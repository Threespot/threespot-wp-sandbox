(function (jquery) {
	'use strict';

	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

	var jquery__default = /*#__PURE__*/_interopDefaultLegacy(jquery);

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var moment = createCommonjsModule(function (module, exports) {
	(function (global, factory) {
	    module.exports = factory() ;
	}(commonjsGlobal, (function () {
	    var hookCallback;

	    function hooks() {
	        return hookCallback.apply(null, arguments);
	    }

	    // This is done to register the method called with moment()
	    // without creating circular dependencies.
	    function setHookCallback(callback) {
	        hookCallback = callback;
	    }

	    function isArray(input) {
	        return (
	            input instanceof Array ||
	            Object.prototype.toString.call(input) === '[object Array]'
	        );
	    }

	    function isObject(input) {
	        // IE8 will treat undefined and null as object if it wasn't for
	        // input != null
	        return (
	            input != null &&
	            Object.prototype.toString.call(input) === '[object Object]'
	        );
	    }

	    function hasOwnProp(a, b) {
	        return Object.prototype.hasOwnProperty.call(a, b);
	    }

	    function isObjectEmpty(obj) {
	        if (Object.getOwnPropertyNames) {
	            return Object.getOwnPropertyNames(obj).length === 0;
	        } else {
	            var k;
	            for (k in obj) {
	                if (hasOwnProp(obj, k)) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }

	    function isUndefined(input) {
	        return input === void 0;
	    }

	    function isNumber(input) {
	        return (
	            typeof input === 'number' ||
	            Object.prototype.toString.call(input) === '[object Number]'
	        );
	    }

	    function isDate(input) {
	        return (
	            input instanceof Date ||
	            Object.prototype.toString.call(input) === '[object Date]'
	        );
	    }

	    function map(arr, fn) {
	        var res = [],
	            i,
	            arrLen = arr.length;
	        for (i = 0; i < arrLen; ++i) {
	            res.push(fn(arr[i], i));
	        }
	        return res;
	    }

	    function extend(a, b) {
	        for (var i in b) {
	            if (hasOwnProp(b, i)) {
	                a[i] = b[i];
	            }
	        }

	        if (hasOwnProp(b, 'toString')) {
	            a.toString = b.toString;
	        }

	        if (hasOwnProp(b, 'valueOf')) {
	            a.valueOf = b.valueOf;
	        }

	        return a;
	    }

	    function createUTC(input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, true).utc();
	    }

	    function defaultParsingFlags() {
	        // We need to deep clone this object.
	        return {
	            empty: false,
	            unusedTokens: [],
	            unusedInput: [],
	            overflow: -2,
	            charsLeftOver: 0,
	            nullInput: false,
	            invalidEra: null,
	            invalidMonth: null,
	            invalidFormat: false,
	            userInvalidated: false,
	            iso: false,
	            parsedDateParts: [],
	            era: null,
	            meridiem: null,
	            rfc2822: false,
	            weekdayMismatch: false,
	        };
	    }

	    function getParsingFlags(m) {
	        if (m._pf == null) {
	            m._pf = defaultParsingFlags();
	        }
	        return m._pf;
	    }

	    var some;
	    if (Array.prototype.some) {
	        some = Array.prototype.some;
	    } else {
	        some = function (fun) {
	            var t = Object(this),
	                len = t.length >>> 0,
	                i;

	            for (i = 0; i < len; i++) {
	                if (i in t && fun.call(this, t[i], i, t)) {
	                    return true;
	                }
	            }

	            return false;
	        };
	    }

	    function isValid(m) {
	        var flags = null,
	            parsedParts = false,
	            isNowValid = m._d && !isNaN(m._d.getTime());
	        if (isNowValid) {
	            flags = getParsingFlags(m);
	            parsedParts = some.call(flags.parsedDateParts, function (i) {
	                return i != null;
	            });
	            isNowValid =
	                flags.overflow < 0 &&
	                !flags.empty &&
	                !flags.invalidEra &&
	                !flags.invalidMonth &&
	                !flags.invalidWeekday &&
	                !flags.weekdayMismatch &&
	                !flags.nullInput &&
	                !flags.invalidFormat &&
	                !flags.userInvalidated &&
	                (!flags.meridiem || (flags.meridiem && parsedParts));
	            if (m._strict) {
	                isNowValid =
	                    isNowValid &&
	                    flags.charsLeftOver === 0 &&
	                    flags.unusedTokens.length === 0 &&
	                    flags.bigHour === undefined;
	            }
	        }
	        if (Object.isFrozen == null || !Object.isFrozen(m)) {
	            m._isValid = isNowValid;
	        } else {
	            return isNowValid;
	        }
	        return m._isValid;
	    }

	    function createInvalid(flags) {
	        var m = createUTC(NaN);
	        if (flags != null) {
	            extend(getParsingFlags(m), flags);
	        } else {
	            getParsingFlags(m).userInvalidated = true;
	        }

	        return m;
	    }

	    // Plugins that add properties should also add the key here (null value),
	    // so we can properly clone ourselves.
	    var momentProperties = (hooks.momentProperties = []),
	        updateInProgress = false;

	    function copyConfig(to, from) {
	        var i,
	            prop,
	            val,
	            momentPropertiesLen = momentProperties.length;

	        if (!isUndefined(from._isAMomentObject)) {
	            to._isAMomentObject = from._isAMomentObject;
	        }
	        if (!isUndefined(from._i)) {
	            to._i = from._i;
	        }
	        if (!isUndefined(from._f)) {
	            to._f = from._f;
	        }
	        if (!isUndefined(from._l)) {
	            to._l = from._l;
	        }
	        if (!isUndefined(from._strict)) {
	            to._strict = from._strict;
	        }
	        if (!isUndefined(from._tzm)) {
	            to._tzm = from._tzm;
	        }
	        if (!isUndefined(from._isUTC)) {
	            to._isUTC = from._isUTC;
	        }
	        if (!isUndefined(from._offset)) {
	            to._offset = from._offset;
	        }
	        if (!isUndefined(from._pf)) {
	            to._pf = getParsingFlags(from);
	        }
	        if (!isUndefined(from._locale)) {
	            to._locale = from._locale;
	        }

	        if (momentPropertiesLen > 0) {
	            for (i = 0; i < momentPropertiesLen; i++) {
	                prop = momentProperties[i];
	                val = from[prop];
	                if (!isUndefined(val)) {
	                    to[prop] = val;
	                }
	            }
	        }

	        return to;
	    }

	    // Moment prototype object
	    function Moment(config) {
	        copyConfig(this, config);
	        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	        if (!this.isValid()) {
	            this._d = new Date(NaN);
	        }
	        // Prevent infinite loop in case updateOffset creates new moment
	        // objects.
	        if (updateInProgress === false) {
	            updateInProgress = true;
	            hooks.updateOffset(this);
	            updateInProgress = false;
	        }
	    }

	    function isMoment(obj) {
	        return (
	            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
	        );
	    }

	    function warn(msg) {
	        if (
	            hooks.suppressDeprecationWarnings === false &&
	            typeof console !== 'undefined' &&
	            console.warn
	        ) {
	            console.warn('Deprecation warning: ' + msg);
	        }
	    }

	    function deprecate(msg, fn) {
	        var firstTime = true;

	        return extend(function () {
	            if (hooks.deprecationHandler != null) {
	                hooks.deprecationHandler(null, msg);
	            }
	            if (firstTime) {
	                var args = [],
	                    arg,
	                    i,
	                    key,
	                    argLen = arguments.length;
	                for (i = 0; i < argLen; i++) {
	                    arg = '';
	                    if (typeof arguments[i] === 'object') {
	                        arg += '\n[' + i + '] ';
	                        for (key in arguments[0]) {
	                            if (hasOwnProp(arguments[0], key)) {
	                                arg += key + ': ' + arguments[0][key] + ', ';
	                            }
	                        }
	                        arg = arg.slice(0, -2); // Remove trailing comma and space
	                    } else {
	                        arg = arguments[i];
	                    }
	                    args.push(arg);
	                }
	                warn(
	                    msg +
	                        '\nArguments: ' +
	                        Array.prototype.slice.call(args).join('') +
	                        '\n' +
	                        new Error().stack
	                );
	                firstTime = false;
	            }
	            return fn.apply(this, arguments);
	        }, fn);
	    }

	    var deprecations = {};

	    function deprecateSimple(name, msg) {
	        if (hooks.deprecationHandler != null) {
	            hooks.deprecationHandler(name, msg);
	        }
	        if (!deprecations[name]) {
	            warn(msg);
	            deprecations[name] = true;
	        }
	    }

	    hooks.suppressDeprecationWarnings = false;
	    hooks.deprecationHandler = null;

	    function isFunction(input) {
	        return (
	            (typeof Function !== 'undefined' && input instanceof Function) ||
	            Object.prototype.toString.call(input) === '[object Function]'
	        );
	    }

	    function set(config) {
	        var prop, i;
	        for (i in config) {
	            if (hasOwnProp(config, i)) {
	                prop = config[i];
	                if (isFunction(prop)) {
	                    this[i] = prop;
	                } else {
	                    this['_' + i] = prop;
	                }
	            }
	        }
	        this._config = config;
	        // Lenient ordinal parsing accepts just a number in addition to
	        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
	        // TODO: Remove "ordinalParse" fallback in next major release.
	        this._dayOfMonthOrdinalParseLenient = new RegExp(
	            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
	                '|' +
	                /\d{1,2}/.source
	        );
	    }

	    function mergeConfigs(parentConfig, childConfig) {
	        var res = extend({}, parentConfig),
	            prop;
	        for (prop in childConfig) {
	            if (hasOwnProp(childConfig, prop)) {
	                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                    res[prop] = {};
	                    extend(res[prop], parentConfig[prop]);
	                    extend(res[prop], childConfig[prop]);
	                } else if (childConfig[prop] != null) {
	                    res[prop] = childConfig[prop];
	                } else {
	                    delete res[prop];
	                }
	            }
	        }
	        for (prop in parentConfig) {
	            if (
	                hasOwnProp(parentConfig, prop) &&
	                !hasOwnProp(childConfig, prop) &&
	                isObject(parentConfig[prop])
	            ) {
	                // make sure changes to properties don't modify parent config
	                res[prop] = extend({}, res[prop]);
	            }
	        }
	        return res;
	    }

	    function Locale(config) {
	        if (config != null) {
	            this.set(config);
	        }
	    }

	    var keys;

	    if (Object.keys) {
	        keys = Object.keys;
	    } else {
	        keys = function (obj) {
	            var i,
	                res = [];
	            for (i in obj) {
	                if (hasOwnProp(obj, i)) {
	                    res.push(i);
	                }
	            }
	            return res;
	        };
	    }

	    var defaultCalendar = {
	        sameDay: '[Today at] LT',
	        nextDay: '[Tomorrow at] LT',
	        nextWeek: 'dddd [at] LT',
	        lastDay: '[Yesterday at] LT',
	        lastWeek: '[Last] dddd [at] LT',
	        sameElse: 'L',
	    };

	    function calendar(key, mom, now) {
	        var output = this._calendar[key] || this._calendar['sameElse'];
	        return isFunction(output) ? output.call(mom, now) : output;
	    }

	    function zeroFill(number, targetLength, forceSign) {
	        var absNumber = '' + Math.abs(number),
	            zerosToFill = targetLength - absNumber.length,
	            sign = number >= 0;
	        return (
	            (sign ? (forceSign ? '+' : '') : '-') +
	            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
	            absNumber
	        );
	    }

	    var formattingTokens =
	            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
	        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
	        formatFunctions = {},
	        formatTokenFunctions = {};

	    // token:    'M'
	    // padded:   ['MM', 2]
	    // ordinal:  'Mo'
	    // callback: function () { this.month() + 1 }
	    function addFormatToken(token, padded, ordinal, callback) {
	        var func = callback;
	        if (typeof callback === 'string') {
	            func = function () {
	                return this[callback]();
	            };
	        }
	        if (token) {
	            formatTokenFunctions[token] = func;
	        }
	        if (padded) {
	            formatTokenFunctions[padded[0]] = function () {
	                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	            };
	        }
	        if (ordinal) {
	            formatTokenFunctions[ordinal] = function () {
	                return this.localeData().ordinal(
	                    func.apply(this, arguments),
	                    token
	                );
	            };
	        }
	    }

	    function removeFormattingTokens(input) {
	        if (input.match(/\[[\s\S]/)) {
	            return input.replace(/^\[|\]$/g, '');
	        }
	        return input.replace(/\\/g, '');
	    }

	    function makeFormatFunction(format) {
	        var array = format.match(formattingTokens),
	            i,
	            length;

	        for (i = 0, length = array.length; i < length; i++) {
	            if (formatTokenFunctions[array[i]]) {
	                array[i] = formatTokenFunctions[array[i]];
	            } else {
	                array[i] = removeFormattingTokens(array[i]);
	            }
	        }

	        return function (mom) {
	            var output = '',
	                i;
	            for (i = 0; i < length; i++) {
	                output += isFunction(array[i])
	                    ? array[i].call(mom, format)
	                    : array[i];
	            }
	            return output;
	        };
	    }

	    // format date using native date object
	    function formatMoment(m, format) {
	        if (!m.isValid()) {
	            return m.localeData().invalidDate();
	        }

	        format = expandFormat(format, m.localeData());
	        formatFunctions[format] =
	            formatFunctions[format] || makeFormatFunction(format);

	        return formatFunctions[format](m);
	    }

	    function expandFormat(format, locale) {
	        var i = 5;

	        function replaceLongDateFormatTokens(input) {
	            return locale.longDateFormat(input) || input;
	        }

	        localFormattingTokens.lastIndex = 0;
	        while (i >= 0 && localFormattingTokens.test(format)) {
	            format = format.replace(
	                localFormattingTokens,
	                replaceLongDateFormatTokens
	            );
	            localFormattingTokens.lastIndex = 0;
	            i -= 1;
	        }

	        return format;
	    }

	    var defaultLongDateFormat = {
	        LTS: 'h:mm:ss A',
	        LT: 'h:mm A',
	        L: 'MM/DD/YYYY',
	        LL: 'MMMM D, YYYY',
	        LLL: 'MMMM D, YYYY h:mm A',
	        LLLL: 'dddd, MMMM D, YYYY h:mm A',
	    };

	    function longDateFormat(key) {
	        var format = this._longDateFormat[key],
	            formatUpper = this._longDateFormat[key.toUpperCase()];

	        if (format || !formatUpper) {
	            return format;
	        }

	        this._longDateFormat[key] = formatUpper
	            .match(formattingTokens)
	            .map(function (tok) {
	                if (
	                    tok === 'MMMM' ||
	                    tok === 'MM' ||
	                    tok === 'DD' ||
	                    tok === 'dddd'
	                ) {
	                    return tok.slice(1);
	                }
	                return tok;
	            })
	            .join('');

	        return this._longDateFormat[key];
	    }

	    var defaultInvalidDate = 'Invalid date';

	    function invalidDate() {
	        return this._invalidDate;
	    }

	    var defaultOrdinal = '%d',
	        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

	    function ordinal(number) {
	        return this._ordinal.replace('%d', number);
	    }

	    var defaultRelativeTime = {
	        future: 'in %s',
	        past: '%s ago',
	        s: 'a few seconds',
	        ss: '%d seconds',
	        m: 'a minute',
	        mm: '%d minutes',
	        h: 'an hour',
	        hh: '%d hours',
	        d: 'a day',
	        dd: '%d days',
	        w: 'a week',
	        ww: '%d weeks',
	        M: 'a month',
	        MM: '%d months',
	        y: 'a year',
	        yy: '%d years',
	    };

	    function relativeTime(number, withoutSuffix, string, isFuture) {
	        var output = this._relativeTime[string];
	        return isFunction(output)
	            ? output(number, withoutSuffix, string, isFuture)
	            : output.replace(/%d/i, number);
	    }

	    function pastFuture(diff, output) {
	        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	    }

	    var aliases = {
	        D: 'date',
	        dates: 'date',
	        date: 'date',
	        d: 'day',
	        days: 'day',
	        day: 'day',
	        e: 'weekday',
	        weekdays: 'weekday',
	        weekday: 'weekday',
	        E: 'isoWeekday',
	        isoweekdays: 'isoWeekday',
	        isoweekday: 'isoWeekday',
	        DDD: 'dayOfYear',
	        dayofyears: 'dayOfYear',
	        dayofyear: 'dayOfYear',
	        h: 'hour',
	        hours: 'hour',
	        hour: 'hour',
	        ms: 'millisecond',
	        milliseconds: 'millisecond',
	        millisecond: 'millisecond',
	        m: 'minute',
	        minutes: 'minute',
	        minute: 'minute',
	        M: 'month',
	        months: 'month',
	        month: 'month',
	        Q: 'quarter',
	        quarters: 'quarter',
	        quarter: 'quarter',
	        s: 'second',
	        seconds: 'second',
	        second: 'second',
	        gg: 'weekYear',
	        weekyears: 'weekYear',
	        weekyear: 'weekYear',
	        GG: 'isoWeekYear',
	        isoweekyears: 'isoWeekYear',
	        isoweekyear: 'isoWeekYear',
	        w: 'week',
	        weeks: 'week',
	        week: 'week',
	        W: 'isoWeek',
	        isoweeks: 'isoWeek',
	        isoweek: 'isoWeek',
	        y: 'year',
	        years: 'year',
	        year: 'year',
	    };

	    function normalizeUnits(units) {
	        return typeof units === 'string'
	            ? aliases[units] || aliases[units.toLowerCase()]
	            : undefined;
	    }

	    function normalizeObjectUnits(inputObject) {
	        var normalizedInput = {},
	            normalizedProp,
	            prop;

	        for (prop in inputObject) {
	            if (hasOwnProp(inputObject, prop)) {
	                normalizedProp = normalizeUnits(prop);
	                if (normalizedProp) {
	                    normalizedInput[normalizedProp] = inputObject[prop];
	                }
	            }
	        }

	        return normalizedInput;
	    }

	    var priorities = {
	        date: 9,
	        day: 11,
	        weekday: 11,
	        isoWeekday: 11,
	        dayOfYear: 4,
	        hour: 13,
	        millisecond: 16,
	        minute: 14,
	        month: 8,
	        quarter: 7,
	        second: 15,
	        weekYear: 1,
	        isoWeekYear: 1,
	        week: 5,
	        isoWeek: 5,
	        year: 1,
	    };

	    function getPrioritizedUnits(unitsObj) {
	        var units = [],
	            u;
	        for (u in unitsObj) {
	            if (hasOwnProp(unitsObj, u)) {
	                units.push({ unit: u, priority: priorities[u] });
	            }
	        }
	        units.sort(function (a, b) {
	            return a.priority - b.priority;
	        });
	        return units;
	    }

	    var match1 = /\d/, //       0 - 9
	        match2 = /\d\d/, //      00 - 99
	        match3 = /\d{3}/, //     000 - 999
	        match4 = /\d{4}/, //    0000 - 9999
	        match6 = /[+-]?\d{6}/, // -999999 - 999999
	        match1to2 = /\d\d?/, //       0 - 99
	        match3to4 = /\d\d\d\d?/, //     999 - 9999
	        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
	        match1to3 = /\d{1,3}/, //       0 - 999
	        match1to4 = /\d{1,4}/, //       0 - 9999
	        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
	        matchUnsigned = /\d+/, //       0 - inf
	        matchSigned = /[+-]?\d+/, //    -inf - inf
	        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
	        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
	        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
	        // any word (or two) characters or numbers including two/three word month in arabic.
	        // includes scottish gaelic two word and hyphenated months
	        matchWord =
	            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
	        match1to2NoLeadingZero = /^[1-9]\d?/, //         1-99
	        match1to2HasZero = /^([1-9]\d|\d)/, //           0-99
	        regexes;

	    regexes = {};

	    function addRegexToken(token, regex, strictRegex) {
	        regexes[token] = isFunction(regex)
	            ? regex
	            : function (isStrict, localeData) {
	                  return isStrict && strictRegex ? strictRegex : regex;
	              };
	    }

	    function getParseRegexForToken(token, config) {
	        if (!hasOwnProp(regexes, token)) {
	            return new RegExp(unescapeFormat(token));
	        }

	        return regexes[token](config._strict, config._locale);
	    }

	    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	    function unescapeFormat(s) {
	        return regexEscape(
	            s
	                .replace('\\', '')
	                .replace(
	                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
	                    function (matched, p1, p2, p3, p4) {
	                        return p1 || p2 || p3 || p4;
	                    }
	                )
	        );
	    }

	    function regexEscape(s) {
	        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	    }

	    function absFloor(number) {
	        if (number < 0) {
	            // -0 -> 0
	            return Math.ceil(number) || 0;
	        } else {
	            return Math.floor(number);
	        }
	    }

	    function toInt(argumentForCoercion) {
	        var coercedNumber = +argumentForCoercion,
	            value = 0;

	        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	            value = absFloor(coercedNumber);
	        }

	        return value;
	    }

	    var tokens = {};

	    function addParseToken(token, callback) {
	        var i,
	            func = callback,
	            tokenLen;
	        if (typeof token === 'string') {
	            token = [token];
	        }
	        if (isNumber(callback)) {
	            func = function (input, array) {
	                array[callback] = toInt(input);
	            };
	        }
	        tokenLen = token.length;
	        for (i = 0; i < tokenLen; i++) {
	            tokens[token[i]] = func;
	        }
	    }

	    function addWeekParseToken(token, callback) {
	        addParseToken(token, function (input, array, config, token) {
	            config._w = config._w || {};
	            callback(input, config._w, config, token);
	        });
	    }

	    function addTimeToArrayFromToken(token, input, config) {
	        if (input != null && hasOwnProp(tokens, token)) {
	            tokens[token](input, config._a, config, token);
	        }
	    }

	    function isLeapYear(year) {
	        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	    }

	    var YEAR = 0,
	        MONTH = 1,
	        DATE = 2,
	        HOUR = 3,
	        MINUTE = 4,
	        SECOND = 5,
	        MILLISECOND = 6,
	        WEEK = 7,
	        WEEKDAY = 8;

	    // FORMATTING

	    addFormatToken('Y', 0, 0, function () {
	        var y = this.year();
	        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
	    });

	    addFormatToken(0, ['YY', 2], 0, function () {
	        return this.year() % 100;
	    });

	    addFormatToken(0, ['YYYY', 4], 0, 'year');
	    addFormatToken(0, ['YYYYY', 5], 0, 'year');
	    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

	    // PARSING

	    addRegexToken('Y', matchSigned);
	    addRegexToken('YY', match1to2, match2);
	    addRegexToken('YYYY', match1to4, match4);
	    addRegexToken('YYYYY', match1to6, match6);
	    addRegexToken('YYYYYY', match1to6, match6);

	    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	    addParseToken('YYYY', function (input, array) {
	        array[YEAR] =
	            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	    });
	    addParseToken('YY', function (input, array) {
	        array[YEAR] = hooks.parseTwoDigitYear(input);
	    });
	    addParseToken('Y', function (input, array) {
	        array[YEAR] = parseInt(input, 10);
	    });

	    // HELPERS

	    function daysInYear(year) {
	        return isLeapYear(year) ? 366 : 365;
	    }

	    // HOOKS

	    hooks.parseTwoDigitYear = function (input) {
	        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	    };

	    // MOMENTS

	    var getSetYear = makeGetSet('FullYear', true);

	    function getIsLeapYear() {
	        return isLeapYear(this.year());
	    }

	    function makeGetSet(unit, keepTime) {
	        return function (value) {
	            if (value != null) {
	                set$1(this, unit, value);
	                hooks.updateOffset(this, keepTime);
	                return this;
	            } else {
	                return get(this, unit);
	            }
	        };
	    }

	    function get(mom, unit) {
	        if (!mom.isValid()) {
	            return NaN;
	        }

	        var d = mom._d,
	            isUTC = mom._isUTC;

	        switch (unit) {
	            case 'Milliseconds':
	                return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
	            case 'Seconds':
	                return isUTC ? d.getUTCSeconds() : d.getSeconds();
	            case 'Minutes':
	                return isUTC ? d.getUTCMinutes() : d.getMinutes();
	            case 'Hours':
	                return isUTC ? d.getUTCHours() : d.getHours();
	            case 'Date':
	                return isUTC ? d.getUTCDate() : d.getDate();
	            case 'Day':
	                return isUTC ? d.getUTCDay() : d.getDay();
	            case 'Month':
	                return isUTC ? d.getUTCMonth() : d.getMonth();
	            case 'FullYear':
	                return isUTC ? d.getUTCFullYear() : d.getFullYear();
	            default:
	                return NaN; // Just in case
	        }
	    }

	    function set$1(mom, unit, value) {
	        var d, isUTC, year, month, date;

	        if (!mom.isValid() || isNaN(value)) {
	            return;
	        }

	        d = mom._d;
	        isUTC = mom._isUTC;

	        switch (unit) {
	            case 'Milliseconds':
	                return void (isUTC
	                    ? d.setUTCMilliseconds(value)
	                    : d.setMilliseconds(value));
	            case 'Seconds':
	                return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
	            case 'Minutes':
	                return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
	            case 'Hours':
	                return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
	            case 'Date':
	                return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
	            // case 'Day': // Not real
	            //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
	            // case 'Month': // Not used because we need to pass two variables
	            //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
	            case 'FullYear':
	                break; // See below ...
	            default:
	                return; // Just in case
	        }

	        year = value;
	        month = mom.month();
	        date = mom.date();
	        date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
	        void (isUTC
	            ? d.setUTCFullYear(year, month, date)
	            : d.setFullYear(year, month, date));
	    }

	    // MOMENTS

	    function stringGet(units) {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units]();
	        }
	        return this;
	    }

	    function stringSet(units, value) {
	        if (typeof units === 'object') {
	            units = normalizeObjectUnits(units);
	            var prioritized = getPrioritizedUnits(units),
	                i,
	                prioritizedLen = prioritized.length;
	            for (i = 0; i < prioritizedLen; i++) {
	                this[prioritized[i].unit](units[prioritized[i].unit]);
	            }
	        } else {
	            units = normalizeUnits(units);
	            if (isFunction(this[units])) {
	                return this[units](value);
	            }
	        }
	        return this;
	    }

	    function mod(n, x) {
	        return ((n % x) + x) % x;
	    }

	    var indexOf;

	    if (Array.prototype.indexOf) {
	        indexOf = Array.prototype.indexOf;
	    } else {
	        indexOf = function (o) {
	            // I know
	            var i;
	            for (i = 0; i < this.length; ++i) {
	                if (this[i] === o) {
	                    return i;
	                }
	            }
	            return -1;
	        };
	    }

	    function daysInMonth(year, month) {
	        if (isNaN(year) || isNaN(month)) {
	            return NaN;
	        }
	        var modMonth = mod(month, 12);
	        year += (month - modMonth) / 12;
	        return modMonth === 1
	            ? isLeapYear(year)
	                ? 29
	                : 28
	            : 31 - ((modMonth % 7) % 2);
	    }

	    // FORMATTING

	    addFormatToken('M', ['MM', 2], 'Mo', function () {
	        return this.month() + 1;
	    });

	    addFormatToken('MMM', 0, 0, function (format) {
	        return this.localeData().monthsShort(this, format);
	    });

	    addFormatToken('MMMM', 0, 0, function (format) {
	        return this.localeData().months(this, format);
	    });

	    // PARSING

	    addRegexToken('M', match1to2, match1to2NoLeadingZero);
	    addRegexToken('MM', match1to2, match2);
	    addRegexToken('MMM', function (isStrict, locale) {
	        return locale.monthsShortRegex(isStrict);
	    });
	    addRegexToken('MMMM', function (isStrict, locale) {
	        return locale.monthsRegex(isStrict);
	    });

	    addParseToken(['M', 'MM'], function (input, array) {
	        array[MONTH] = toInt(input) - 1;
	    });

	    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	        var month = config._locale.monthsParse(input, token, config._strict);
	        // if we didn't find a month name, mark the date as invalid.
	        if (month != null) {
	            array[MONTH] = month;
	        } else {
	            getParsingFlags(config).invalidMonth = input;
	        }
	    });

	    // LOCALES

	    var defaultLocaleMonths =
	            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
	                '_'
	            ),
	        defaultLocaleMonthsShort =
	            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
	        defaultMonthsShortRegex = matchWord,
	        defaultMonthsRegex = matchWord;

	    function localeMonths(m, format) {
	        if (!m) {
	            return isArray(this._months)
	                ? this._months
	                : this._months['standalone'];
	        }
	        return isArray(this._months)
	            ? this._months[m.month()]
	            : this._months[
	                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
	                      ? 'format'
	                      : 'standalone'
	              ][m.month()];
	    }

	    function localeMonthsShort(m, format) {
	        if (!m) {
	            return isArray(this._monthsShort)
	                ? this._monthsShort
	                : this._monthsShort['standalone'];
	        }
	        return isArray(this._monthsShort)
	            ? this._monthsShort[m.month()]
	            : this._monthsShort[
	                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
	              ][m.month()];
	    }

	    function handleStrictParse(monthName, format, strict) {
	        var i,
	            ii,
	            mom,
	            llc = monthName.toLocaleLowerCase();
	        if (!this._monthsParse) {
	            // this is not used
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	            for (i = 0; i < 12; ++i) {
	                mom = createUTC([2000, i]);
	                this._shortMonthsParse[i] = this.monthsShort(
	                    mom,
	                    ''
	                ).toLocaleLowerCase();
	                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	            }
	        }

	        if (strict) {
	            if (format === 'MMM') {
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._longMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        } else {
	            if (format === 'MMM') {
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._longMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._longMonthsParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortMonthsParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        }
	    }

	    function localeMonthsParse(monthName, format, strict) {
	        var i, mom, regex;

	        if (this._monthsParseExact) {
	            return handleStrictParse.call(this, monthName, format, strict);
	        }

	        if (!this._monthsParse) {
	            this._monthsParse = [];
	            this._longMonthsParse = [];
	            this._shortMonthsParse = [];
	        }

	        // TODO: add sorting
	        // Sorting makes sure if one month (or abbr) is a prefix of another
	        // see sorting in computeMonthsParse
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = createUTC([2000, i]);
	            if (strict && !this._longMonthsParse[i]) {
	                this._longMonthsParse[i] = new RegExp(
	                    '^' + this.months(mom, '').replace('.', '') + '$',
	                    'i'
	                );
	                this._shortMonthsParse[i] = new RegExp(
	                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
	                    'i'
	                );
	            }
	            if (!strict && !this._monthsParse[i]) {
	                regex =
	                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (
	                strict &&
	                format === 'MMMM' &&
	                this._longMonthsParse[i].test(monthName)
	            ) {
	                return i;
	            } else if (
	                strict &&
	                format === 'MMM' &&
	                this._shortMonthsParse[i].test(monthName)
	            ) {
	                return i;
	            } else if (!strict && this._monthsParse[i].test(monthName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function setMonth(mom, value) {
	        if (!mom.isValid()) {
	            // No op
	            return mom;
	        }

	        if (typeof value === 'string') {
	            if (/^\d+$/.test(value)) {
	                value = toInt(value);
	            } else {
	                value = mom.localeData().monthsParse(value);
	                // TODO: Another silent failure?
	                if (!isNumber(value)) {
	                    return mom;
	                }
	            }
	        }

	        var month = value,
	            date = mom.date();

	        date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
	        void (mom._isUTC
	            ? mom._d.setUTCMonth(month, date)
	            : mom._d.setMonth(month, date));
	        return mom;
	    }

	    function getSetMonth(value) {
	        if (value != null) {
	            setMonth(this, value);
	            hooks.updateOffset(this, true);
	            return this;
	        } else {
	            return get(this, 'Month');
	        }
	    }

	    function getDaysInMonth() {
	        return daysInMonth(this.year(), this.month());
	    }

	    function monthsShortRegex(isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsShortStrictRegex;
	            } else {
	                return this._monthsShortRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_monthsShortRegex')) {
	                this._monthsShortRegex = defaultMonthsShortRegex;
	            }
	            return this._monthsShortStrictRegex && isStrict
	                ? this._monthsShortStrictRegex
	                : this._monthsShortRegex;
	        }
	    }

	    function monthsRegex(isStrict) {
	        if (this._monthsParseExact) {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                computeMonthsParse.call(this);
	            }
	            if (isStrict) {
	                return this._monthsStrictRegex;
	            } else {
	                return this._monthsRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_monthsRegex')) {
	                this._monthsRegex = defaultMonthsRegex;
	            }
	            return this._monthsStrictRegex && isStrict
	                ? this._monthsStrictRegex
	                : this._monthsRegex;
	        }
	    }

	    function computeMonthsParse() {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }

	        var shortPieces = [],
	            longPieces = [],
	            mixedPieces = [],
	            i,
	            mom,
	            shortP,
	            longP;
	        for (i = 0; i < 12; i++) {
	            // make the regex if we don't have it already
	            mom = createUTC([2000, i]);
	            shortP = regexEscape(this.monthsShort(mom, ''));
	            longP = regexEscape(this.months(mom, ''));
	            shortPieces.push(shortP);
	            longPieces.push(longP);
	            mixedPieces.push(longP);
	            mixedPieces.push(shortP);
	        }
	        // Sorting makes sure if one month (or abbr) is a prefix of another it
	        // will match the longer piece.
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);

	        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._monthsShortRegex = this._monthsRegex;
	        this._monthsStrictRegex = new RegExp(
	            '^(' + longPieces.join('|') + ')',
	            'i'
	        );
	        this._monthsShortStrictRegex = new RegExp(
	            '^(' + shortPieces.join('|') + ')',
	            'i'
	        );
	    }

	    function createDate(y, m, d, h, M, s, ms) {
	        // can't just apply() to create a date:
	        // https://stackoverflow.com/q/181348
	        var date;
	        // the date constructor remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0) {
	            // preserve leap years using a full 400 year cycle, then reset
	            date = new Date(y + 400, m, d, h, M, s, ms);
	            if (isFinite(date.getFullYear())) {
	                date.setFullYear(y);
	            }
	        } else {
	            date = new Date(y, m, d, h, M, s, ms);
	        }

	        return date;
	    }

	    function createUTCDate(y) {
	        var date, args;
	        // the Date.UTC function remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0) {
	            args = Array.prototype.slice.call(arguments);
	            // preserve leap years using a full 400 year cycle, then reset
	            args[0] = y + 400;
	            date = new Date(Date.UTC.apply(null, args));
	            if (isFinite(date.getUTCFullYear())) {
	                date.setUTCFullYear(y);
	            }
	        } else {
	            date = new Date(Date.UTC.apply(null, arguments));
	        }

	        return date;
	    }

	    // start-of-first-week - start-of-year
	    function firstWeekOffset(year, dow, doy) {
	        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	            fwd = 7 + dow - doy,
	            // first-week day local weekday -- which local weekday is fwd
	            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

	        return -fwdlw + fwd - 1;
	    }

	    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	        var localWeekday = (7 + weekday - dow) % 7,
	            weekOffset = firstWeekOffset(year, dow, doy),
	            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	            resYear,
	            resDayOfYear;

	        if (dayOfYear <= 0) {
	            resYear = year - 1;
	            resDayOfYear = daysInYear(resYear) + dayOfYear;
	        } else if (dayOfYear > daysInYear(year)) {
	            resYear = year + 1;
	            resDayOfYear = dayOfYear - daysInYear(year);
	        } else {
	            resYear = year;
	            resDayOfYear = dayOfYear;
	        }

	        return {
	            year: resYear,
	            dayOfYear: resDayOfYear,
	        };
	    }

	    function weekOfYear(mom, dow, doy) {
	        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	            resWeek,
	            resYear;

	        if (week < 1) {
	            resYear = mom.year() - 1;
	            resWeek = week + weeksInYear(resYear, dow, doy);
	        } else if (week > weeksInYear(mom.year(), dow, doy)) {
	            resWeek = week - weeksInYear(mom.year(), dow, doy);
	            resYear = mom.year() + 1;
	        } else {
	            resYear = mom.year();
	            resWeek = week;
	        }

	        return {
	            week: resWeek,
	            year: resYear,
	        };
	    }

	    function weeksInYear(year, dow, doy) {
	        var weekOffset = firstWeekOffset(year, dow, doy),
	            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	    }

	    // FORMATTING

	    addFormatToken('w', ['ww', 2], 'wo', 'week');
	    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

	    // PARSING

	    addRegexToken('w', match1to2, match1to2NoLeadingZero);
	    addRegexToken('ww', match1to2, match2);
	    addRegexToken('W', match1to2, match1to2NoLeadingZero);
	    addRegexToken('WW', match1to2, match2);

	    addWeekParseToken(
	        ['w', 'ww', 'W', 'WW'],
	        function (input, week, config, token) {
	            week[token.substr(0, 1)] = toInt(input);
	        }
	    );

	    // HELPERS

	    // LOCALES

	    function localeWeek(mom) {
	        return weekOfYear(mom, this._week.dow, this._week.doy).week;
	    }

	    var defaultLocaleWeek = {
	        dow: 0, // Sunday is the first day of the week.
	        doy: 6, // The week that contains Jan 6th is the first week of the year.
	    };

	    function localeFirstDayOfWeek() {
	        return this._week.dow;
	    }

	    function localeFirstDayOfYear() {
	        return this._week.doy;
	    }

	    // MOMENTS

	    function getSetWeek(input) {
	        var week = this.localeData().week(this);
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    function getSetISOWeek(input) {
	        var week = weekOfYear(this, 1, 4).week;
	        return input == null ? week : this.add((input - week) * 7, 'd');
	    }

	    // FORMATTING

	    addFormatToken('d', 0, 'do', 'day');

	    addFormatToken('dd', 0, 0, function (format) {
	        return this.localeData().weekdaysMin(this, format);
	    });

	    addFormatToken('ddd', 0, 0, function (format) {
	        return this.localeData().weekdaysShort(this, format);
	    });

	    addFormatToken('dddd', 0, 0, function (format) {
	        return this.localeData().weekdays(this, format);
	    });

	    addFormatToken('e', 0, 0, 'weekday');
	    addFormatToken('E', 0, 0, 'isoWeekday');

	    // PARSING

	    addRegexToken('d', match1to2);
	    addRegexToken('e', match1to2);
	    addRegexToken('E', match1to2);
	    addRegexToken('dd', function (isStrict, locale) {
	        return locale.weekdaysMinRegex(isStrict);
	    });
	    addRegexToken('ddd', function (isStrict, locale) {
	        return locale.weekdaysShortRegex(isStrict);
	    });
	    addRegexToken('dddd', function (isStrict, locale) {
	        return locale.weekdaysRegex(isStrict);
	    });

	    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	        var weekday = config._locale.weekdaysParse(input, token, config._strict);
	        // if we didn't get a weekday name, mark the date as invalid
	        if (weekday != null) {
	            week.d = weekday;
	        } else {
	            getParsingFlags(config).invalidWeekday = input;
	        }
	    });

	    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	        week[token] = toInt(input);
	    });

	    // HELPERS

	    function parseWeekday(input, locale) {
	        if (typeof input !== 'string') {
	            return input;
	        }

	        if (!isNaN(input)) {
	            return parseInt(input, 10);
	        }

	        input = locale.weekdaysParse(input);
	        if (typeof input === 'number') {
	            return input;
	        }

	        return null;
	    }

	    function parseIsoWeekday(input, locale) {
	        if (typeof input === 'string') {
	            return locale.weekdaysParse(input) % 7 || 7;
	        }
	        return isNaN(input) ? null : input;
	    }

	    // LOCALES
	    function shiftWeekdays(ws, n) {
	        return ws.slice(n, 7).concat(ws.slice(0, n));
	    }

	    var defaultLocaleWeekdays =
	            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	        defaultWeekdaysRegex = matchWord,
	        defaultWeekdaysShortRegex = matchWord,
	        defaultWeekdaysMinRegex = matchWord;

	    function localeWeekdays(m, format) {
	        var weekdays = isArray(this._weekdays)
	            ? this._weekdays
	            : this._weekdays[
	                  m && m !== true && this._weekdays.isFormat.test(format)
	                      ? 'format'
	                      : 'standalone'
	              ];
	        return m === true
	            ? shiftWeekdays(weekdays, this._week.dow)
	            : m
	              ? weekdays[m.day()]
	              : weekdays;
	    }

	    function localeWeekdaysShort(m) {
	        return m === true
	            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
	            : m
	              ? this._weekdaysShort[m.day()]
	              : this._weekdaysShort;
	    }

	    function localeWeekdaysMin(m) {
	        return m === true
	            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
	            : m
	              ? this._weekdaysMin[m.day()]
	              : this._weekdaysMin;
	    }

	    function handleStrictParse$1(weekdayName, format, strict) {
	        var i,
	            ii,
	            mom,
	            llc = weekdayName.toLocaleLowerCase();
	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._minWeekdaysParse = [];

	            for (i = 0; i < 7; ++i) {
	                mom = createUTC([2000, 1]).day(i);
	                this._minWeekdaysParse[i] = this.weekdaysMin(
	                    mom,
	                    ''
	                ).toLocaleLowerCase();
	                this._shortWeekdaysParse[i] = this.weekdaysShort(
	                    mom,
	                    ''
	                ).toLocaleLowerCase();
	                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	            }
	        }

	        if (strict) {
	            if (format === 'dddd') {
	                ii = indexOf.call(this._weekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else if (format === 'ddd') {
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        } else {
	            if (format === 'dddd') {
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else if (format === 'ddd') {
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            } else {
	                ii = indexOf.call(this._minWeekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._weekdaysParse, llc);
	                if (ii !== -1) {
	                    return ii;
	                }
	                ii = indexOf.call(this._shortWeekdaysParse, llc);
	                return ii !== -1 ? ii : null;
	            }
	        }
	    }

	    function localeWeekdaysParse(weekdayName, format, strict) {
	        var i, mom, regex;

	        if (this._weekdaysParseExact) {
	            return handleStrictParse$1.call(this, weekdayName, format, strict);
	        }

	        if (!this._weekdaysParse) {
	            this._weekdaysParse = [];
	            this._minWeekdaysParse = [];
	            this._shortWeekdaysParse = [];
	            this._fullWeekdaysParse = [];
	        }

	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already

	            mom = createUTC([2000, 1]).day(i);
	            if (strict && !this._fullWeekdaysParse[i]) {
	                this._fullWeekdaysParse[i] = new RegExp(
	                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
	                    'i'
	                );
	                this._shortWeekdaysParse[i] = new RegExp(
	                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
	                    'i'
	                );
	                this._minWeekdaysParse[i] = new RegExp(
	                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
	                    'i'
	                );
	            }
	            if (!this._weekdaysParse[i]) {
	                regex =
	                    '^' +
	                    this.weekdays(mom, '') +
	                    '|^' +
	                    this.weekdaysShort(mom, '') +
	                    '|^' +
	                    this.weekdaysMin(mom, '');
	                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	            }
	            // test the regex
	            if (
	                strict &&
	                format === 'dddd' &&
	                this._fullWeekdaysParse[i].test(weekdayName)
	            ) {
	                return i;
	            } else if (
	                strict &&
	                format === 'ddd' &&
	                this._shortWeekdaysParse[i].test(weekdayName)
	            ) {
	                return i;
	            } else if (
	                strict &&
	                format === 'dd' &&
	                this._minWeekdaysParse[i].test(weekdayName)
	            ) {
	                return i;
	            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	                return i;
	            }
	        }
	    }

	    // MOMENTS

	    function getSetDayOfWeek(input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }

	        var day = get(this, 'Day');
	        if (input != null) {
	            input = parseWeekday(input, this.localeData());
	            return this.add(input - day, 'd');
	        } else {
	            return day;
	        }
	    }

	    function getSetLocaleDayOfWeek(input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	        return input == null ? weekday : this.add(input - weekday, 'd');
	    }

	    function getSetISODayOfWeek(input) {
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }

	        // behaves the same as moment#day except
	        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	        // as a setter, sunday should belong to the previous week.

	        if (input != null) {
	            var weekday = parseIsoWeekday(input, this.localeData());
	            return this.day(this.day() % 7 ? weekday : weekday - 7);
	        } else {
	            return this.day() || 7;
	        }
	    }

	    function weekdaysRegex(isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysStrictRegex;
	            } else {
	                return this._weekdaysRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                this._weekdaysRegex = defaultWeekdaysRegex;
	            }
	            return this._weekdaysStrictRegex && isStrict
	                ? this._weekdaysStrictRegex
	                : this._weekdaysRegex;
	        }
	    }

	    function weekdaysShortRegex(isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysShortStrictRegex;
	            } else {
	                return this._weekdaysShortRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	            }
	            return this._weekdaysShortStrictRegex && isStrict
	                ? this._weekdaysShortStrictRegex
	                : this._weekdaysShortRegex;
	        }
	    }

	    function weekdaysMinRegex(isStrict) {
	        if (this._weekdaysParseExact) {
	            if (!hasOwnProp(this, '_weekdaysRegex')) {
	                computeWeekdaysParse.call(this);
	            }
	            if (isStrict) {
	                return this._weekdaysMinStrictRegex;
	            } else {
	                return this._weekdaysMinRegex;
	            }
	        } else {
	            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	            }
	            return this._weekdaysMinStrictRegex && isStrict
	                ? this._weekdaysMinStrictRegex
	                : this._weekdaysMinRegex;
	        }
	    }

	    function computeWeekdaysParse() {
	        function cmpLenRev(a, b) {
	            return b.length - a.length;
	        }

	        var minPieces = [],
	            shortPieces = [],
	            longPieces = [],
	            mixedPieces = [],
	            i,
	            mom,
	            minp,
	            shortp,
	            longp;
	        for (i = 0; i < 7; i++) {
	            // make the regex if we don't have it already
	            mom = createUTC([2000, 1]).day(i);
	            minp = regexEscape(this.weekdaysMin(mom, ''));
	            shortp = regexEscape(this.weekdaysShort(mom, ''));
	            longp = regexEscape(this.weekdays(mom, ''));
	            minPieces.push(minp);
	            shortPieces.push(shortp);
	            longPieces.push(longp);
	            mixedPieces.push(minp);
	            mixedPieces.push(shortp);
	            mixedPieces.push(longp);
	        }
	        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	        // will match the longer piece.
	        minPieces.sort(cmpLenRev);
	        shortPieces.sort(cmpLenRev);
	        longPieces.sort(cmpLenRev);
	        mixedPieces.sort(cmpLenRev);

	        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._weekdaysShortRegex = this._weekdaysRegex;
	        this._weekdaysMinRegex = this._weekdaysRegex;

	        this._weekdaysStrictRegex = new RegExp(
	            '^(' + longPieces.join('|') + ')',
	            'i'
	        );
	        this._weekdaysShortStrictRegex = new RegExp(
	            '^(' + shortPieces.join('|') + ')',
	            'i'
	        );
	        this._weekdaysMinStrictRegex = new RegExp(
	            '^(' + minPieces.join('|') + ')',
	            'i'
	        );
	    }

	    // FORMATTING

	    function hFormat() {
	        return this.hours() % 12 || 12;
	    }

	    function kFormat() {
	        return this.hours() || 24;
	    }

	    addFormatToken('H', ['HH', 2], 0, 'hour');
	    addFormatToken('h', ['hh', 2], 0, hFormat);
	    addFormatToken('k', ['kk', 2], 0, kFormat);

	    addFormatToken('hmm', 0, 0, function () {
	        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	    });

	    addFormatToken('hmmss', 0, 0, function () {
	        return (
	            '' +
	            hFormat.apply(this) +
	            zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2)
	        );
	    });

	    addFormatToken('Hmm', 0, 0, function () {
	        return '' + this.hours() + zeroFill(this.minutes(), 2);
	    });

	    addFormatToken('Hmmss', 0, 0, function () {
	        return (
	            '' +
	            this.hours() +
	            zeroFill(this.minutes(), 2) +
	            zeroFill(this.seconds(), 2)
	        );
	    });

	    function meridiem(token, lowercase) {
	        addFormatToken(token, 0, 0, function () {
	            return this.localeData().meridiem(
	                this.hours(),
	                this.minutes(),
	                lowercase
	            );
	        });
	    }

	    meridiem('a', true);
	    meridiem('A', false);

	    // PARSING

	    function matchMeridiem(isStrict, locale) {
	        return locale._meridiemParse;
	    }

	    addRegexToken('a', matchMeridiem);
	    addRegexToken('A', matchMeridiem);
	    addRegexToken('H', match1to2, match1to2HasZero);
	    addRegexToken('h', match1to2, match1to2NoLeadingZero);
	    addRegexToken('k', match1to2, match1to2NoLeadingZero);
	    addRegexToken('HH', match1to2, match2);
	    addRegexToken('hh', match1to2, match2);
	    addRegexToken('kk', match1to2, match2);

	    addRegexToken('hmm', match3to4);
	    addRegexToken('hmmss', match5to6);
	    addRegexToken('Hmm', match3to4);
	    addRegexToken('Hmmss', match5to6);

	    addParseToken(['H', 'HH'], HOUR);
	    addParseToken(['k', 'kk'], function (input, array, config) {
	        var kInput = toInt(input);
	        array[HOUR] = kInput === 24 ? 0 : kInput;
	    });
	    addParseToken(['a', 'A'], function (input, array, config) {
	        config._isPm = config._locale.isPM(input);
	        config._meridiem = input;
	    });
	    addParseToken(['h', 'hh'], function (input, array, config) {
	        array[HOUR] = toInt(input);
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('hmmss', function (input, array, config) {
	        var pos1 = input.length - 4,
	            pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	        getParsingFlags(config).bigHour = true;
	    });
	    addParseToken('Hmm', function (input, array, config) {
	        var pos = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos));
	        array[MINUTE] = toInt(input.substr(pos));
	    });
	    addParseToken('Hmmss', function (input, array, config) {
	        var pos1 = input.length - 4,
	            pos2 = input.length - 2;
	        array[HOUR] = toInt(input.substr(0, pos1));
	        array[MINUTE] = toInt(input.substr(pos1, 2));
	        array[SECOND] = toInt(input.substr(pos2));
	    });

	    // LOCALES

	    function localeIsPM(input) {
	        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	        // Using charAt should be more compatible.
	        return (input + '').toLowerCase().charAt(0) === 'p';
	    }

	    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
	        // Setting the hour should keep the time, because the user explicitly
	        // specified which hour they want. So trying to maintain the same hour (in
	        // a new timezone) makes sense. Adding/subtracting hours does not follow
	        // this rule.
	        getSetHour = makeGetSet('Hours', true);

	    function localeMeridiem(hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'pm' : 'PM';
	        } else {
	            return isLower ? 'am' : 'AM';
	        }
	    }

	    var baseConfig = {
	        calendar: defaultCalendar,
	        longDateFormat: defaultLongDateFormat,
	        invalidDate: defaultInvalidDate,
	        ordinal: defaultOrdinal,
	        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
	        relativeTime: defaultRelativeTime,

	        months: defaultLocaleMonths,
	        monthsShort: defaultLocaleMonthsShort,

	        week: defaultLocaleWeek,

	        weekdays: defaultLocaleWeekdays,
	        weekdaysMin: defaultLocaleWeekdaysMin,
	        weekdaysShort: defaultLocaleWeekdaysShort,

	        meridiemParse: defaultLocaleMeridiemParse,
	    };

	    // internal storage for locale config files
	    var locales = {},
	        localeFamilies = {},
	        globalLocale;

	    function commonPrefix(arr1, arr2) {
	        var i,
	            minl = Math.min(arr1.length, arr2.length);
	        for (i = 0; i < minl; i += 1) {
	            if (arr1[i] !== arr2[i]) {
	                return i;
	            }
	        }
	        return minl;
	    }

	    function normalizeLocale(key) {
	        return key ? key.toLowerCase().replace('_', '-') : key;
	    }

	    // pick the locale from the array
	    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	    function chooseLocale(names) {
	        var i = 0,
	            j,
	            next,
	            locale,
	            split;

	        while (i < names.length) {
	            split = normalizeLocale(names[i]).split('-');
	            j = split.length;
	            next = normalizeLocale(names[i + 1]);
	            next = next ? next.split('-') : null;
	            while (j > 0) {
	                locale = loadLocale(split.slice(0, j).join('-'));
	                if (locale) {
	                    return locale;
	                }
	                if (
	                    next &&
	                    next.length >= j &&
	                    commonPrefix(split, next) >= j - 1
	                ) {
	                    //the next array item is better than a shallower substring of this one
	                    break;
	                }
	                j--;
	            }
	            i++;
	        }
	        return globalLocale;
	    }

	    function isLocaleNameSane(name) {
	        // Prevent names that look like filesystem paths, i.e contain '/' or '\'
	        // Ensure name is available and function returns boolean
	        return !!(name && name.match('^[^/\\\\]*$'));
	    }

	    function loadLocale(name) {
	        var oldLocale = null,
	            aliasedRequire;
	        // TODO: Find a better way to register and load all the locales in Node
	        if (
	            locales[name] === undefined &&
	            'object' !== 'undefined' &&
	            module &&
	            module.exports &&
	            isLocaleNameSane(name)
	        ) {
	            try {
	                oldLocale = globalLocale._abbr;
	                aliasedRequire = commonjsRequire;
	                aliasedRequire('./locale/' + name);
	                getSetGlobalLocale(oldLocale);
	            } catch (e) {
	                // mark as not found to avoid repeating expensive file require call causing high CPU
	                // when trying to find en-US, en_US, en-us for every format call
	                locales[name] = null; // null means not found
	            }
	        }
	        return locales[name];
	    }

	    // This function will load locale and then set the global locale.  If
	    // no arguments are passed in, it will simply return the current global
	    // locale key.
	    function getSetGlobalLocale(key, values) {
	        var data;
	        if (key) {
	            if (isUndefined(values)) {
	                data = getLocale(key);
	            } else {
	                data = defineLocale(key, values);
	            }

	            if (data) {
	                // moment.duration._locale = moment._locale = data;
	                globalLocale = data;
	            } else {
	                if (typeof console !== 'undefined' && console.warn) {
	                    //warn user if arguments are passed but the locale could not be set
	                    console.warn(
	                        'Locale ' + key + ' not found. Did you forget to load it?'
	                    );
	                }
	            }
	        }

	        return globalLocale._abbr;
	    }

	    function defineLocale(name, config) {
	        if (config !== null) {
	            var locale,
	                parentConfig = baseConfig;
	            config.abbr = name;
	            if (locales[name] != null) {
	                deprecateSimple(
	                    'defineLocaleOverride',
	                    'use moment.updateLocale(localeName, config) to change ' +
	                        'an existing locale. moment.defineLocale(localeName, ' +
	                        'config) should only be used for creating a new locale ' +
	                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
	                );
	                parentConfig = locales[name]._config;
	            } else if (config.parentLocale != null) {
	                if (locales[config.parentLocale] != null) {
	                    parentConfig = locales[config.parentLocale]._config;
	                } else {
	                    locale = loadLocale(config.parentLocale);
	                    if (locale != null) {
	                        parentConfig = locale._config;
	                    } else {
	                        if (!localeFamilies[config.parentLocale]) {
	                            localeFamilies[config.parentLocale] = [];
	                        }
	                        localeFamilies[config.parentLocale].push({
	                            name: name,
	                            config: config,
	                        });
	                        return null;
	                    }
	                }
	            }
	            locales[name] = new Locale(mergeConfigs(parentConfig, config));

	            if (localeFamilies[name]) {
	                localeFamilies[name].forEach(function (x) {
	                    defineLocale(x.name, x.config);
	                });
	            }

	            // backwards compat for now: also set the locale
	            // make sure we set the locale AFTER all child locales have been
	            // created, so we won't end up with the child locale set.
	            getSetGlobalLocale(name);

	            return locales[name];
	        } else {
	            // useful for testing
	            delete locales[name];
	            return null;
	        }
	    }

	    function updateLocale(name, config) {
	        if (config != null) {
	            var locale,
	                tmpLocale,
	                parentConfig = baseConfig;

	            if (locales[name] != null && locales[name].parentLocale != null) {
	                // Update existing child locale in-place to avoid memory-leaks
	                locales[name].set(mergeConfigs(locales[name]._config, config));
	            } else {
	                // MERGE
	                tmpLocale = loadLocale(name);
	                if (tmpLocale != null) {
	                    parentConfig = tmpLocale._config;
	                }
	                config = mergeConfigs(parentConfig, config);
	                if (tmpLocale == null) {
	                    // updateLocale is called for creating a new locale
	                    // Set abbr so it will have a name (getters return
	                    // undefined otherwise).
	                    config.abbr = name;
	                }
	                locale = new Locale(config);
	                locale.parentLocale = locales[name];
	                locales[name] = locale;
	            }

	            // backwards compat for now: also set the locale
	            getSetGlobalLocale(name);
	        } else {
	            // pass null for config to unupdate, useful for tests
	            if (locales[name] != null) {
	                if (locales[name].parentLocale != null) {
	                    locales[name] = locales[name].parentLocale;
	                    if (name === getSetGlobalLocale()) {
	                        getSetGlobalLocale(name);
	                    }
	                } else if (locales[name] != null) {
	                    delete locales[name];
	                }
	            }
	        }
	        return locales[name];
	    }

	    // returns locale data
	    function getLocale(key) {
	        var locale;

	        if (key && key._locale && key._locale._abbr) {
	            key = key._locale._abbr;
	        }

	        if (!key) {
	            return globalLocale;
	        }

	        if (!isArray(key)) {
	            //short-circuit everything else
	            locale = loadLocale(key);
	            if (locale) {
	                return locale;
	            }
	            key = [key];
	        }

	        return chooseLocale(key);
	    }

	    function listLocales() {
	        return keys(locales);
	    }

	    function checkOverflow(m) {
	        var overflow,
	            a = m._a;

	        if (a && getParsingFlags(m).overflow === -2) {
	            overflow =
	                a[MONTH] < 0 || a[MONTH] > 11
	                    ? MONTH
	                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
	                      ? DATE
	                      : a[HOUR] < 0 ||
	                          a[HOUR] > 24 ||
	                          (a[HOUR] === 24 &&
	                              (a[MINUTE] !== 0 ||
	                                  a[SECOND] !== 0 ||
	                                  a[MILLISECOND] !== 0))
	                        ? HOUR
	                        : a[MINUTE] < 0 || a[MINUTE] > 59
	                          ? MINUTE
	                          : a[SECOND] < 0 || a[SECOND] > 59
	                            ? SECOND
	                            : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
	                              ? MILLISECOND
	                              : -1;

	            if (
	                getParsingFlags(m)._overflowDayOfYear &&
	                (overflow < YEAR || overflow > DATE)
	            ) {
	                overflow = DATE;
	            }
	            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	                overflow = WEEK;
	            }
	            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	                overflow = WEEKDAY;
	            }

	            getParsingFlags(m).overflow = overflow;
	        }

	        return m;
	    }

	    // iso 8601 regex
	    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	    var extendedIsoRegex =
	            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
	        basicIsoRegex =
	            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
	        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
	        isoDates = [
	            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	            ['YYYY-DDD', /\d{4}-\d{3}/],
	            ['YYYY-MM', /\d{4}-\d\d/, false],
	            ['YYYYYYMMDD', /[+-]\d{10}/],
	            ['YYYYMMDD', /\d{8}/],
	            ['GGGG[W]WWE', /\d{4}W\d{3}/],
	            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	            ['YYYYDDD', /\d{7}/],
	            ['YYYYMM', /\d{6}/, false],
	            ['YYYY', /\d{4}/, false],
	        ],
	        // iso time formats and regexes
	        isoTimes = [
	            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	            ['HH:mm', /\d\d:\d\d/],
	            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	            ['HHmmss', /\d\d\d\d\d\d/],
	            ['HHmm', /\d\d\d\d/],
	            ['HH', /\d\d/],
	        ],
	        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
	        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
	        rfc2822 =
	            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
	        obsOffsets = {
	            UT: 0,
	            GMT: 0,
	            EDT: -4 * 60,
	            EST: -5 * 60,
	            CDT: -5 * 60,
	            CST: -6 * 60,
	            MDT: -6 * 60,
	            MST: -7 * 60,
	            PDT: -7 * 60,
	            PST: -8 * 60,
	        };

	    // date from iso format
	    function configFromISO(config) {
	        var i,
	            l,
	            string = config._i,
	            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	            allowTime,
	            dateFormat,
	            timeFormat,
	            tzFormat,
	            isoDatesLen = isoDates.length,
	            isoTimesLen = isoTimes.length;

	        if (match) {
	            getParsingFlags(config).iso = true;
	            for (i = 0, l = isoDatesLen; i < l; i++) {
	                if (isoDates[i][1].exec(match[1])) {
	                    dateFormat = isoDates[i][0];
	                    allowTime = isoDates[i][2] !== false;
	                    break;
	                }
	            }
	            if (dateFormat == null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[3]) {
	                for (i = 0, l = isoTimesLen; i < l; i++) {
	                    if (isoTimes[i][1].exec(match[3])) {
	                        // match[2] should be 'T' or space
	                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                        break;
	                    }
	                }
	                if (timeFormat == null) {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            if (!allowTime && timeFormat != null) {
	                config._isValid = false;
	                return;
	            }
	            if (match[4]) {
	                if (tzRegex.exec(match[4])) {
	                    tzFormat = 'Z';
	                } else {
	                    config._isValid = false;
	                    return;
	                }
	            }
	            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	            configFromStringAndFormat(config);
	        } else {
	            config._isValid = false;
	        }
	    }

	    function extractFromRFC2822Strings(
	        yearStr,
	        monthStr,
	        dayStr,
	        hourStr,
	        minuteStr,
	        secondStr
	    ) {
	        var result = [
	            untruncateYear(yearStr),
	            defaultLocaleMonthsShort.indexOf(monthStr),
	            parseInt(dayStr, 10),
	            parseInt(hourStr, 10),
	            parseInt(minuteStr, 10),
	        ];

	        if (secondStr) {
	            result.push(parseInt(secondStr, 10));
	        }

	        return result;
	    }

	    function untruncateYear(yearStr) {
	        var year = parseInt(yearStr, 10);
	        if (year <= 49) {
	            return 2000 + year;
	        } else if (year <= 999) {
	            return 1900 + year;
	        }
	        return year;
	    }

	    function preprocessRFC2822(s) {
	        // Remove comments and folding whitespace and replace multiple-spaces with a single space
	        return s
	            .replace(/\([^()]*\)|[\n\t]/g, ' ')
	            .replace(/(\s\s+)/g, ' ')
	            .replace(/^\s\s*/, '')
	            .replace(/\s\s*$/, '');
	    }

	    function checkWeekday(weekdayStr, parsedInput, config) {
	        if (weekdayStr) {
	            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
	            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
	                weekdayActual = new Date(
	                    parsedInput[0],
	                    parsedInput[1],
	                    parsedInput[2]
	                ).getDay();
	            if (weekdayProvided !== weekdayActual) {
	                getParsingFlags(config).weekdayMismatch = true;
	                config._isValid = false;
	                return false;
	            }
	        }
	        return true;
	    }

	    function calculateOffset(obsOffset, militaryOffset, numOffset) {
	        if (obsOffset) {
	            return obsOffsets[obsOffset];
	        } else if (militaryOffset) {
	            // the only allowed military tz is Z
	            return 0;
	        } else {
	            var hm = parseInt(numOffset, 10),
	                m = hm % 100,
	                h = (hm - m) / 100;
	            return h * 60 + m;
	        }
	    }

	    // date and time from ref 2822 format
	    function configFromRFC2822(config) {
	        var match = rfc2822.exec(preprocessRFC2822(config._i)),
	            parsedArray;
	        if (match) {
	            parsedArray = extractFromRFC2822Strings(
	                match[4],
	                match[3],
	                match[2],
	                match[5],
	                match[6],
	                match[7]
	            );
	            if (!checkWeekday(match[1], parsedArray, config)) {
	                return;
	            }

	            config._a = parsedArray;
	            config._tzm = calculateOffset(match[8], match[9], match[10]);

	            config._d = createUTCDate.apply(null, config._a);
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

	            getParsingFlags(config).rfc2822 = true;
	        } else {
	            config._isValid = false;
	        }
	    }

	    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
	    function configFromString(config) {
	        var matched = aspNetJsonRegex.exec(config._i);
	        if (matched !== null) {
	            config._d = new Date(+matched[1]);
	            return;
	        }

	        configFromISO(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	        } else {
	            return;
	        }

	        configFromRFC2822(config);
	        if (config._isValid === false) {
	            delete config._isValid;
	        } else {
	            return;
	        }

	        if (config._strict) {
	            config._isValid = false;
	        } else {
	            // Final attempt, use Input Fallback
	            hooks.createFromInputFallback(config);
	        }
	    }

	    hooks.createFromInputFallback = deprecate(
	        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
	            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
	            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
	        function (config) {
	            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	        }
	    );

	    // Pick the first defined of two or three arguments.
	    function defaults(a, b, c) {
	        if (a != null) {
	            return a;
	        }
	        if (b != null) {
	            return b;
	        }
	        return c;
	    }

	    function currentDateArray(config) {
	        // hooks is actually the exported moment object
	        var nowValue = new Date(hooks.now());
	        if (config._useUTC) {
	            return [
	                nowValue.getUTCFullYear(),
	                nowValue.getUTCMonth(),
	                nowValue.getUTCDate(),
	            ];
	        }
	        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	    }

	    // convert an array to a date.
	    // the array should mirror the parameters below
	    // note: all values past the year are optional and will default to the lowest possible value.
	    // [year, month, day , hour, minute, second, millisecond]
	    function configFromArray(config) {
	        var i,
	            date,
	            input = [],
	            currentDate,
	            expectedWeekday,
	            yearToUse;

	        if (config._d) {
	            return;
	        }

	        currentDate = currentDateArray(config);

	        //compute day of the year from weeks and weekdays
	        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	            dayOfYearFromWeekInfo(config);
	        }

	        //if the day of the year is set, figure out what it is
	        if (config._dayOfYear != null) {
	            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	            if (
	                config._dayOfYear > daysInYear(yearToUse) ||
	                config._dayOfYear === 0
	            ) {
	                getParsingFlags(config)._overflowDayOfYear = true;
	            }

	            date = createUTCDate(yearToUse, 0, config._dayOfYear);
	            config._a[MONTH] = date.getUTCMonth();
	            config._a[DATE] = date.getUTCDate();
	        }

	        // Default to current date.
	        // * if no year, month, day of month are given, default to today
	        // * if day of month is given, default month and year
	        // * if month is given, default only year
	        // * if year is given, don't default anything
	        for (i = 0; i < 3 && config._a[i] == null; ++i) {
	            config._a[i] = input[i] = currentDate[i];
	        }

	        // Zero out whatever was not defaulted, including time
	        for (; i < 7; i++) {
	            config._a[i] = input[i] =
	                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
	        }

	        // Check for 24:00:00.000
	        if (
	            config._a[HOUR] === 24 &&
	            config._a[MINUTE] === 0 &&
	            config._a[SECOND] === 0 &&
	            config._a[MILLISECOND] === 0
	        ) {
	            config._nextDay = true;
	            config._a[HOUR] = 0;
	        }

	        config._d = (config._useUTC ? createUTCDate : createDate).apply(
	            null,
	            input
	        );
	        expectedWeekday = config._useUTC
	            ? config._d.getUTCDay()
	            : config._d.getDay();

	        // Apply timezone offset from input. The actual utcOffset can be changed
	        // with parseZone.
	        if (config._tzm != null) {
	            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	        }

	        if (config._nextDay) {
	            config._a[HOUR] = 24;
	        }

	        // check for mismatching day of week
	        if (
	            config._w &&
	            typeof config._w.d !== 'undefined' &&
	            config._w.d !== expectedWeekday
	        ) {
	            getParsingFlags(config).weekdayMismatch = true;
	        }
	    }

	    function dayOfYearFromWeekInfo(config) {
	        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

	        w = config._w;
	        if (w.GG != null || w.W != null || w.E != null) {
	            dow = 1;
	            doy = 4;

	            // TODO: We need to take the current isoWeekYear, but that depends on
	            // how we interpret now (local, utc, fixed offset). So create
	            // a now version of current config (take local/utc/offset flags, and
	            // create now).
	            weekYear = defaults(
	                w.GG,
	                config._a[YEAR],
	                weekOfYear(createLocal(), 1, 4).year
	            );
	            week = defaults(w.W, 1);
	            weekday = defaults(w.E, 1);
	            if (weekday < 1 || weekday > 7) {
	                weekdayOverflow = true;
	            }
	        } else {
	            dow = config._locale._week.dow;
	            doy = config._locale._week.doy;

	            curWeek = weekOfYear(createLocal(), dow, doy);

	            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

	            // Default to current week.
	            week = defaults(w.w, curWeek.week);

	            if (w.d != null) {
	                // weekday -- low day numbers are considered next week
	                weekday = w.d;
	                if (weekday < 0 || weekday > 6) {
	                    weekdayOverflow = true;
	                }
	            } else if (w.e != null) {
	                // local weekday -- counting starts from beginning of week
	                weekday = w.e + dow;
	                if (w.e < 0 || w.e > 6) {
	                    weekdayOverflow = true;
	                }
	            } else {
	                // default to beginning of week
	                weekday = dow;
	            }
	        }
	        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	            getParsingFlags(config)._overflowWeeks = true;
	        } else if (weekdayOverflow != null) {
	            getParsingFlags(config)._overflowWeekday = true;
	        } else {
	            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	            config._a[YEAR] = temp.year;
	            config._dayOfYear = temp.dayOfYear;
	        }
	    }

	    // constant that refers to the ISO standard
	    hooks.ISO_8601 = function () {};

	    // constant that refers to the RFC 2822 form
	    hooks.RFC_2822 = function () {};

	    // date from string and format string
	    function configFromStringAndFormat(config) {
	        // TODO: Move this to another part of the creation flow to prevent circular deps
	        if (config._f === hooks.ISO_8601) {
	            configFromISO(config);
	            return;
	        }
	        if (config._f === hooks.RFC_2822) {
	            configFromRFC2822(config);
	            return;
	        }
	        config._a = [];
	        getParsingFlags(config).empty = true;

	        // This array is used to make a Date, either with `new Date` or `Date.UTC`
	        var string = '' + config._i,
	            i,
	            parsedInput,
	            tokens,
	            token,
	            skipped,
	            stringLength = string.length,
	            totalParsedInputLength = 0,
	            era,
	            tokenLen;

	        tokens =
	            expandFormat(config._f, config._locale).match(formattingTokens) || [];
	        tokenLen = tokens.length;
	        for (i = 0; i < tokenLen; i++) {
	            token = tokens[i];
	            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
	                [])[0];
	            if (parsedInput) {
	                skipped = string.substr(0, string.indexOf(parsedInput));
	                if (skipped.length > 0) {
	                    getParsingFlags(config).unusedInput.push(skipped);
	                }
	                string = string.slice(
	                    string.indexOf(parsedInput) + parsedInput.length
	                );
	                totalParsedInputLength += parsedInput.length;
	            }
	            // don't parse if it's not a known token
	            if (formatTokenFunctions[token]) {
	                if (parsedInput) {
	                    getParsingFlags(config).empty = false;
	                } else {
	                    getParsingFlags(config).unusedTokens.push(token);
	                }
	                addTimeToArrayFromToken(token, parsedInput, config);
	            } else if (config._strict && !parsedInput) {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	        }

	        // add remaining unparsed input length to the string
	        getParsingFlags(config).charsLeftOver =
	            stringLength - totalParsedInputLength;
	        if (string.length > 0) {
	            getParsingFlags(config).unusedInput.push(string);
	        }

	        // clear _12h flag if hour is <= 12
	        if (
	            config._a[HOUR] <= 12 &&
	            getParsingFlags(config).bigHour === true &&
	            config._a[HOUR] > 0
	        ) {
	            getParsingFlags(config).bigHour = undefined;
	        }

	        getParsingFlags(config).parsedDateParts = config._a.slice(0);
	        getParsingFlags(config).meridiem = config._meridiem;
	        // handle meridiem
	        config._a[HOUR] = meridiemFixWrap(
	            config._locale,
	            config._a[HOUR],
	            config._meridiem
	        );

	        // handle era
	        era = getParsingFlags(config).era;
	        if (era !== null) {
	            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
	        }

	        configFromArray(config);
	        checkOverflow(config);
	    }

	    function meridiemFixWrap(locale, hour, meridiem) {
	        var isPm;

	        if (meridiem == null) {
	            // nothing to do
	            return hour;
	        }
	        if (locale.meridiemHour != null) {
	            return locale.meridiemHour(hour, meridiem);
	        } else if (locale.isPM != null) {
	            // Fallback
	            isPm = locale.isPM(meridiem);
	            if (isPm && hour < 12) {
	                hour += 12;
	            }
	            if (!isPm && hour === 12) {
	                hour = 0;
	            }
	            return hour;
	        } else {
	            // this is not supposed to happen
	            return hour;
	        }
	    }

	    // date from string and array of format strings
	    function configFromStringAndArray(config) {
	        var tempConfig,
	            bestMoment,
	            scoreToBeat,
	            i,
	            currentScore,
	            validFormatFound,
	            bestFormatIsValid = false,
	            configfLen = config._f.length;

	        if (configfLen === 0) {
	            getParsingFlags(config).invalidFormat = true;
	            config._d = new Date(NaN);
	            return;
	        }

	        for (i = 0; i < configfLen; i++) {
	            currentScore = 0;
	            validFormatFound = false;
	            tempConfig = copyConfig({}, config);
	            if (config._useUTC != null) {
	                tempConfig._useUTC = config._useUTC;
	            }
	            tempConfig._f = config._f[i];
	            configFromStringAndFormat(tempConfig);

	            if (isValid(tempConfig)) {
	                validFormatFound = true;
	            }

	            // if there is any input that was not parsed add a penalty for that format
	            currentScore += getParsingFlags(tempConfig).charsLeftOver;

	            //or tokens
	            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

	            getParsingFlags(tempConfig).score = currentScore;

	            if (!bestFormatIsValid) {
	                if (
	                    scoreToBeat == null ||
	                    currentScore < scoreToBeat ||
	                    validFormatFound
	                ) {
	                    scoreToBeat = currentScore;
	                    bestMoment = tempConfig;
	                    if (validFormatFound) {
	                        bestFormatIsValid = true;
	                    }
	                }
	            } else {
	                if (currentScore < scoreToBeat) {
	                    scoreToBeat = currentScore;
	                    bestMoment = tempConfig;
	                }
	            }
	        }

	        extend(config, bestMoment || tempConfig);
	    }

	    function configFromObject(config) {
	        if (config._d) {
	            return;
	        }

	        var i = normalizeObjectUnits(config._i),
	            dayOrDate = i.day === undefined ? i.date : i.day;
	        config._a = map(
	            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
	            function (obj) {
	                return obj && parseInt(obj, 10);
	            }
	        );

	        configFromArray(config);
	    }

	    function createFromConfig(config) {
	        var res = new Moment(checkOverflow(prepareConfig(config)));
	        if (res._nextDay) {
	            // Adding is smart enough around DST
	            res.add(1, 'd');
	            res._nextDay = undefined;
	        }

	        return res;
	    }

	    function prepareConfig(config) {
	        var input = config._i,
	            format = config._f;

	        config._locale = config._locale || getLocale(config._l);

	        if (input === null || (format === undefined && input === '')) {
	            return createInvalid({ nullInput: true });
	        }

	        if (typeof input === 'string') {
	            config._i = input = config._locale.preparse(input);
	        }

	        if (isMoment(input)) {
	            return new Moment(checkOverflow(input));
	        } else if (isDate(input)) {
	            config._d = input;
	        } else if (isArray(format)) {
	            configFromStringAndArray(config);
	        } else if (format) {
	            configFromStringAndFormat(config);
	        } else {
	            configFromInput(config);
	        }

	        if (!isValid(config)) {
	            config._d = null;
	        }

	        return config;
	    }

	    function configFromInput(config) {
	        var input = config._i;
	        if (isUndefined(input)) {
	            config._d = new Date(hooks.now());
	        } else if (isDate(input)) {
	            config._d = new Date(input.valueOf());
	        } else if (typeof input === 'string') {
	            configFromString(config);
	        } else if (isArray(input)) {
	            config._a = map(input.slice(0), function (obj) {
	                return parseInt(obj, 10);
	            });
	            configFromArray(config);
	        } else if (isObject(input)) {
	            configFromObject(config);
	        } else if (isNumber(input)) {
	            // from milliseconds
	            config._d = new Date(input);
	        } else {
	            hooks.createFromInputFallback(config);
	        }
	    }

	    function createLocalOrUTC(input, format, locale, strict, isUTC) {
	        var c = {};

	        if (format === true || format === false) {
	            strict = format;
	            format = undefined;
	        }

	        if (locale === true || locale === false) {
	            strict = locale;
	            locale = undefined;
	        }

	        if (
	            (isObject(input) && isObjectEmpty(input)) ||
	            (isArray(input) && input.length === 0)
	        ) {
	            input = undefined;
	        }
	        // object construction must be done this way.
	        // https://github.com/moment/moment/issues/1423
	        c._isAMomentObject = true;
	        c._useUTC = c._isUTC = isUTC;
	        c._l = locale;
	        c._i = input;
	        c._f = format;
	        c._strict = strict;

	        return createFromConfig(c);
	    }

	    function createLocal(input, format, locale, strict) {
	        return createLocalOrUTC(input, format, locale, strict, false);
	    }

	    var prototypeMin = deprecate(
	            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
	            function () {
	                var other = createLocal.apply(null, arguments);
	                if (this.isValid() && other.isValid()) {
	                    return other < this ? this : other;
	                } else {
	                    return createInvalid();
	                }
	            }
	        ),
	        prototypeMax = deprecate(
	            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
	            function () {
	                var other = createLocal.apply(null, arguments);
	                if (this.isValid() && other.isValid()) {
	                    return other > this ? this : other;
	                } else {
	                    return createInvalid();
	                }
	            }
	        );

	    // Pick a moment m from moments so that m[fn](other) is true for all
	    // other. This relies on the function fn to be transitive.
	    //
	    // moments should either be an array of moment objects or an array, whose
	    // first element is an array of moment objects.
	    function pickBy(fn, moments) {
	        var res, i;
	        if (moments.length === 1 && isArray(moments[0])) {
	            moments = moments[0];
	        }
	        if (!moments.length) {
	            return createLocal();
	        }
	        res = moments[0];
	        for (i = 1; i < moments.length; ++i) {
	            if (!moments[i].isValid() || moments[i][fn](res)) {
	                res = moments[i];
	            }
	        }
	        return res;
	    }

	    // TODO: Use [].sort instead?
	    function min() {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isBefore', args);
	    }

	    function max() {
	        var args = [].slice.call(arguments, 0);

	        return pickBy('isAfter', args);
	    }

	    var now = function () {
	        return Date.now ? Date.now() : +new Date();
	    };

	    var ordering = [
	        'year',
	        'quarter',
	        'month',
	        'week',
	        'day',
	        'hour',
	        'minute',
	        'second',
	        'millisecond',
	    ];

	    function isDurationValid(m) {
	        var key,
	            unitHasDecimal = false,
	            i,
	            orderLen = ordering.length;
	        for (key in m) {
	            if (
	                hasOwnProp(m, key) &&
	                !(
	                    indexOf.call(ordering, key) !== -1 &&
	                    (m[key] == null || !isNaN(m[key]))
	                )
	            ) {
	                return false;
	            }
	        }

	        for (i = 0; i < orderLen; ++i) {
	            if (m[ordering[i]]) {
	                if (unitHasDecimal) {
	                    return false; // only allow non-integers for smallest unit
	                }
	                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
	                    unitHasDecimal = true;
	                }
	            }
	        }

	        return true;
	    }

	    function isValid$1() {
	        return this._isValid;
	    }

	    function createInvalid$1() {
	        return createDuration(NaN);
	    }

	    function Duration(duration) {
	        var normalizedInput = normalizeObjectUnits(duration),
	            years = normalizedInput.year || 0,
	            quarters = normalizedInput.quarter || 0,
	            months = normalizedInput.month || 0,
	            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
	            days = normalizedInput.day || 0,
	            hours = normalizedInput.hour || 0,
	            minutes = normalizedInput.minute || 0,
	            seconds = normalizedInput.second || 0,
	            milliseconds = normalizedInput.millisecond || 0;

	        this._isValid = isDurationValid(normalizedInput);

	        // representation for dateAddRemove
	        this._milliseconds =
	            +milliseconds +
	            seconds * 1e3 + // 1000
	            minutes * 6e4 + // 1000 * 60
	            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	        // Because of dateAddRemove treats 24 hours as different from a
	        // day when working around DST, we need to store them separately
	        this._days = +days + weeks * 7;
	        // It is impossible to translate months into days without knowing
	        // which months you are are talking about, so we have to store
	        // it separately.
	        this._months = +months + quarters * 3 + years * 12;

	        this._data = {};

	        this._locale = getLocale();

	        this._bubble();
	    }

	    function isDuration(obj) {
	        return obj instanceof Duration;
	    }

	    function absRound(number) {
	        if (number < 0) {
	            return Math.round(-1 * number) * -1;
	        } else {
	            return Math.round(number);
	        }
	    }

	    // compare two arrays, return the number of differences
	    function compareArrays(array1, array2, dontConvert) {
	        var len = Math.min(array1.length, array2.length),
	            lengthDiff = Math.abs(array1.length - array2.length),
	            diffs = 0,
	            i;
	        for (i = 0; i < len; i++) {
	            if (
	                (dontConvert && array1[i] !== array2[i]) ||
	                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
	            ) {
	                diffs++;
	            }
	        }
	        return diffs + lengthDiff;
	    }

	    // FORMATTING

	    function offset(token, separator) {
	        addFormatToken(token, 0, 0, function () {
	            var offset = this.utcOffset(),
	                sign = '+';
	            if (offset < 0) {
	                offset = -offset;
	                sign = '-';
	            }
	            return (
	                sign +
	                zeroFill(~~(offset / 60), 2) +
	                separator +
	                zeroFill(~~offset % 60, 2)
	            );
	        });
	    }

	    offset('Z', ':');
	    offset('ZZ', '');

	    // PARSING

	    addRegexToken('Z', matchShortOffset);
	    addRegexToken('ZZ', matchShortOffset);
	    addParseToken(['Z', 'ZZ'], function (input, array, config) {
	        config._useUTC = true;
	        config._tzm = offsetFromString(matchShortOffset, input);
	    });

	    // HELPERS

	    // timezone chunker
	    // '+10:00' > ['10',  '00']
	    // '-1530'  > ['-15', '30']
	    var chunkOffset = /([\+\-]|\d\d)/gi;

	    function offsetFromString(matcher, string) {
	        var matches = (string || '').match(matcher),
	            chunk,
	            parts,
	            minutes;

	        if (matches === null) {
	            return null;
	        }

	        chunk = matches[matches.length - 1] || [];
	        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	        minutes = +(parts[1] * 60) + toInt(parts[2]);

	        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
	    }

	    // Return a moment from input, that is local/utc/zone equivalent to model.
	    function cloneWithOffset(input, model) {
	        var res, diff;
	        if (model._isUTC) {
	            res = model.clone();
	            diff =
	                (isMoment(input) || isDate(input)
	                    ? input.valueOf()
	                    : createLocal(input).valueOf()) - res.valueOf();
	            // Use low-level api, because this fn is low-level api.
	            res._d.setTime(res._d.valueOf() + diff);
	            hooks.updateOffset(res, false);
	            return res;
	        } else {
	            return createLocal(input).local();
	        }
	    }

	    function getDateOffset(m) {
	        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	        // https://github.com/moment/moment/pull/1871
	        return -Math.round(m._d.getTimezoneOffset());
	    }

	    // HOOKS

	    // This function will be called whenever a moment is mutated.
	    // It is intended to keep the offset in sync with the timezone.
	    hooks.updateOffset = function () {};

	    // MOMENTS

	    // keepLocalTime = true means only change the timezone, without
	    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	    // +0200, so we adjust the time as needed, to be valid.
	    //
	    // Keeping the time actually adds/subtracts (one hour)
	    // from the actual represented time. That is why we call updateOffset
	    // a second time. In case it wants us to change the offset again
	    // _changeInProgress == true case, then we have to adjust, because
	    // there is no such time in the given timezone.
	    function getSetOffset(input, keepLocalTime, keepMinutes) {
	        var offset = this._offset || 0,
	            localAdjust;
	        if (!this.isValid()) {
	            return input != null ? this : NaN;
	        }
	        if (input != null) {
	            if (typeof input === 'string') {
	                input = offsetFromString(matchShortOffset, input);
	                if (input === null) {
	                    return this;
	                }
	            } else if (Math.abs(input) < 16 && !keepMinutes) {
	                input = input * 60;
	            }
	            if (!this._isUTC && keepLocalTime) {
	                localAdjust = getDateOffset(this);
	            }
	            this._offset = input;
	            this._isUTC = true;
	            if (localAdjust != null) {
	                this.add(localAdjust, 'm');
	            }
	            if (offset !== input) {
	                if (!keepLocalTime || this._changeInProgress) {
	                    addSubtract(
	                        this,
	                        createDuration(input - offset, 'm'),
	                        1,
	                        false
	                    );
	                } else if (!this._changeInProgress) {
	                    this._changeInProgress = true;
	                    hooks.updateOffset(this, true);
	                    this._changeInProgress = null;
	                }
	            }
	            return this;
	        } else {
	            return this._isUTC ? offset : getDateOffset(this);
	        }
	    }

	    function getSetZone(input, keepLocalTime) {
	        if (input != null) {
	            if (typeof input !== 'string') {
	                input = -input;
	            }

	            this.utcOffset(input, keepLocalTime);

	            return this;
	        } else {
	            return -this.utcOffset();
	        }
	    }

	    function setOffsetToUTC(keepLocalTime) {
	        return this.utcOffset(0, keepLocalTime);
	    }

	    function setOffsetToLocal(keepLocalTime) {
	        if (this._isUTC) {
	            this.utcOffset(0, keepLocalTime);
	            this._isUTC = false;

	            if (keepLocalTime) {
	                this.subtract(getDateOffset(this), 'm');
	            }
	        }
	        return this;
	    }

	    function setOffsetToParsedOffset() {
	        if (this._tzm != null) {
	            this.utcOffset(this._tzm, false, true);
	        } else if (typeof this._i === 'string') {
	            var tZone = offsetFromString(matchOffset, this._i);
	            if (tZone != null) {
	                this.utcOffset(tZone);
	            } else {
	                this.utcOffset(0, true);
	            }
	        }
	        return this;
	    }

	    function hasAlignedHourOffset(input) {
	        if (!this.isValid()) {
	            return false;
	        }
	        input = input ? createLocal(input).utcOffset() : 0;

	        return (this.utcOffset() - input) % 60 === 0;
	    }

	    function isDaylightSavingTime() {
	        return (
	            this.utcOffset() > this.clone().month(0).utcOffset() ||
	            this.utcOffset() > this.clone().month(5).utcOffset()
	        );
	    }

	    function isDaylightSavingTimeShifted() {
	        if (!isUndefined(this._isDSTShifted)) {
	            return this._isDSTShifted;
	        }

	        var c = {},
	            other;

	        copyConfig(c, this);
	        c = prepareConfig(c);

	        if (c._a) {
	            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
	            this._isDSTShifted =
	                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
	        } else {
	            this._isDSTShifted = false;
	        }

	        return this._isDSTShifted;
	    }

	    function isLocal() {
	        return this.isValid() ? !this._isUTC : false;
	    }

	    function isUtcOffset() {
	        return this.isValid() ? this._isUTC : false;
	    }

	    function isUtc() {
	        return this.isValid() ? this._isUTC && this._offset === 0 : false;
	    }

	    // ASP.NET json date format regex
	    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
	        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	        // and further modified to allow for strings containing both week and day
	        isoRegex =
	            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

	    function createDuration(input, key) {
	        var duration = input,
	            // matching against regexp is expensive, do it on demand
	            match = null,
	            sign,
	            ret,
	            diffRes;

	        if (isDuration(input)) {
	            duration = {
	                ms: input._milliseconds,
	                d: input._days,
	                M: input._months,
	            };
	        } else if (isNumber(input) || !isNaN(+input)) {
	            duration = {};
	            if (key) {
	                duration[key] = +input;
	            } else {
	                duration.milliseconds = +input;
	            }
	        } else if ((match = aspNetRegex.exec(input))) {
	            sign = match[1] === '-' ? -1 : 1;
	            duration = {
	                y: 0,
	                d: toInt(match[DATE]) * sign,
	                h: toInt(match[HOUR]) * sign,
	                m: toInt(match[MINUTE]) * sign,
	                s: toInt(match[SECOND]) * sign,
	                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
	            };
	        } else if ((match = isoRegex.exec(input))) {
	            sign = match[1] === '-' ? -1 : 1;
	            duration = {
	                y: parseIso(match[2], sign),
	                M: parseIso(match[3], sign),
	                w: parseIso(match[4], sign),
	                d: parseIso(match[5], sign),
	                h: parseIso(match[6], sign),
	                m: parseIso(match[7], sign),
	                s: parseIso(match[8], sign),
	            };
	        } else if (duration == null) {
	            // checks for null or undefined
	            duration = {};
	        } else if (
	            typeof duration === 'object' &&
	            ('from' in duration || 'to' in duration)
	        ) {
	            diffRes = momentsDifference(
	                createLocal(duration.from),
	                createLocal(duration.to)
	            );

	            duration = {};
	            duration.ms = diffRes.milliseconds;
	            duration.M = diffRes.months;
	        }

	        ret = new Duration(duration);

	        if (isDuration(input) && hasOwnProp(input, '_locale')) {
	            ret._locale = input._locale;
	        }

	        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
	            ret._isValid = input._isValid;
	        }

	        return ret;
	    }

	    createDuration.fn = Duration.prototype;
	    createDuration.invalid = createInvalid$1;

	    function parseIso(inp, sign) {
	        // We'd normally use ~~inp for this, but unfortunately it also
	        // converts floats to ints.
	        // inp may be undefined, so careful calling replace on it.
	        var res = inp && parseFloat(inp.replace(',', '.'));
	        // apply sign while we're at it
	        return (isNaN(res) ? 0 : res) * sign;
	    }

	    function positiveMomentsDifference(base, other) {
	        var res = {};

	        res.months =
	            other.month() - base.month() + (other.year() - base.year()) * 12;
	        if (base.clone().add(res.months, 'M').isAfter(other)) {
	            --res.months;
	        }

	        res.milliseconds = +other - +base.clone().add(res.months, 'M');

	        return res;
	    }

	    function momentsDifference(base, other) {
	        var res;
	        if (!(base.isValid() && other.isValid())) {
	            return { milliseconds: 0, months: 0 };
	        }

	        other = cloneWithOffset(other, base);
	        if (base.isBefore(other)) {
	            res = positiveMomentsDifference(base, other);
	        } else {
	            res = positiveMomentsDifference(other, base);
	            res.milliseconds = -res.milliseconds;
	            res.months = -res.months;
	        }

	        return res;
	    }

	    // TODO: remove 'name' arg after deprecation is removed
	    function createAdder(direction, name) {
	        return function (val, period) {
	            var dur, tmp;
	            //invert the arguments, but complain about it
	            if (period !== null && !isNaN(+period)) {
	                deprecateSimple(
	                    name,
	                    'moment().' +
	                        name +
	                        '(period, number) is deprecated. Please use moment().' +
	                        name +
	                        '(number, period). ' +
	                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
	                );
	                tmp = val;
	                val = period;
	                period = tmp;
	            }

	            dur = createDuration(val, period);
	            addSubtract(this, dur, direction);
	            return this;
	        };
	    }

	    function addSubtract(mom, duration, isAdding, updateOffset) {
	        var milliseconds = duration._milliseconds,
	            days = absRound(duration._days),
	            months = absRound(duration._months);

	        if (!mom.isValid()) {
	            // No op
	            return;
	        }

	        updateOffset = updateOffset == null ? true : updateOffset;

	        if (months) {
	            setMonth(mom, get(mom, 'Month') + months * isAdding);
	        }
	        if (days) {
	            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
	        }
	        if (milliseconds) {
	            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	        }
	        if (updateOffset) {
	            hooks.updateOffset(mom, days || months);
	        }
	    }

	    var add = createAdder(1, 'add'),
	        subtract = createAdder(-1, 'subtract');

	    function isString(input) {
	        return typeof input === 'string' || input instanceof String;
	    }

	    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
	    function isMomentInput(input) {
	        return (
	            isMoment(input) ||
	            isDate(input) ||
	            isString(input) ||
	            isNumber(input) ||
	            isNumberOrStringArray(input) ||
	            isMomentInputObject(input) ||
	            input === null ||
	            input === undefined
	        );
	    }

	    function isMomentInputObject(input) {
	        var objectTest = isObject(input) && !isObjectEmpty(input),
	            propertyTest = false,
	            properties = [
	                'years',
	                'year',
	                'y',
	                'months',
	                'month',
	                'M',
	                'days',
	                'day',
	                'd',
	                'dates',
	                'date',
	                'D',
	                'hours',
	                'hour',
	                'h',
	                'minutes',
	                'minute',
	                'm',
	                'seconds',
	                'second',
	                's',
	                'milliseconds',
	                'millisecond',
	                'ms',
	            ],
	            i,
	            property,
	            propertyLen = properties.length;

	        for (i = 0; i < propertyLen; i += 1) {
	            property = properties[i];
	            propertyTest = propertyTest || hasOwnProp(input, property);
	        }

	        return objectTest && propertyTest;
	    }

	    function isNumberOrStringArray(input) {
	        var arrayTest = isArray(input),
	            dataTypeTest = false;
	        if (arrayTest) {
	            dataTypeTest =
	                input.filter(function (item) {
	                    return !isNumber(item) && isString(input);
	                }).length === 0;
	        }
	        return arrayTest && dataTypeTest;
	    }

	    function isCalendarSpec(input) {
	        var objectTest = isObject(input) && !isObjectEmpty(input),
	            propertyTest = false,
	            properties = [
	                'sameDay',
	                'nextDay',
	                'lastDay',
	                'nextWeek',
	                'lastWeek',
	                'sameElse',
	            ],
	            i,
	            property;

	        for (i = 0; i < properties.length; i += 1) {
	            property = properties[i];
	            propertyTest = propertyTest || hasOwnProp(input, property);
	        }

	        return objectTest && propertyTest;
	    }

	    function getCalendarFormat(myMoment, now) {
	        var diff = myMoment.diff(now, 'days', true);
	        return diff < -6
	            ? 'sameElse'
	            : diff < -1
	              ? 'lastWeek'
	              : diff < 0
	                ? 'lastDay'
	                : diff < 1
	                  ? 'sameDay'
	                  : diff < 2
	                    ? 'nextDay'
	                    : diff < 7
	                      ? 'nextWeek'
	                      : 'sameElse';
	    }

	    function calendar$1(time, formats) {
	        // Support for single parameter, formats only overload to the calendar function
	        if (arguments.length === 1) {
	            if (!arguments[0]) {
	                time = undefined;
	                formats = undefined;
	            } else if (isMomentInput(arguments[0])) {
	                time = arguments[0];
	                formats = undefined;
	            } else if (isCalendarSpec(arguments[0])) {
	                formats = arguments[0];
	                time = undefined;
	            }
	        }
	        // We want to compare the start of today, vs this.
	        // Getting start-of-today depends on whether we're local/utc/offset or not.
	        var now = time || createLocal(),
	            sod = cloneWithOffset(now, this).startOf('day'),
	            format = hooks.calendarFormat(this, sod) || 'sameElse',
	            output =
	                formats &&
	                (isFunction(formats[format])
	                    ? formats[format].call(this, now)
	                    : formats[format]);

	        return this.format(
	            output || this.localeData().calendar(format, this, createLocal(now))
	        );
	    }

	    function clone() {
	        return new Moment(this);
	    }

	    function isAfter(input, units) {
	        var localInput = isMoment(input) ? input : createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units) || 'millisecond';
	        if (units === 'millisecond') {
	            return this.valueOf() > localInput.valueOf();
	        } else {
	            return localInput.valueOf() < this.clone().startOf(units).valueOf();
	        }
	    }

	    function isBefore(input, units) {
	        var localInput = isMoment(input) ? input : createLocal(input);
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units) || 'millisecond';
	        if (units === 'millisecond') {
	            return this.valueOf() < localInput.valueOf();
	        } else {
	            return this.clone().endOf(units).valueOf() < localInput.valueOf();
	        }
	    }

	    function isBetween(from, to, units, inclusivity) {
	        var localFrom = isMoment(from) ? from : createLocal(from),
	            localTo = isMoment(to) ? to : createLocal(to);
	        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
	            return false;
	        }
	        inclusivity = inclusivity || '()';
	        return (
	            (inclusivity[0] === '('
	                ? this.isAfter(localFrom, units)
	                : !this.isBefore(localFrom, units)) &&
	            (inclusivity[1] === ')'
	                ? this.isBefore(localTo, units)
	                : !this.isAfter(localTo, units))
	        );
	    }

	    function isSame(input, units) {
	        var localInput = isMoment(input) ? input : createLocal(input),
	            inputMs;
	        if (!(this.isValid() && localInput.isValid())) {
	            return false;
	        }
	        units = normalizeUnits(units) || 'millisecond';
	        if (units === 'millisecond') {
	            return this.valueOf() === localInput.valueOf();
	        } else {
	            inputMs = localInput.valueOf();
	            return (
	                this.clone().startOf(units).valueOf() <= inputMs &&
	                inputMs <= this.clone().endOf(units).valueOf()
	            );
	        }
	    }

	    function isSameOrAfter(input, units) {
	        return this.isSame(input, units) || this.isAfter(input, units);
	    }

	    function isSameOrBefore(input, units) {
	        return this.isSame(input, units) || this.isBefore(input, units);
	    }

	    function diff(input, units, asFloat) {
	        var that, zoneDelta, output;

	        if (!this.isValid()) {
	            return NaN;
	        }

	        that = cloneWithOffset(input, this);

	        if (!that.isValid()) {
	            return NaN;
	        }

	        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

	        units = normalizeUnits(units);

	        switch (units) {
	            case 'year':
	                output = monthDiff(this, that) / 12;
	                break;
	            case 'month':
	                output = monthDiff(this, that);
	                break;
	            case 'quarter':
	                output = monthDiff(this, that) / 3;
	                break;
	            case 'second':
	                output = (this - that) / 1e3;
	                break; // 1000
	            case 'minute':
	                output = (this - that) / 6e4;
	                break; // 1000 * 60
	            case 'hour':
	                output = (this - that) / 36e5;
	                break; // 1000 * 60 * 60
	            case 'day':
	                output = (this - that - zoneDelta) / 864e5;
	                break; // 1000 * 60 * 60 * 24, negate dst
	            case 'week':
	                output = (this - that - zoneDelta) / 6048e5;
	                break; // 1000 * 60 * 60 * 24 * 7, negate dst
	            default:
	                output = this - that;
	        }

	        return asFloat ? output : absFloor(output);
	    }

	    function monthDiff(a, b) {
	        if (a.date() < b.date()) {
	            // end-of-month calculations work correct when the start month has more
	            // days than the end month.
	            return -monthDiff(b, a);
	        }
	        // difference in months
	        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
	            // b is in (anchor - 1 month, anchor + 1 month)
	            anchor = a.clone().add(wholeMonthDiff, 'months'),
	            anchor2,
	            adjust;

	        if (b - anchor < 0) {
	            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor - anchor2);
	        } else {
	            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	            // linear across the month
	            adjust = (b - anchor) / (anchor2 - anchor);
	        }

	        //check for negative zero, return zero if negative zero
	        return -(wholeMonthDiff + adjust) || 0;
	    }

	    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

	    function toString() {
	        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	    }

	    function toISOString(keepOffset) {
	        if (!this.isValid()) {
	            return null;
	        }
	        var utc = keepOffset !== true,
	            m = utc ? this.clone().utc() : this;
	        if (m.year() < 0 || m.year() > 9999) {
	            return formatMoment(
	                m,
	                utc
	                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
	                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
	            );
	        }
	        if (isFunction(Date.prototype.toISOString)) {
	            // native implementation is ~50x faster, use it when we can
	            if (utc) {
	                return this.toDate().toISOString();
	            } else {
	                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
	                    .toISOString()
	                    .replace('Z', formatMoment(m, 'Z'));
	            }
	        }
	        return formatMoment(
	            m,
	            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
	        );
	    }

	    /**
	     * Return a human readable representation of a moment that can
	     * also be evaluated to get a new moment which is the same
	     *
	     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	     */
	    function inspect() {
	        if (!this.isValid()) {
	            return 'moment.invalid(/* ' + this._i + ' */)';
	        }
	        var func = 'moment',
	            zone = '',
	            prefix,
	            year,
	            datetime,
	            suffix;
	        if (!this.isLocal()) {
	            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
	            zone = 'Z';
	        }
	        prefix = '[' + func + '("]';
	        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
	        datetime = '-MM-DD[T]HH:mm:ss.SSS';
	        suffix = zone + '[")]';

	        return this.format(prefix + year + datetime + suffix);
	    }

	    function format(inputString) {
	        if (!inputString) {
	            inputString = this.isUtc()
	                ? hooks.defaultFormatUtc
	                : hooks.defaultFormat;
	        }
	        var output = formatMoment(this, inputString);
	        return this.localeData().postformat(output);
	    }

	    function from(time, withoutSuffix) {
	        if (
	            this.isValid() &&
	            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
	        ) {
	            return createDuration({ to: this, from: time })
	                .locale(this.locale())
	                .humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }

	    function fromNow(withoutSuffix) {
	        return this.from(createLocal(), withoutSuffix);
	    }

	    function to(time, withoutSuffix) {
	        if (
	            this.isValid() &&
	            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
	        ) {
	            return createDuration({ from: this, to: time })
	                .locale(this.locale())
	                .humanize(!withoutSuffix);
	        } else {
	            return this.localeData().invalidDate();
	        }
	    }

	    function toNow(withoutSuffix) {
	        return this.to(createLocal(), withoutSuffix);
	    }

	    // If passed a locale key, it will set the locale for this
	    // instance.  Otherwise, it will return the locale configuration
	    // variables for this instance.
	    function locale(key) {
	        var newLocaleData;

	        if (key === undefined) {
	            return this._locale._abbr;
	        } else {
	            newLocaleData = getLocale(key);
	            if (newLocaleData != null) {
	                this._locale = newLocaleData;
	            }
	            return this;
	        }
	    }

	    var lang = deprecate(
	        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	        function (key) {
	            if (key === undefined) {
	                return this.localeData();
	            } else {
	                return this.locale(key);
	            }
	        }
	    );

	    function localeData() {
	        return this._locale;
	    }

	    var MS_PER_SECOND = 1000,
	        MS_PER_MINUTE = 60 * MS_PER_SECOND,
	        MS_PER_HOUR = 60 * MS_PER_MINUTE,
	        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

	    // actual modulo - handles negative numbers (for dates before 1970):
	    function mod$1(dividend, divisor) {
	        return ((dividend % divisor) + divisor) % divisor;
	    }

	    function localStartOfDate(y, m, d) {
	        // the date constructor remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0) {
	            // preserve leap years using a full 400 year cycle, then reset
	            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
	        } else {
	            return new Date(y, m, d).valueOf();
	        }
	    }

	    function utcStartOfDate(y, m, d) {
	        // Date.UTC remaps years 0-99 to 1900-1999
	        if (y < 100 && y >= 0) {
	            // preserve leap years using a full 400 year cycle, then reset
	            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
	        } else {
	            return Date.UTC(y, m, d);
	        }
	    }

	    function startOf(units) {
	        var time, startOfDate;
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond' || !this.isValid()) {
	            return this;
	        }

	        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

	        switch (units) {
	            case 'year':
	                time = startOfDate(this.year(), 0, 1);
	                break;
	            case 'quarter':
	                time = startOfDate(
	                    this.year(),
	                    this.month() - (this.month() % 3),
	                    1
	                );
	                break;
	            case 'month':
	                time = startOfDate(this.year(), this.month(), 1);
	                break;
	            case 'week':
	                time = startOfDate(
	                    this.year(),
	                    this.month(),
	                    this.date() - this.weekday()
	                );
	                break;
	            case 'isoWeek':
	                time = startOfDate(
	                    this.year(),
	                    this.month(),
	                    this.date() - (this.isoWeekday() - 1)
	                );
	                break;
	            case 'day':
	            case 'date':
	                time = startOfDate(this.year(), this.month(), this.date());
	                break;
	            case 'hour':
	                time = this._d.valueOf();
	                time -= mod$1(
	                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
	                    MS_PER_HOUR
	                );
	                break;
	            case 'minute':
	                time = this._d.valueOf();
	                time -= mod$1(time, MS_PER_MINUTE);
	                break;
	            case 'second':
	                time = this._d.valueOf();
	                time -= mod$1(time, MS_PER_SECOND);
	                break;
	        }

	        this._d.setTime(time);
	        hooks.updateOffset(this, true);
	        return this;
	    }

	    function endOf(units) {
	        var time, startOfDate;
	        units = normalizeUnits(units);
	        if (units === undefined || units === 'millisecond' || !this.isValid()) {
	            return this;
	        }

	        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

	        switch (units) {
	            case 'year':
	                time = startOfDate(this.year() + 1, 0, 1) - 1;
	                break;
	            case 'quarter':
	                time =
	                    startOfDate(
	                        this.year(),
	                        this.month() - (this.month() % 3) + 3,
	                        1
	                    ) - 1;
	                break;
	            case 'month':
	                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
	                break;
	            case 'week':
	                time =
	                    startOfDate(
	                        this.year(),
	                        this.month(),
	                        this.date() - this.weekday() + 7
	                    ) - 1;
	                break;
	            case 'isoWeek':
	                time =
	                    startOfDate(
	                        this.year(),
	                        this.month(),
	                        this.date() - (this.isoWeekday() - 1) + 7
	                    ) - 1;
	                break;
	            case 'day':
	            case 'date':
	                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
	                break;
	            case 'hour':
	                time = this._d.valueOf();
	                time +=
	                    MS_PER_HOUR -
	                    mod$1(
	                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
	                        MS_PER_HOUR
	                    ) -
	                    1;
	                break;
	            case 'minute':
	                time = this._d.valueOf();
	                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
	                break;
	            case 'second':
	                time = this._d.valueOf();
	                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
	                break;
	        }

	        this._d.setTime(time);
	        hooks.updateOffset(this, true);
	        return this;
	    }

	    function valueOf() {
	        return this._d.valueOf() - (this._offset || 0) * 60000;
	    }

	    function unix() {
	        return Math.floor(this.valueOf() / 1000);
	    }

	    function toDate() {
	        return new Date(this.valueOf());
	    }

	    function toArray() {
	        var m = this;
	        return [
	            m.year(),
	            m.month(),
	            m.date(),
	            m.hour(),
	            m.minute(),
	            m.second(),
	            m.millisecond(),
	        ];
	    }

	    function toObject() {
	        var m = this;
	        return {
	            years: m.year(),
	            months: m.month(),
	            date: m.date(),
	            hours: m.hours(),
	            minutes: m.minutes(),
	            seconds: m.seconds(),
	            milliseconds: m.milliseconds(),
	        };
	    }

	    function toJSON() {
	        // new Date(NaN).toJSON() === null
	        return this.isValid() ? this.toISOString() : null;
	    }

	    function isValid$2() {
	        return isValid(this);
	    }

	    function parsingFlags() {
	        return extend({}, getParsingFlags(this));
	    }

	    function invalidAt() {
	        return getParsingFlags(this).overflow;
	    }

	    function creationData() {
	        return {
	            input: this._i,
	            format: this._f,
	            locale: this._locale,
	            isUTC: this._isUTC,
	            strict: this._strict,
	        };
	    }

	    addFormatToken('N', 0, 0, 'eraAbbr');
	    addFormatToken('NN', 0, 0, 'eraAbbr');
	    addFormatToken('NNN', 0, 0, 'eraAbbr');
	    addFormatToken('NNNN', 0, 0, 'eraName');
	    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

	    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
	    addFormatToken('y', ['yy', 2], 0, 'eraYear');
	    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
	    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

	    addRegexToken('N', matchEraAbbr);
	    addRegexToken('NN', matchEraAbbr);
	    addRegexToken('NNN', matchEraAbbr);
	    addRegexToken('NNNN', matchEraName);
	    addRegexToken('NNNNN', matchEraNarrow);

	    addParseToken(
	        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
	        function (input, array, config, token) {
	            var era = config._locale.erasParse(input, token, config._strict);
	            if (era) {
	                getParsingFlags(config).era = era;
	            } else {
	                getParsingFlags(config).invalidEra = input;
	            }
	        }
	    );

	    addRegexToken('y', matchUnsigned);
	    addRegexToken('yy', matchUnsigned);
	    addRegexToken('yyy', matchUnsigned);
	    addRegexToken('yyyy', matchUnsigned);
	    addRegexToken('yo', matchEraYearOrdinal);

	    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
	    addParseToken(['yo'], function (input, array, config, token) {
	        var match;
	        if (config._locale._eraYearOrdinalRegex) {
	            match = input.match(config._locale._eraYearOrdinalRegex);
	        }

	        if (config._locale.eraYearOrdinalParse) {
	            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
	        } else {
	            array[YEAR] = parseInt(input, 10);
	        }
	    });

	    function localeEras(m, format) {
	        var i,
	            l,
	            date,
	            eras = this._eras || getLocale('en')._eras;
	        for (i = 0, l = eras.length; i < l; ++i) {
	            switch (typeof eras[i].since) {
	                case 'string':
	                    // truncate time
	                    date = hooks(eras[i].since).startOf('day');
	                    eras[i].since = date.valueOf();
	                    break;
	            }

	            switch (typeof eras[i].until) {
	                case 'undefined':
	                    eras[i].until = +Infinity;
	                    break;
	                case 'string':
	                    // truncate time
	                    date = hooks(eras[i].until).startOf('day').valueOf();
	                    eras[i].until = date.valueOf();
	                    break;
	            }
	        }
	        return eras;
	    }

	    function localeErasParse(eraName, format, strict) {
	        var i,
	            l,
	            eras = this.eras(),
	            name,
	            abbr,
	            narrow;
	        eraName = eraName.toUpperCase();

	        for (i = 0, l = eras.length; i < l; ++i) {
	            name = eras[i].name.toUpperCase();
	            abbr = eras[i].abbr.toUpperCase();
	            narrow = eras[i].narrow.toUpperCase();

	            if (strict) {
	                switch (format) {
	                    case 'N':
	                    case 'NN':
	                    case 'NNN':
	                        if (abbr === eraName) {
	                            return eras[i];
	                        }
	                        break;

	                    case 'NNNN':
	                        if (name === eraName) {
	                            return eras[i];
	                        }
	                        break;

	                    case 'NNNNN':
	                        if (narrow === eraName) {
	                            return eras[i];
	                        }
	                        break;
	                }
	            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
	                return eras[i];
	            }
	        }
	    }

	    function localeErasConvertYear(era, year) {
	        var dir = era.since <= era.until ? +1 : -1;
	        if (year === undefined) {
	            return hooks(era.since).year();
	        } else {
	            return hooks(era.since).year() + (year - era.offset) * dir;
	        }
	    }

	    function getEraName() {
	        var i,
	            l,
	            val,
	            eras = this.localeData().eras();
	        for (i = 0, l = eras.length; i < l; ++i) {
	            // truncate time
	            val = this.clone().startOf('day').valueOf();

	            if (eras[i].since <= val && val <= eras[i].until) {
	                return eras[i].name;
	            }
	            if (eras[i].until <= val && val <= eras[i].since) {
	                return eras[i].name;
	            }
	        }

	        return '';
	    }

	    function getEraNarrow() {
	        var i,
	            l,
	            val,
	            eras = this.localeData().eras();
	        for (i = 0, l = eras.length; i < l; ++i) {
	            // truncate time
	            val = this.clone().startOf('day').valueOf();

	            if (eras[i].since <= val && val <= eras[i].until) {
	                return eras[i].narrow;
	            }
	            if (eras[i].until <= val && val <= eras[i].since) {
	                return eras[i].narrow;
	            }
	        }

	        return '';
	    }

	    function getEraAbbr() {
	        var i,
	            l,
	            val,
	            eras = this.localeData().eras();
	        for (i = 0, l = eras.length; i < l; ++i) {
	            // truncate time
	            val = this.clone().startOf('day').valueOf();

	            if (eras[i].since <= val && val <= eras[i].until) {
	                return eras[i].abbr;
	            }
	            if (eras[i].until <= val && val <= eras[i].since) {
	                return eras[i].abbr;
	            }
	        }

	        return '';
	    }

	    function getEraYear() {
	        var i,
	            l,
	            dir,
	            val,
	            eras = this.localeData().eras();
	        for (i = 0, l = eras.length; i < l; ++i) {
	            dir = eras[i].since <= eras[i].until ? +1 : -1;

	            // truncate time
	            val = this.clone().startOf('day').valueOf();

	            if (
	                (eras[i].since <= val && val <= eras[i].until) ||
	                (eras[i].until <= val && val <= eras[i].since)
	            ) {
	                return (
	                    (this.year() - hooks(eras[i].since).year()) * dir +
	                    eras[i].offset
	                );
	            }
	        }

	        return this.year();
	    }

	    function erasNameRegex(isStrict) {
	        if (!hasOwnProp(this, '_erasNameRegex')) {
	            computeErasParse.call(this);
	        }
	        return isStrict ? this._erasNameRegex : this._erasRegex;
	    }

	    function erasAbbrRegex(isStrict) {
	        if (!hasOwnProp(this, '_erasAbbrRegex')) {
	            computeErasParse.call(this);
	        }
	        return isStrict ? this._erasAbbrRegex : this._erasRegex;
	    }

	    function erasNarrowRegex(isStrict) {
	        if (!hasOwnProp(this, '_erasNarrowRegex')) {
	            computeErasParse.call(this);
	        }
	        return isStrict ? this._erasNarrowRegex : this._erasRegex;
	    }

	    function matchEraAbbr(isStrict, locale) {
	        return locale.erasAbbrRegex(isStrict);
	    }

	    function matchEraName(isStrict, locale) {
	        return locale.erasNameRegex(isStrict);
	    }

	    function matchEraNarrow(isStrict, locale) {
	        return locale.erasNarrowRegex(isStrict);
	    }

	    function matchEraYearOrdinal(isStrict, locale) {
	        return locale._eraYearOrdinalRegex || matchUnsigned;
	    }

	    function computeErasParse() {
	        var abbrPieces = [],
	            namePieces = [],
	            narrowPieces = [],
	            mixedPieces = [],
	            i,
	            l,
	            erasName,
	            erasAbbr,
	            erasNarrow,
	            eras = this.eras();

	        for (i = 0, l = eras.length; i < l; ++i) {
	            erasName = regexEscape(eras[i].name);
	            erasAbbr = regexEscape(eras[i].abbr);
	            erasNarrow = regexEscape(eras[i].narrow);

	            namePieces.push(erasName);
	            abbrPieces.push(erasAbbr);
	            narrowPieces.push(erasNarrow);
	            mixedPieces.push(erasName);
	            mixedPieces.push(erasAbbr);
	            mixedPieces.push(erasNarrow);
	        }

	        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
	        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
	        this._erasNarrowRegex = new RegExp(
	            '^(' + narrowPieces.join('|') + ')',
	            'i'
	        );
	    }

	    // FORMATTING

	    addFormatToken(0, ['gg', 2], 0, function () {
	        return this.weekYear() % 100;
	    });

	    addFormatToken(0, ['GG', 2], 0, function () {
	        return this.isoWeekYear() % 100;
	    });

	    function addWeekYearFormatToken(token, getter) {
	        addFormatToken(0, [token, token.length], 0, getter);
	    }

	    addWeekYearFormatToken('gggg', 'weekYear');
	    addWeekYearFormatToken('ggggg', 'weekYear');
	    addWeekYearFormatToken('GGGG', 'isoWeekYear');
	    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

	    // ALIASES

	    // PARSING

	    addRegexToken('G', matchSigned);
	    addRegexToken('g', matchSigned);
	    addRegexToken('GG', match1to2, match2);
	    addRegexToken('gg', match1to2, match2);
	    addRegexToken('GGGG', match1to4, match4);
	    addRegexToken('gggg', match1to4, match4);
	    addRegexToken('GGGGG', match1to6, match6);
	    addRegexToken('ggggg', match1to6, match6);

	    addWeekParseToken(
	        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
	        function (input, week, config, token) {
	            week[token.substr(0, 2)] = toInt(input);
	        }
	    );

	    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	        week[token] = hooks.parseTwoDigitYear(input);
	    });

	    // MOMENTS

	    function getSetWeekYear(input) {
	        return getSetWeekYearHelper.call(
	            this,
	            input,
	            this.week(),
	            this.weekday() + this.localeData()._week.dow,
	            this.localeData()._week.dow,
	            this.localeData()._week.doy
	        );
	    }

	    function getSetISOWeekYear(input) {
	        return getSetWeekYearHelper.call(
	            this,
	            input,
	            this.isoWeek(),
	            this.isoWeekday(),
	            1,
	            4
	        );
	    }

	    function getISOWeeksInYear() {
	        return weeksInYear(this.year(), 1, 4);
	    }

	    function getISOWeeksInISOWeekYear() {
	        return weeksInYear(this.isoWeekYear(), 1, 4);
	    }

	    function getWeeksInYear() {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	    }

	    function getWeeksInWeekYear() {
	        var weekInfo = this.localeData()._week;
	        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
	    }

	    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	        var weeksTarget;
	        if (input == null) {
	            return weekOfYear(this, dow, doy).year;
	        } else {
	            weeksTarget = weeksInYear(input, dow, doy);
	            if (week > weeksTarget) {
	                week = weeksTarget;
	            }
	            return setWeekAll.call(this, input, week, weekday, dow, doy);
	        }
	    }

	    function setWeekAll(weekYear, week, weekday, dow, doy) {
	        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

	        this.year(date.getUTCFullYear());
	        this.month(date.getUTCMonth());
	        this.date(date.getUTCDate());
	        return this;
	    }

	    // FORMATTING

	    addFormatToken('Q', 0, 'Qo', 'quarter');

	    // PARSING

	    addRegexToken('Q', match1);
	    addParseToken('Q', function (input, array) {
	        array[MONTH] = (toInt(input) - 1) * 3;
	    });

	    // MOMENTS

	    function getSetQuarter(input) {
	        return input == null
	            ? Math.ceil((this.month() + 1) / 3)
	            : this.month((input - 1) * 3 + (this.month() % 3));
	    }

	    // FORMATTING

	    addFormatToken('D', ['DD', 2], 'Do', 'date');

	    // PARSING

	    addRegexToken('D', match1to2, match1to2NoLeadingZero);
	    addRegexToken('DD', match1to2, match2);
	    addRegexToken('Do', function (isStrict, locale) {
	        // TODO: Remove "ordinalParse" fallback in next major release.
	        return isStrict
	            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
	            : locale._dayOfMonthOrdinalParseLenient;
	    });

	    addParseToken(['D', 'DD'], DATE);
	    addParseToken('Do', function (input, array) {
	        array[DATE] = toInt(input.match(match1to2)[0]);
	    });

	    // MOMENTS

	    var getSetDayOfMonth = makeGetSet('Date', true);

	    // FORMATTING

	    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

	    // PARSING

	    addRegexToken('DDD', match1to3);
	    addRegexToken('DDDD', match3);
	    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	        config._dayOfYear = toInt(input);
	    });

	    // HELPERS

	    // MOMENTS

	    function getSetDayOfYear(input) {
	        var dayOfYear =
	            Math.round(
	                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
	            ) + 1;
	        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
	    }

	    // FORMATTING

	    addFormatToken('m', ['mm', 2], 0, 'minute');

	    // PARSING

	    addRegexToken('m', match1to2, match1to2HasZero);
	    addRegexToken('mm', match1to2, match2);
	    addParseToken(['m', 'mm'], MINUTE);

	    // MOMENTS

	    var getSetMinute = makeGetSet('Minutes', false);

	    // FORMATTING

	    addFormatToken('s', ['ss', 2], 0, 'second');

	    // PARSING

	    addRegexToken('s', match1to2, match1to2HasZero);
	    addRegexToken('ss', match1to2, match2);
	    addParseToken(['s', 'ss'], SECOND);

	    // MOMENTS

	    var getSetSecond = makeGetSet('Seconds', false);

	    // FORMATTING

	    addFormatToken('S', 0, 0, function () {
	        return ~~(this.millisecond() / 100);
	    });

	    addFormatToken(0, ['SS', 2], 0, function () {
	        return ~~(this.millisecond() / 10);
	    });

	    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	    addFormatToken(0, ['SSSS', 4], 0, function () {
	        return this.millisecond() * 10;
	    });
	    addFormatToken(0, ['SSSSS', 5], 0, function () {
	        return this.millisecond() * 100;
	    });
	    addFormatToken(0, ['SSSSSS', 6], 0, function () {
	        return this.millisecond() * 1000;
	    });
	    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	        return this.millisecond() * 10000;
	    });
	    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	        return this.millisecond() * 100000;
	    });
	    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	        return this.millisecond() * 1000000;
	    });

	    // PARSING

	    addRegexToken('S', match1to3, match1);
	    addRegexToken('SS', match1to3, match2);
	    addRegexToken('SSS', match1to3, match3);

	    var token, getSetMillisecond;
	    for (token = 'SSSS'; token.length <= 9; token += 'S') {
	        addRegexToken(token, matchUnsigned);
	    }

	    function parseMs(input, array) {
	        array[MILLISECOND] = toInt(('0.' + input) * 1000);
	    }

	    for (token = 'S'; token.length <= 9; token += 'S') {
	        addParseToken(token, parseMs);
	    }

	    getSetMillisecond = makeGetSet('Milliseconds', false);

	    // FORMATTING

	    addFormatToken('z', 0, 0, 'zoneAbbr');
	    addFormatToken('zz', 0, 0, 'zoneName');

	    // MOMENTS

	    function getZoneAbbr() {
	        return this._isUTC ? 'UTC' : '';
	    }

	    function getZoneName() {
	        return this._isUTC ? 'Coordinated Universal Time' : '';
	    }

	    var proto = Moment.prototype;

	    proto.add = add;
	    proto.calendar = calendar$1;
	    proto.clone = clone;
	    proto.diff = diff;
	    proto.endOf = endOf;
	    proto.format = format;
	    proto.from = from;
	    proto.fromNow = fromNow;
	    proto.to = to;
	    proto.toNow = toNow;
	    proto.get = stringGet;
	    proto.invalidAt = invalidAt;
	    proto.isAfter = isAfter;
	    proto.isBefore = isBefore;
	    proto.isBetween = isBetween;
	    proto.isSame = isSame;
	    proto.isSameOrAfter = isSameOrAfter;
	    proto.isSameOrBefore = isSameOrBefore;
	    proto.isValid = isValid$2;
	    proto.lang = lang;
	    proto.locale = locale;
	    proto.localeData = localeData;
	    proto.max = prototypeMax;
	    proto.min = prototypeMin;
	    proto.parsingFlags = parsingFlags;
	    proto.set = stringSet;
	    proto.startOf = startOf;
	    proto.subtract = subtract;
	    proto.toArray = toArray;
	    proto.toObject = toObject;
	    proto.toDate = toDate;
	    proto.toISOString = toISOString;
	    proto.inspect = inspect;
	    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
	        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
	            return 'Moment<' + this.format() + '>';
	        };
	    }
	    proto.toJSON = toJSON;
	    proto.toString = toString;
	    proto.unix = unix;
	    proto.valueOf = valueOf;
	    proto.creationData = creationData;
	    proto.eraName = getEraName;
	    proto.eraNarrow = getEraNarrow;
	    proto.eraAbbr = getEraAbbr;
	    proto.eraYear = getEraYear;
	    proto.year = getSetYear;
	    proto.isLeapYear = getIsLeapYear;
	    proto.weekYear = getSetWeekYear;
	    proto.isoWeekYear = getSetISOWeekYear;
	    proto.quarter = proto.quarters = getSetQuarter;
	    proto.month = getSetMonth;
	    proto.daysInMonth = getDaysInMonth;
	    proto.week = proto.weeks = getSetWeek;
	    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
	    proto.weeksInYear = getWeeksInYear;
	    proto.weeksInWeekYear = getWeeksInWeekYear;
	    proto.isoWeeksInYear = getISOWeeksInYear;
	    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
	    proto.date = getSetDayOfMonth;
	    proto.day = proto.days = getSetDayOfWeek;
	    proto.weekday = getSetLocaleDayOfWeek;
	    proto.isoWeekday = getSetISODayOfWeek;
	    proto.dayOfYear = getSetDayOfYear;
	    proto.hour = proto.hours = getSetHour;
	    proto.minute = proto.minutes = getSetMinute;
	    proto.second = proto.seconds = getSetSecond;
	    proto.millisecond = proto.milliseconds = getSetMillisecond;
	    proto.utcOffset = getSetOffset;
	    proto.utc = setOffsetToUTC;
	    proto.local = setOffsetToLocal;
	    proto.parseZone = setOffsetToParsedOffset;
	    proto.hasAlignedHourOffset = hasAlignedHourOffset;
	    proto.isDST = isDaylightSavingTime;
	    proto.isLocal = isLocal;
	    proto.isUtcOffset = isUtcOffset;
	    proto.isUtc = isUtc;
	    proto.isUTC = isUtc;
	    proto.zoneAbbr = getZoneAbbr;
	    proto.zoneName = getZoneName;
	    proto.dates = deprecate(
	        'dates accessor is deprecated. Use date instead.',
	        getSetDayOfMonth
	    );
	    proto.months = deprecate(
	        'months accessor is deprecated. Use month instead',
	        getSetMonth
	    );
	    proto.years = deprecate(
	        'years accessor is deprecated. Use year instead',
	        getSetYear
	    );
	    proto.zone = deprecate(
	        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
	        getSetZone
	    );
	    proto.isDSTShifted = deprecate(
	        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
	        isDaylightSavingTimeShifted
	    );

	    function createUnix(input) {
	        return createLocal(input * 1000);
	    }

	    function createInZone() {
	        return createLocal.apply(null, arguments).parseZone();
	    }

	    function preParsePostFormat(string) {
	        return string;
	    }

	    var proto$1 = Locale.prototype;

	    proto$1.calendar = calendar;
	    proto$1.longDateFormat = longDateFormat;
	    proto$1.invalidDate = invalidDate;
	    proto$1.ordinal = ordinal;
	    proto$1.preparse = preParsePostFormat;
	    proto$1.postformat = preParsePostFormat;
	    proto$1.relativeTime = relativeTime;
	    proto$1.pastFuture = pastFuture;
	    proto$1.set = set;
	    proto$1.eras = localeEras;
	    proto$1.erasParse = localeErasParse;
	    proto$1.erasConvertYear = localeErasConvertYear;
	    proto$1.erasAbbrRegex = erasAbbrRegex;
	    proto$1.erasNameRegex = erasNameRegex;
	    proto$1.erasNarrowRegex = erasNarrowRegex;

	    proto$1.months = localeMonths;
	    proto$1.monthsShort = localeMonthsShort;
	    proto$1.monthsParse = localeMonthsParse;
	    proto$1.monthsRegex = monthsRegex;
	    proto$1.monthsShortRegex = monthsShortRegex;
	    proto$1.week = localeWeek;
	    proto$1.firstDayOfYear = localeFirstDayOfYear;
	    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

	    proto$1.weekdays = localeWeekdays;
	    proto$1.weekdaysMin = localeWeekdaysMin;
	    proto$1.weekdaysShort = localeWeekdaysShort;
	    proto$1.weekdaysParse = localeWeekdaysParse;

	    proto$1.weekdaysRegex = weekdaysRegex;
	    proto$1.weekdaysShortRegex = weekdaysShortRegex;
	    proto$1.weekdaysMinRegex = weekdaysMinRegex;

	    proto$1.isPM = localeIsPM;
	    proto$1.meridiem = localeMeridiem;

	    function get$1(format, index, field, setter) {
	        var locale = getLocale(),
	            utc = createUTC().set(setter, index);
	        return locale[field](utc, format);
	    }

	    function listMonthsImpl(format, index, field) {
	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }

	        format = format || '';

	        if (index != null) {
	            return get$1(format, index, field, 'month');
	        }

	        var i,
	            out = [];
	        for (i = 0; i < 12; i++) {
	            out[i] = get$1(format, i, field, 'month');
	        }
	        return out;
	    }

	    // ()
	    // (5)
	    // (fmt, 5)
	    // (fmt)
	    // (true)
	    // (true, 5)
	    // (true, fmt, 5)
	    // (true, fmt)
	    function listWeekdaysImpl(localeSorted, format, index, field) {
	        if (typeof localeSorted === 'boolean') {
	            if (isNumber(format)) {
	                index = format;
	                format = undefined;
	            }

	            format = format || '';
	        } else {
	            format = localeSorted;
	            index = format;
	            localeSorted = false;

	            if (isNumber(format)) {
	                index = format;
	                format = undefined;
	            }

	            format = format || '';
	        }

	        var locale = getLocale(),
	            shift = localeSorted ? locale._week.dow : 0,
	            i,
	            out = [];

	        if (index != null) {
	            return get$1(format, (index + shift) % 7, field, 'day');
	        }

	        for (i = 0; i < 7; i++) {
	            out[i] = get$1(format, (i + shift) % 7, field, 'day');
	        }
	        return out;
	    }

	    function listMonths(format, index) {
	        return listMonthsImpl(format, index, 'months');
	    }

	    function listMonthsShort(format, index) {
	        return listMonthsImpl(format, index, 'monthsShort');
	    }

	    function listWeekdays(localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	    }

	    function listWeekdaysShort(localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	    }

	    function listWeekdaysMin(localeSorted, format, index) {
	        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	    }

	    getSetGlobalLocale('en', {
	        eras: [
	            {
	                since: '0001-01-01',
	                until: +Infinity,
	                offset: 1,
	                name: 'Anno Domini',
	                narrow: 'AD',
	                abbr: 'AD',
	            },
	            {
	                since: '0000-12-31',
	                until: -Infinity,
	                offset: 1,
	                name: 'Before Christ',
	                narrow: 'BC',
	                abbr: 'BC',
	            },
	        ],
	        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	        ordinal: function (number) {
	            var b = number % 10,
	                output =
	                    toInt((number % 100) / 10) === 1
	                        ? 'th'
	                        : b === 1
	                          ? 'st'
	                          : b === 2
	                            ? 'nd'
	                            : b === 3
	                              ? 'rd'
	                              : 'th';
	            return number + output;
	        },
	    });

	    // Side effect imports

	    hooks.lang = deprecate(
	        'moment.lang is deprecated. Use moment.locale instead.',
	        getSetGlobalLocale
	    );
	    hooks.langData = deprecate(
	        'moment.langData is deprecated. Use moment.localeData instead.',
	        getLocale
	    );

	    var mathAbs = Math.abs;

	    function abs() {
	        var data = this._data;

	        this._milliseconds = mathAbs(this._milliseconds);
	        this._days = mathAbs(this._days);
	        this._months = mathAbs(this._months);

	        data.milliseconds = mathAbs(data.milliseconds);
	        data.seconds = mathAbs(data.seconds);
	        data.minutes = mathAbs(data.minutes);
	        data.hours = mathAbs(data.hours);
	        data.months = mathAbs(data.months);
	        data.years = mathAbs(data.years);

	        return this;
	    }

	    function addSubtract$1(duration, input, value, direction) {
	        var other = createDuration(input, value);

	        duration._milliseconds += direction * other._milliseconds;
	        duration._days += direction * other._days;
	        duration._months += direction * other._months;

	        return duration._bubble();
	    }

	    // supports only 2.0-style add(1, 's') or add(duration)
	    function add$1(input, value) {
	        return addSubtract$1(this, input, value, 1);
	    }

	    // supports only 2.0-style subtract(1, 's') or subtract(duration)
	    function subtract$1(input, value) {
	        return addSubtract$1(this, input, value, -1);
	    }

	    function absCeil(number) {
	        if (number < 0) {
	            return Math.floor(number);
	        } else {
	            return Math.ceil(number);
	        }
	    }

	    function bubble() {
	        var milliseconds = this._milliseconds,
	            days = this._days,
	            months = this._months,
	            data = this._data,
	            seconds,
	            minutes,
	            hours,
	            years,
	            monthsFromDays;

	        // if we have a mix of positive and negative values, bubble down first
	        // check: https://github.com/moment/moment/issues/2166
	        if (
	            !(
	                (milliseconds >= 0 && days >= 0 && months >= 0) ||
	                (milliseconds <= 0 && days <= 0 && months <= 0)
	            )
	        ) {
	            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	            days = 0;
	            months = 0;
	        }

	        // The following code bubbles up values, see the tests for
	        // examples of what that means.
	        data.milliseconds = milliseconds % 1000;

	        seconds = absFloor(milliseconds / 1000);
	        data.seconds = seconds % 60;

	        minutes = absFloor(seconds / 60);
	        data.minutes = minutes % 60;

	        hours = absFloor(minutes / 60);
	        data.hours = hours % 24;

	        days += absFloor(hours / 24);

	        // convert days to months
	        monthsFromDays = absFloor(daysToMonths(days));
	        months += monthsFromDays;
	        days -= absCeil(monthsToDays(monthsFromDays));

	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;

	        data.days = days;
	        data.months = months;
	        data.years = years;

	        return this;
	    }

	    function daysToMonths(days) {
	        // 400 years have 146097 days (taking into account leap year rules)
	        // 400 years have 12 months === 4800
	        return (days * 4800) / 146097;
	    }

	    function monthsToDays(months) {
	        // the reverse of daysToMonths
	        return (months * 146097) / 4800;
	    }

	    function as(units) {
	        if (!this.isValid()) {
	            return NaN;
	        }
	        var days,
	            months,
	            milliseconds = this._milliseconds;

	        units = normalizeUnits(units);

	        if (units === 'month' || units === 'quarter' || units === 'year') {
	            days = this._days + milliseconds / 864e5;
	            months = this._months + daysToMonths(days);
	            switch (units) {
	                case 'month':
	                    return months;
	                case 'quarter':
	                    return months / 3;
	                case 'year':
	                    return months / 12;
	            }
	        } else {
	            // handle milliseconds separately because of floating point math errors (issue #1867)
	            days = this._days + Math.round(monthsToDays(this._months));
	            switch (units) {
	                case 'week':
	                    return days / 7 + milliseconds / 6048e5;
	                case 'day':
	                    return days + milliseconds / 864e5;
	                case 'hour':
	                    return days * 24 + milliseconds / 36e5;
	                case 'minute':
	                    return days * 1440 + milliseconds / 6e4;
	                case 'second':
	                    return days * 86400 + milliseconds / 1000;
	                // Math.floor prevents floating point math errors here
	                case 'millisecond':
	                    return Math.floor(days * 864e5) + milliseconds;
	                default:
	                    throw new Error('Unknown unit ' + units);
	            }
	        }
	    }

	    function makeAs(alias) {
	        return function () {
	            return this.as(alias);
	        };
	    }

	    var asMilliseconds = makeAs('ms'),
	        asSeconds = makeAs('s'),
	        asMinutes = makeAs('m'),
	        asHours = makeAs('h'),
	        asDays = makeAs('d'),
	        asWeeks = makeAs('w'),
	        asMonths = makeAs('M'),
	        asQuarters = makeAs('Q'),
	        asYears = makeAs('y'),
	        valueOf$1 = asMilliseconds;

	    function clone$1() {
	        return createDuration(this);
	    }

	    function get$2(units) {
	        units = normalizeUnits(units);
	        return this.isValid() ? this[units + 's']() : NaN;
	    }

	    function makeGetter(name) {
	        return function () {
	            return this.isValid() ? this._data[name] : NaN;
	        };
	    }

	    var milliseconds = makeGetter('milliseconds'),
	        seconds = makeGetter('seconds'),
	        minutes = makeGetter('minutes'),
	        hours = makeGetter('hours'),
	        days = makeGetter('days'),
	        months = makeGetter('months'),
	        years = makeGetter('years');

	    function weeks() {
	        return absFloor(this.days() / 7);
	    }

	    var round = Math.round,
	        thresholds = {
	            ss: 44, // a few seconds to seconds
	            s: 45, // seconds to minute
	            m: 45, // minutes to hour
	            h: 22, // hours to day
	            d: 26, // days to month/week
	            w: null, // weeks to month
	            M: 11, // months to year
	        };

	    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	    }

	    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
	        var duration = createDuration(posNegDuration).abs(),
	            seconds = round(duration.as('s')),
	            minutes = round(duration.as('m')),
	            hours = round(duration.as('h')),
	            days = round(duration.as('d')),
	            months = round(duration.as('M')),
	            weeks = round(duration.as('w')),
	            years = round(duration.as('y')),
	            a =
	                (seconds <= thresholds.ss && ['s', seconds]) ||
	                (seconds < thresholds.s && ['ss', seconds]) ||
	                (minutes <= 1 && ['m']) ||
	                (minutes < thresholds.m && ['mm', minutes]) ||
	                (hours <= 1 && ['h']) ||
	                (hours < thresholds.h && ['hh', hours]) ||
	                (days <= 1 && ['d']) ||
	                (days < thresholds.d && ['dd', days]);

	        if (thresholds.w != null) {
	            a =
	                a ||
	                (weeks <= 1 && ['w']) ||
	                (weeks < thresholds.w && ['ww', weeks]);
	        }
	        a = a ||
	            (months <= 1 && ['M']) ||
	            (months < thresholds.M && ['MM', months]) ||
	            (years <= 1 && ['y']) || ['yy', years];

	        a[2] = withoutSuffix;
	        a[3] = +posNegDuration > 0;
	        a[4] = locale;
	        return substituteTimeAgo.apply(null, a);
	    }

	    // This function allows you to set the rounding function for relative time strings
	    function getSetRelativeTimeRounding(roundingFunction) {
	        if (roundingFunction === undefined) {
	            return round;
	        }
	        if (typeof roundingFunction === 'function') {
	            round = roundingFunction;
	            return true;
	        }
	        return false;
	    }

	    // This function allows you to set a threshold for relative time strings
	    function getSetRelativeTimeThreshold(threshold, limit) {
	        if (thresholds[threshold] === undefined) {
	            return false;
	        }
	        if (limit === undefined) {
	            return thresholds[threshold];
	        }
	        thresholds[threshold] = limit;
	        if (threshold === 's') {
	            thresholds.ss = limit - 1;
	        }
	        return true;
	    }

	    function humanize(argWithSuffix, argThresholds) {
	        if (!this.isValid()) {
	            return this.localeData().invalidDate();
	        }

	        var withSuffix = false,
	            th = thresholds,
	            locale,
	            output;

	        if (typeof argWithSuffix === 'object') {
	            argThresholds = argWithSuffix;
	            argWithSuffix = false;
	        }
	        if (typeof argWithSuffix === 'boolean') {
	            withSuffix = argWithSuffix;
	        }
	        if (typeof argThresholds === 'object') {
	            th = Object.assign({}, thresholds, argThresholds);
	            if (argThresholds.s != null && argThresholds.ss == null) {
	                th.ss = argThresholds.s - 1;
	            }
	        }

	        locale = this.localeData();
	        output = relativeTime$1(this, !withSuffix, th, locale);

	        if (withSuffix) {
	            output = locale.pastFuture(+this, output);
	        }

	        return locale.postformat(output);
	    }

	    var abs$1 = Math.abs;

	    function sign(x) {
	        return (x > 0) - (x < 0) || +x;
	    }

	    function toISOString$1() {
	        // for ISO strings we do not use the normal bubbling rules:
	        //  * milliseconds bubble up until they become hours
	        //  * days do not bubble at all
	        //  * months bubble up until they become years
	        // This is because there is no context-free conversion between hours and days
	        // (think of clock changes)
	        // and also not between days and months (28-31 days per month)
	        if (!this.isValid()) {
	            return this.localeData().invalidDate();
	        }

	        var seconds = abs$1(this._milliseconds) / 1000,
	            days = abs$1(this._days),
	            months = abs$1(this._months),
	            minutes,
	            hours,
	            years,
	            s,
	            total = this.asSeconds(),
	            totalSign,
	            ymSign,
	            daysSign,
	            hmsSign;

	        if (!total) {
	            // this is the same as C#'s (Noda) and python (isodate)...
	            // but not other JS (goog.date)
	            return 'P0D';
	        }

	        // 3600 seconds -> 60 minutes -> 1 hour
	        minutes = absFloor(seconds / 60);
	        hours = absFloor(minutes / 60);
	        seconds %= 60;
	        minutes %= 60;

	        // 12 months -> 1 year
	        years = absFloor(months / 12);
	        months %= 12;

	        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

	        totalSign = total < 0 ? '-' : '';
	        ymSign = sign(this._months) !== sign(total) ? '-' : '';
	        daysSign = sign(this._days) !== sign(total) ? '-' : '';
	        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

	        return (
	            totalSign +
	            'P' +
	            (years ? ymSign + years + 'Y' : '') +
	            (months ? ymSign + months + 'M' : '') +
	            (days ? daysSign + days + 'D' : '') +
	            (hours || minutes || seconds ? 'T' : '') +
	            (hours ? hmsSign + hours + 'H' : '') +
	            (minutes ? hmsSign + minutes + 'M' : '') +
	            (seconds ? hmsSign + s + 'S' : '')
	        );
	    }

	    var proto$2 = Duration.prototype;

	    proto$2.isValid = isValid$1;
	    proto$2.abs = abs;
	    proto$2.add = add$1;
	    proto$2.subtract = subtract$1;
	    proto$2.as = as;
	    proto$2.asMilliseconds = asMilliseconds;
	    proto$2.asSeconds = asSeconds;
	    proto$2.asMinutes = asMinutes;
	    proto$2.asHours = asHours;
	    proto$2.asDays = asDays;
	    proto$2.asWeeks = asWeeks;
	    proto$2.asMonths = asMonths;
	    proto$2.asQuarters = asQuarters;
	    proto$2.asYears = asYears;
	    proto$2.valueOf = valueOf$1;
	    proto$2._bubble = bubble;
	    proto$2.clone = clone$1;
	    proto$2.get = get$2;
	    proto$2.milliseconds = milliseconds;
	    proto$2.seconds = seconds;
	    proto$2.minutes = minutes;
	    proto$2.hours = hours;
	    proto$2.days = days;
	    proto$2.weeks = weeks;
	    proto$2.months = months;
	    proto$2.years = years;
	    proto$2.humanize = humanize;
	    proto$2.toISOString = toISOString$1;
	    proto$2.toString = toISOString$1;
	    proto$2.toJSON = toISOString$1;
	    proto$2.locale = locale;
	    proto$2.localeData = localeData;

	    proto$2.toIsoString = deprecate(
	        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
	        toISOString$1
	    );
	    proto$2.lang = lang;

	    // FORMATTING

	    addFormatToken('X', 0, 0, 'unix');
	    addFormatToken('x', 0, 0, 'valueOf');

	    // PARSING

	    addRegexToken('x', matchSigned);
	    addRegexToken('X', matchTimestamp);
	    addParseToken('X', function (input, array, config) {
	        config._d = new Date(parseFloat(input) * 1000);
	    });
	    addParseToken('x', function (input, array, config) {
	        config._d = new Date(toInt(input));
	    });

	    //! moment.js

	    hooks.version = '2.30.1';

	    setHookCallback(createLocal);

	    hooks.fn = proto;
	    hooks.min = min;
	    hooks.max = max;
	    hooks.now = now;
	    hooks.utc = createUTC;
	    hooks.unix = createUnix;
	    hooks.months = listMonths;
	    hooks.isDate = isDate;
	    hooks.locale = getSetGlobalLocale;
	    hooks.invalid = createInvalid;
	    hooks.duration = createDuration;
	    hooks.isMoment = isMoment;
	    hooks.weekdays = listWeekdays;
	    hooks.parseZone = createInZone;
	    hooks.localeData = getLocale;
	    hooks.isDuration = isDuration;
	    hooks.monthsShort = listMonthsShort;
	    hooks.weekdaysMin = listWeekdaysMin;
	    hooks.defineLocale = defineLocale;
	    hooks.updateLocale = updateLocale;
	    hooks.locales = listLocales;
	    hooks.weekdaysShort = listWeekdaysShort;
	    hooks.normalizeUnits = normalizeUnits;
	    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
	    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	    hooks.calendarFormat = getCalendarFormat;
	    hooks.prototype = proto;

	    // currently HTML5 input type only supports 24-hour formats
	    hooks.HTML5_FMT = {
	        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
	        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
	        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
	        DATE: 'YYYY-MM-DD', // <input type="date" />
	        TIME: 'HH:mm', // <input type="time" />
	        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
	        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
	        WEEK: 'GGGG-[W]WW', // <input type="week" />
	        MONTH: 'YYYY-MM', // <input type="month" />
	    };

	    return hooks;

	})));
	});

	createCommonjsModule(function (module) {
	/**
	* @version: 3.1
	* @author: Dan Grossman http://www.dangrossman.info/
	* @copyright: Copyright (c) 2012-2019 Dan Grossman. All rights reserved.
	* @license: Licensed under the MIT license. See http://www.opensource.org/licenses/mit-license.php
	* @website: http://www.daterangepicker.com/
	*/
	// Following the UMD template https://github.com/umdjs/umd/blob/master/templates/returnExportsGlobal.js
	(function (root, factory) {
	    if (module.exports) {
	        // Node / Browserify
	        //isomorphic issue
	        var jQuery = (typeof window != 'undefined') ? window.jQuery : undefined;
	        if (!jQuery) {
	            jQuery = jquery__default["default"];
	            if (!jQuery.fn) jQuery.fn = {};
	        }
	        var moment$1 = (typeof window != 'undefined' && typeof window.moment != 'undefined') ? window.moment : moment;
	        module.exports = factory(moment$1, jQuery);
	    } else {
	        // Browser globals
	        root.daterangepicker = factory(root.moment, root.jQuery);
	    }
	}(commonjsGlobal, function(moment, $) {
	    var DateRangePicker = function(element, options, cb) {

	        //default settings for options
	        this.parentEl = 'body';
	        this.element = $(element);
	        this.startDate = moment().startOf('day');
	        this.endDate = moment().endOf('day');
	        this.minDate = false;
	        this.maxDate = false;
	        this.maxSpan = false;
	        this.autoApply = false;
	        this.singleDatePicker = false;
	        this.showDropdowns = false;
	        this.minYear = moment().subtract(100, 'year').format('YYYY');
	        this.maxYear = moment().add(100, 'year').format('YYYY');
	        this.showWeekNumbers = false;
	        this.showISOWeekNumbers = false;
	        this.showCustomRangeLabel = true;
	        this.timePicker = false;
	        this.timePicker24Hour = false;
	        this.timePickerIncrement = 1;
	        this.timePickerSeconds = false;
	        this.linkedCalendars = true;
	        this.autoUpdateInput = true;
	        this.alwaysShowCalendars = false;
	        this.ranges = {};

	        this.opens = 'right';
	        if (this.element.hasClass('pull-right'))
	            this.opens = 'left';

	        this.drops = 'down';
	        if (this.element.hasClass('dropup'))
	            this.drops = 'up';

	        this.buttonClasses = 'btn btn-sm';
	        this.applyButtonClasses = 'btn-primary';
	        this.cancelButtonClasses = 'btn-default';

	        this.locale = {
	            direction: 'ltr',
	            format: moment.localeData().longDateFormat('L'),
	            separator: ' - ',
	            applyLabel: 'Apply',
	            cancelLabel: 'Cancel',
	            weekLabel: 'W',
	            customRangeLabel: 'Custom Range',
	            daysOfWeek: moment.weekdaysMin(),
	            monthNames: moment.monthsShort(),
	            firstDay: moment.localeData().firstDayOfWeek()
	        };

	        this.callback = function() { };

	        //some state information
	        this.isShowing = false;
	        this.leftCalendar = {};
	        this.rightCalendar = {};

	        //custom options from user
	        if (typeof options !== 'object' || options === null)
	            options = {};

	        //allow setting options with data attributes
	        //data-api options will be overwritten with custom javascript options
	        options = $.extend(this.element.data(), options);

	        //html template for the picker UI
	        if (typeof options.template !== 'string' && !(options.template instanceof $))
	            options.template =
	            '<div class="daterangepicker">' +
	                '<div class="ranges"></div>' +
	                '<div class="drp-calendar left">' +
	                    '<div class="calendar-table"></div>' +
	                    '<div class="calendar-time"></div>' +
	                '</div>' +
	                '<div class="drp-calendar right">' +
	                    '<div class="calendar-table"></div>' +
	                    '<div class="calendar-time"></div>' +
	                '</div>' +
	                '<div class="drp-buttons">' +
	                    '<span class="drp-selected"></span>' +
	                    '<button class="cancelBtn" type="button"></button>' +
	                    '<button class="applyBtn" disabled="disabled" type="button"></button> ' +
	                '</div>' +
	            '</div>';

	        this.parentEl = (options.parentEl && $(options.parentEl).length) ? $(options.parentEl) : $(this.parentEl);
	        this.container = $(options.template).appendTo(this.parentEl);

	        //
	        // handle all the possible options overriding defaults
	        //

	        if (typeof options.locale === 'object') {

	            if (typeof options.locale.direction === 'string')
	                this.locale.direction = options.locale.direction;

	            if (typeof options.locale.format === 'string')
	                this.locale.format = options.locale.format;

	            if (typeof options.locale.separator === 'string')
	                this.locale.separator = options.locale.separator;

	            if (typeof options.locale.daysOfWeek === 'object')
	                this.locale.daysOfWeek = options.locale.daysOfWeek.slice();

	            if (typeof options.locale.monthNames === 'object')
	              this.locale.monthNames = options.locale.monthNames.slice();

	            if (typeof options.locale.firstDay === 'number')
	              this.locale.firstDay = options.locale.firstDay;

	            if (typeof options.locale.applyLabel === 'string')
	              this.locale.applyLabel = options.locale.applyLabel;

	            if (typeof options.locale.cancelLabel === 'string')
	              this.locale.cancelLabel = options.locale.cancelLabel;

	            if (typeof options.locale.weekLabel === 'string')
	              this.locale.weekLabel = options.locale.weekLabel;

	            if (typeof options.locale.customRangeLabel === 'string'){
	                //Support unicode chars in the custom range name.
	                var elem = document.createElement('textarea');
	                elem.innerHTML = options.locale.customRangeLabel;
	                var rangeHtml = elem.value;
	                this.locale.customRangeLabel = rangeHtml;
	            }
	        }
	        this.container.addClass(this.locale.direction);

	        if (typeof options.startDate === 'string')
	            this.startDate = moment(options.startDate, this.locale.format);

	        if (typeof options.endDate === 'string')
	            this.endDate = moment(options.endDate, this.locale.format);

	        if (typeof options.minDate === 'string')
	            this.minDate = moment(options.minDate, this.locale.format);

	        if (typeof options.maxDate === 'string')
	            this.maxDate = moment(options.maxDate, this.locale.format);

	        if (typeof options.startDate === 'object')
	            this.startDate = moment(options.startDate);

	        if (typeof options.endDate === 'object')
	            this.endDate = moment(options.endDate);

	        if (typeof options.minDate === 'object')
	            this.minDate = moment(options.minDate);

	        if (typeof options.maxDate === 'object')
	            this.maxDate = moment(options.maxDate);

	        // sanity check for bad options
	        if (this.minDate && this.startDate.isBefore(this.minDate))
	            this.startDate = this.minDate.clone();

	        // sanity check for bad options
	        if (this.maxDate && this.endDate.isAfter(this.maxDate))
	            this.endDate = this.maxDate.clone();

	        if (typeof options.applyButtonClasses === 'string')
	            this.applyButtonClasses = options.applyButtonClasses;

	        if (typeof options.applyClass === 'string') //backwards compat
	            this.applyButtonClasses = options.applyClass;

	        if (typeof options.cancelButtonClasses === 'string')
	            this.cancelButtonClasses = options.cancelButtonClasses;

	        if (typeof options.cancelClass === 'string') //backwards compat
	            this.cancelButtonClasses = options.cancelClass;

	        if (typeof options.maxSpan === 'object')
	            this.maxSpan = options.maxSpan;

	        if (typeof options.dateLimit === 'object') //backwards compat
	            this.maxSpan = options.dateLimit;

	        if (typeof options.opens === 'string')
	            this.opens = options.opens;

	        if (typeof options.drops === 'string')
	            this.drops = options.drops;

	        if (typeof options.showWeekNumbers === 'boolean')
	            this.showWeekNumbers = options.showWeekNumbers;

	        if (typeof options.showISOWeekNumbers === 'boolean')
	            this.showISOWeekNumbers = options.showISOWeekNumbers;

	        if (typeof options.buttonClasses === 'string')
	            this.buttonClasses = options.buttonClasses;

	        if (typeof options.buttonClasses === 'object')
	            this.buttonClasses = options.buttonClasses.join(' ');

	        if (typeof options.showDropdowns === 'boolean')
	            this.showDropdowns = options.showDropdowns;

	        if (typeof options.minYear === 'number')
	            this.minYear = options.minYear;

	        if (typeof options.maxYear === 'number')
	            this.maxYear = options.maxYear;

	        if (typeof options.showCustomRangeLabel === 'boolean')
	            this.showCustomRangeLabel = options.showCustomRangeLabel;

	        if (typeof options.singleDatePicker === 'boolean') {
	            this.singleDatePicker = options.singleDatePicker;
	            if (this.singleDatePicker)
	                this.endDate = this.startDate.clone();
	        }

	        if (typeof options.timePicker === 'boolean')
	            this.timePicker = options.timePicker;

	        if (typeof options.timePickerSeconds === 'boolean')
	            this.timePickerSeconds = options.timePickerSeconds;

	        if (typeof options.timePickerIncrement === 'number')
	            this.timePickerIncrement = options.timePickerIncrement;

	        if (typeof options.timePicker24Hour === 'boolean')
	            this.timePicker24Hour = options.timePicker24Hour;

	        if (typeof options.autoApply === 'boolean')
	            this.autoApply = options.autoApply;

	        if (typeof options.autoUpdateInput === 'boolean')
	            this.autoUpdateInput = options.autoUpdateInput;

	        if (typeof options.linkedCalendars === 'boolean')
	            this.linkedCalendars = options.linkedCalendars;

	        if (typeof options.isInvalidDate === 'function')
	            this.isInvalidDate = options.isInvalidDate;

	        if (typeof options.isCustomDate === 'function')
	            this.isCustomDate = options.isCustomDate;

	        if (typeof options.alwaysShowCalendars === 'boolean')
	            this.alwaysShowCalendars = options.alwaysShowCalendars;

	        // update day names order to firstDay
	        if (this.locale.firstDay != 0) {
	            var iterator = this.locale.firstDay;
	            while (iterator > 0) {
	                this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift());
	                iterator--;
	            }
	        }

	        var start, end, range;

	        //if no start/end dates set, check if an input element contains initial values
	        if (typeof options.startDate === 'undefined' && typeof options.endDate === 'undefined') {
	            if ($(this.element).is(':text')) {
	                var val = $(this.element).val(),
	                    split = val.split(this.locale.separator);

	                start = end = null;

	                if (split.length == 2) {
	                    start = moment(split[0], this.locale.format);
	                    end = moment(split[1], this.locale.format);
	                } else if (this.singleDatePicker && val !== "") {
	                    start = moment(val, this.locale.format);
	                    end = moment(val, this.locale.format);
	                }
	                if (start !== null && end !== null) {
	                    this.setStartDate(start);
	                    this.setEndDate(end);
	                }
	            }
	        }

	        if (typeof options.ranges === 'object') {
	            for (range in options.ranges) {

	                if (typeof options.ranges[range][0] === 'string')
	                    start = moment(options.ranges[range][0], this.locale.format);
	                else
	                    start = moment(options.ranges[range][0]);

	                if (typeof options.ranges[range][1] === 'string')
	                    end = moment(options.ranges[range][1], this.locale.format);
	                else
	                    end = moment(options.ranges[range][1]);

	                // If the start or end date exceed those allowed by the minDate or maxSpan
	                // options, shorten the range to the allowable period.
	                if (this.minDate && start.isBefore(this.minDate))
	                    start = this.minDate.clone();

	                var maxDate = this.maxDate;
	                if (this.maxSpan && maxDate && start.clone().add(this.maxSpan).isAfter(maxDate))
	                    maxDate = start.clone().add(this.maxSpan);
	                if (maxDate && end.isAfter(maxDate))
	                    end = maxDate.clone();

	                // If the end of the range is before the minimum or the start of the range is
	                // after the maximum, don't display this range option at all.
	                if ((this.minDate && end.isBefore(this.minDate, this.timepicker ? 'minute' : 'day'))
	                  || (maxDate && start.isAfter(maxDate, this.timepicker ? 'minute' : 'day')))
	                    continue;

	                //Support unicode chars in the range names.
	                var elem = document.createElement('textarea');
	                elem.innerHTML = range;
	                var rangeHtml = elem.value;

	                this.ranges[rangeHtml] = [start, end];
	            }

	            var list = '<ul>';
	            for (range in this.ranges) {
	                list += '<li data-range-key="' + range + '">' + range + '</li>';
	            }
	            if (this.showCustomRangeLabel) {
	                list += '<li data-range-key="' + this.locale.customRangeLabel + '">' + this.locale.customRangeLabel + '</li>';
	            }
	            list += '</ul>';
	            this.container.find('.ranges').prepend(list);
	        }

	        if (typeof cb === 'function') {
	            this.callback = cb;
	        }

	        if (!this.timePicker) {
	            this.startDate = this.startDate.startOf('day');
	            this.endDate = this.endDate.endOf('day');
	            this.container.find('.calendar-time').hide();
	        }

	        //can't be used together for now
	        if (this.timePicker && this.autoApply)
	            this.autoApply = false;

	        if (this.autoApply) {
	            this.container.addClass('auto-apply');
	        }

	        if (typeof options.ranges === 'object')
	            this.container.addClass('show-ranges');

	        if (this.singleDatePicker) {
	            this.container.addClass('single');
	            this.container.find('.drp-calendar.left').addClass('single');
	            this.container.find('.drp-calendar.left').show();
	            this.container.find('.drp-calendar.right').hide();
	            if (!this.timePicker && this.autoApply) {
	                this.container.addClass('auto-apply');
	            }
	        }

	        if ((typeof options.ranges === 'undefined' && !this.singleDatePicker) || this.alwaysShowCalendars) {
	            this.container.addClass('show-calendar');
	        }

	        this.container.addClass('opens' + this.opens);

	        //apply CSS classes and labels to buttons
	        this.container.find('.applyBtn, .cancelBtn').addClass(this.buttonClasses);
	        if (this.applyButtonClasses.length)
	            this.container.find('.applyBtn').addClass(this.applyButtonClasses);
	        if (this.cancelButtonClasses.length)
	            this.container.find('.cancelBtn').addClass(this.cancelButtonClasses);
	        this.container.find('.applyBtn').html(this.locale.applyLabel);
	        this.container.find('.cancelBtn').html(this.locale.cancelLabel);

	        //
	        // event listeners
	        //

	        this.container.find('.drp-calendar')
	            .on('click.daterangepicker', '.prev', $.proxy(this.clickPrev, this))
	            .on('click.daterangepicker', '.next', $.proxy(this.clickNext, this))
	            .on('mousedown.daterangepicker', 'td.available', $.proxy(this.clickDate, this))
	            .on('mouseenter.daterangepicker', 'td.available', $.proxy(this.hoverDate, this))
	            .on('change.daterangepicker', 'select.yearselect', $.proxy(this.monthOrYearChanged, this))
	            .on('change.daterangepicker', 'select.monthselect', $.proxy(this.monthOrYearChanged, this))
	            .on('change.daterangepicker', 'select.hourselect,select.minuteselect,select.secondselect,select.ampmselect', $.proxy(this.timeChanged, this));

	        this.container.find('.ranges')
	            .on('click.daterangepicker', 'li', $.proxy(this.clickRange, this));

	        this.container.find('.drp-buttons')
	            .on('click.daterangepicker', 'button.applyBtn', $.proxy(this.clickApply, this))
	            .on('click.daterangepicker', 'button.cancelBtn', $.proxy(this.clickCancel, this));

	        if (this.element.is('input') || this.element.is('button')) {
	            this.element.on({
	                'click.daterangepicker': $.proxy(this.show, this),
	                'focus.daterangepicker': $.proxy(this.show, this),
	                'keyup.daterangepicker': $.proxy(this.elementChanged, this),
	                'keydown.daterangepicker': $.proxy(this.keydown, this) //IE 11 compatibility
	            });
	        } else {
	            this.element.on('click.daterangepicker', $.proxy(this.toggle, this));
	            this.element.on('keydown.daterangepicker', $.proxy(this.toggle, this));
	        }

	        //
	        // if attached to a text input, set the initial value
	        //

	        this.updateElement();

	    };

	    DateRangePicker.prototype = {

	        constructor: DateRangePicker,

	        setStartDate: function(startDate) {
	            if (typeof startDate === 'string')
	                this.startDate = moment(startDate, this.locale.format);

	            if (typeof startDate === 'object')
	                this.startDate = moment(startDate);

	            if (!this.timePicker)
	                this.startDate = this.startDate.startOf('day');

	            if (this.timePicker && this.timePickerIncrement)
	                this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);

	            if (this.minDate && this.startDate.isBefore(this.minDate)) {
	                this.startDate = this.minDate.clone();
	                if (this.timePicker && this.timePickerIncrement)
	                    this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
	            }

	            if (this.maxDate && this.startDate.isAfter(this.maxDate)) {
	                this.startDate = this.maxDate.clone();
	                if (this.timePicker && this.timePickerIncrement)
	                    this.startDate.minute(Math.floor(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
	            }

	            if (!this.isShowing)
	                this.updateElement();

	            this.updateMonthsInView();
	        },

	        setEndDate: function(endDate) {
	            if (typeof endDate === 'string')
	                this.endDate = moment(endDate, this.locale.format);

	            if (typeof endDate === 'object')
	                this.endDate = moment(endDate);

	            if (!this.timePicker)
	                this.endDate = this.endDate.endOf('day');

	            if (this.timePicker && this.timePickerIncrement)
	                this.endDate.minute(Math.round(this.endDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);

	            if (this.endDate.isBefore(this.startDate))
	                this.endDate = this.startDate.clone();

	            if (this.maxDate && this.endDate.isAfter(this.maxDate))
	                this.endDate = this.maxDate.clone();

	            if (this.maxSpan && this.startDate.clone().add(this.maxSpan).isBefore(this.endDate))
	                this.endDate = this.startDate.clone().add(this.maxSpan);

	            this.previousRightTime = this.endDate.clone();

	            this.container.find('.drp-selected').html(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));

	            if (!this.isShowing)
	                this.updateElement();

	            this.updateMonthsInView();
	        },

	        isInvalidDate: function() {
	            return false;
	        },

	        isCustomDate: function() {
	            return false;
	        },

	        updateView: function() {
	            if (this.timePicker) {
	                this.renderTimePicker('left');
	                this.renderTimePicker('right');
	                if (!this.endDate) {
	                    this.container.find('.right .calendar-time select').prop('disabled', true).addClass('disabled');
	                } else {
	                    this.container.find('.right .calendar-time select').prop('disabled', false).removeClass('disabled');
	                }
	            }
	            if (this.endDate)
	                this.container.find('.drp-selected').html(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
	            this.updateMonthsInView();
	            this.updateCalendars();
	            this.updateFormInputs();
	        },

	        updateMonthsInView: function() {
	            if (this.endDate) {

	                //if both dates are visible already, do nothing
	                if (!this.singleDatePicker && this.leftCalendar.month && this.rightCalendar.month &&
	                    (this.startDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.startDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
	                    &&
	                    (this.endDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.endDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
	                    ) {
	                    return;
	                }

	                this.leftCalendar.month = this.startDate.clone().date(2);
	                if (!this.linkedCalendars && (this.endDate.month() != this.startDate.month() || this.endDate.year() != this.startDate.year())) {
	                    this.rightCalendar.month = this.endDate.clone().date(2);
	                } else {
	                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
	                }

	            } else {
	                if (this.leftCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM') && this.rightCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM')) {
	                    this.leftCalendar.month = this.startDate.clone().date(2);
	                    this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
	                }
	            }
	            if (this.maxDate && this.linkedCalendars && !this.singleDatePicker && this.rightCalendar.month > this.maxDate) {
	              this.rightCalendar.month = this.maxDate.clone().date(2);
	              this.leftCalendar.month = this.maxDate.clone().date(2).subtract(1, 'month');
	            }
	        },

	        updateCalendars: function() {

	            if (this.timePicker) {
	                var hour, minute, second;
	                if (this.endDate) {
	                    hour = parseInt(this.container.find('.left .hourselect').val(), 10);
	                    minute = parseInt(this.container.find('.left .minuteselect').val(), 10);
	                    if (isNaN(minute)) {
	                        minute = parseInt(this.container.find('.left .minuteselect option:last').val(), 10);
	                    }
	                    second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;
	                    if (!this.timePicker24Hour) {
	                        var ampm = this.container.find('.left .ampmselect').val();
	                        if (ampm === 'PM' && hour < 12)
	                            hour += 12;
	                        if (ampm === 'AM' && hour === 12)
	                            hour = 0;
	                    }
	                } else {
	                    hour = parseInt(this.container.find('.right .hourselect').val(), 10);
	                    minute = parseInt(this.container.find('.right .minuteselect').val(), 10);
	                    if (isNaN(minute)) {
	                        minute = parseInt(this.container.find('.right .minuteselect option:last').val(), 10);
	                    }
	                    second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;
	                    if (!this.timePicker24Hour) {
	                        var ampm = this.container.find('.right .ampmselect').val();
	                        if (ampm === 'PM' && hour < 12)
	                            hour += 12;
	                        if (ampm === 'AM' && hour === 12)
	                            hour = 0;
	                    }
	                }
	                this.leftCalendar.month.hour(hour).minute(minute).second(second);
	                this.rightCalendar.month.hour(hour).minute(minute).second(second);
	            }

	            this.renderCalendar('left');
	            this.renderCalendar('right');

	            //highlight any predefined range matching the current start and end dates
	            this.container.find('.ranges li').removeClass('active');
	            if (this.endDate == null) return;

	            this.calculateChosenLabel();
	        },

	        renderCalendar: function(side) {

	            //
	            // Build the matrix of dates that will populate the calendar
	            //

	            var calendar = side == 'left' ? this.leftCalendar : this.rightCalendar;
	            var month = calendar.month.month();
	            var year = calendar.month.year();
	            var hour = calendar.month.hour();
	            var minute = calendar.month.minute();
	            var second = calendar.month.second();
	            var daysInMonth = moment([year, month]).daysInMonth();
	            var firstDay = moment([year, month, 1]);
	            var lastDay = moment([year, month, daysInMonth]);
	            var lastMonth = moment(firstDay).subtract(1, 'month').month();
	            var lastYear = moment(firstDay).subtract(1, 'month').year();
	            var daysInLastMonth = moment([lastYear, lastMonth]).daysInMonth();
	            var dayOfWeek = firstDay.day();

	            //initialize a 6 rows x 7 columns array for the calendar
	            var calendar = [];
	            calendar.firstDay = firstDay;
	            calendar.lastDay = lastDay;

	            for (var i = 0; i < 6; i++) {
	                calendar[i] = [];
	            }

	            //populate the calendar with date objects
	            var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;
	            if (startDay > daysInLastMonth)
	                startDay -= 7;

	            if (dayOfWeek == this.locale.firstDay)
	                startDay = daysInLastMonth - 6;

	            var curDate = moment([lastYear, lastMonth, startDay, 12, minute, second]);

	            var col, row;
	            for (var i = 0, col = 0, row = 0; i < 42; i++, col++, curDate = moment(curDate).add(24, 'hour')) {
	                if (i > 0 && col % 7 === 0) {
	                    col = 0;
	                    row++;
	                }
	                calendar[row][col] = curDate.clone().hour(hour).minute(minute).second(second);
	                curDate.hour(12);

	                if (this.minDate && calendar[row][col].format('YYYY-MM-DD') == this.minDate.format('YYYY-MM-DD') && calendar[row][col].isBefore(this.minDate) && side == 'left') {
	                    calendar[row][col] = this.minDate.clone();
	                }

	                if (this.maxDate && calendar[row][col].format('YYYY-MM-DD') == this.maxDate.format('YYYY-MM-DD') && calendar[row][col].isAfter(this.maxDate) && side == 'right') {
	                    calendar[row][col] = this.maxDate.clone();
	                }

	            }

	            //make the calendar object available to hoverDate/clickDate
	            if (side == 'left') {
	                this.leftCalendar.calendar = calendar;
	            } else {
	                this.rightCalendar.calendar = calendar;
	            }

	            //
	            // Display the calendar
	            //

	            var minDate = side == 'left' ? this.minDate : this.startDate;
	            var maxDate = this.maxDate;
	            side == 'left' ? this.startDate : this.endDate;
	            this.locale.direction == 'ltr' ? {left: 'chevron-left', right: 'chevron-right'} : {left: 'chevron-right', right: 'chevron-left'};

	            var html = '<table class="table-condensed">';
	            html += '<thead>';
	            html += '<tr>';

	            // add empty cell for week number
	            if (this.showWeekNumbers || this.showISOWeekNumbers)
	                html += '<th></th>';

	            if ((!minDate || minDate.isBefore(calendar.firstDay)) && (!this.linkedCalendars || side == 'left')) {
	                html += '<th class="prev available"><span></span></th>';
	            } else {
	                html += '<th></th>';
	            }

	            var dateHtml = this.locale.monthNames[calendar[1][1].month()] + calendar[1][1].format(" YYYY");

	            if (this.showDropdowns) {
	                var currentMonth = calendar[1][1].month();
	                var currentYear = calendar[1][1].year();
	                var maxYear = (maxDate && maxDate.year()) || (this.maxYear);
	                var minYear = (minDate && minDate.year()) || (this.minYear);
	                var inMinYear = currentYear == minYear;
	                var inMaxYear = currentYear == maxYear;

	                var monthHtml = '<select class="monthselect">';
	                for (var m = 0; m < 12; m++) {
	                    if ((!inMinYear || (minDate && m >= minDate.month())) && (!inMaxYear || (maxDate && m <= maxDate.month()))) {
	                        monthHtml += "<option value='" + m + "'" +
	                            (m === currentMonth ? " selected='selected'" : "") +
	                            ">" + this.locale.monthNames[m] + "</option>";
	                    } else {
	                        monthHtml += "<option value='" + m + "'" +
	                            (m === currentMonth ? " selected='selected'" : "") +
	                            " disabled='disabled'>" + this.locale.monthNames[m] + "</option>";
	                    }
	                }
	                monthHtml += "</select>";

	                var yearHtml = '<select class="yearselect">';
	                for (var y = minYear; y <= maxYear; y++) {
	                    yearHtml += '<option value="' + y + '"' +
	                        (y === currentYear ? ' selected="selected"' : '') +
	                        '>' + y + '</option>';
	                }
	                yearHtml += '</select>';

	                dateHtml = monthHtml + yearHtml;
	            }

	            html += '<th colspan="5" class="month">' + dateHtml + '</th>';
	            if ((!maxDate || maxDate.isAfter(calendar.lastDay)) && (!this.linkedCalendars || side == 'right' || this.singleDatePicker)) {
	                html += '<th class="next available"><span></span></th>';
	            } else {
	                html += '<th></th>';
	            }

	            html += '</tr>';
	            html += '<tr>';

	            // add week number label
	            if (this.showWeekNumbers || this.showISOWeekNumbers)
	                html += '<th class="week">' + this.locale.weekLabel + '</th>';

	            $.each(this.locale.daysOfWeek, function(index, dayOfWeek) {
	                html += '<th>' + dayOfWeek + '</th>';
	            });

	            html += '</tr>';
	            html += '</thead>';
	            html += '<tbody>';

	            //adjust maxDate to reflect the maxSpan setting in order to
	            //grey out end dates beyond the maxSpan
	            if (this.endDate == null && this.maxSpan) {
	                var maxLimit = this.startDate.clone().add(this.maxSpan).endOf('day');
	                if (!maxDate || maxLimit.isBefore(maxDate)) {
	                    maxDate = maxLimit;
	                }
	            }

	            for (var row = 0; row < 6; row++) {
	                html += '<tr>';

	                // add week number
	                if (this.showWeekNumbers)
	                    html += '<td class="week">' + calendar[row][0].week() + '</td>';
	                else if (this.showISOWeekNumbers)
	                    html += '<td class="week">' + calendar[row][0].isoWeek() + '</td>';

	                for (var col = 0; col < 7; col++) {

	                    var classes = [];

	                    //highlight today's date
	                    if (calendar[row][col].isSame(new Date(), "day"))
	                        classes.push('today');

	                    //highlight weekends
	                    if (calendar[row][col].isoWeekday() > 5)
	                        classes.push('weekend');

	                    //grey out the dates in other months displayed at beginning and end of this calendar
	                    if (calendar[row][col].month() != calendar[1][1].month())
	                        classes.push('off', 'ends');

	                    //don't allow selection of dates before the minimum date
	                    if (this.minDate && calendar[row][col].isBefore(this.minDate, 'day'))
	                        classes.push('off', 'disabled');

	                    //don't allow selection of dates after the maximum date
	                    if (maxDate && calendar[row][col].isAfter(maxDate, 'day'))
	                        classes.push('off', 'disabled');

	                    //don't allow selection of date if a custom function decides it's invalid
	                    if (this.isInvalidDate(calendar[row][col]))
	                        classes.push('off', 'disabled');

	                    //highlight the currently selected start date
	                    if (calendar[row][col].format('YYYY-MM-DD') == this.startDate.format('YYYY-MM-DD'))
	                        classes.push('active', 'start-date');

	                    //highlight the currently selected end date
	                    if (this.endDate != null && calendar[row][col].format('YYYY-MM-DD') == this.endDate.format('YYYY-MM-DD'))
	                        classes.push('active', 'end-date');

	                    //highlight dates in-between the selected dates
	                    if (this.endDate != null && calendar[row][col] > this.startDate && calendar[row][col] < this.endDate)
	                        classes.push('in-range');

	                    //apply custom classes for this date
	                    var isCustom = this.isCustomDate(calendar[row][col]);
	                    if (isCustom !== false) {
	                        if (typeof isCustom === 'string')
	                            classes.push(isCustom);
	                        else
	                            Array.prototype.push.apply(classes, isCustom);
	                    }

	                    var cname = '', disabled = false;
	                    for (var i = 0; i < classes.length; i++) {
	                        cname += classes[i] + ' ';
	                        if (classes[i] == 'disabled')
	                            disabled = true;
	                    }
	                    if (!disabled)
	                        cname += 'available';

	                    html += '<td class="' + cname.replace(/^\s+|\s+$/g, '') + '" data-title="' + 'r' + row + 'c' + col + '">' + calendar[row][col].date() + '</td>';

	                }
	                html += '</tr>';
	            }

	            html += '</tbody>';
	            html += '</table>';

	            this.container.find('.drp-calendar.' + side + ' .calendar-table').html(html);

	        },

	        renderTimePicker: function(side) {

	            // Don't bother updating the time picker if it's currently disabled
	            // because an end date hasn't been clicked yet
	            if (side == 'right' && !this.endDate) return;

	            var html, selected, minDate, maxDate = this.maxDate;

	            if (this.maxSpan && (!this.maxDate || this.startDate.clone().add(this.maxSpan).isBefore(this.maxDate)))
	                maxDate = this.startDate.clone().add(this.maxSpan);

	            if (side == 'left') {
	                selected = this.startDate.clone();
	                minDate = this.minDate;
	            } else if (side == 'right') {
	                selected = this.endDate.clone();
	                minDate = this.startDate;

	                //Preserve the time already selected
	                var timeSelector = this.container.find('.drp-calendar.right .calendar-time');
	                if (timeSelector.html() != '') {

	                    selected.hour(!isNaN(selected.hour()) ? selected.hour() : timeSelector.find('.hourselect option:selected').val());
	                    selected.minute(!isNaN(selected.minute()) ? selected.minute() : timeSelector.find('.minuteselect option:selected').val());
	                    selected.second(!isNaN(selected.second()) ? selected.second() : timeSelector.find('.secondselect option:selected').val());

	                    if (!this.timePicker24Hour) {
	                        var ampm = timeSelector.find('.ampmselect option:selected').val();
	                        if (ampm === 'PM' && selected.hour() < 12)
	                            selected.hour(selected.hour() + 12);
	                        if (ampm === 'AM' && selected.hour() === 12)
	                            selected.hour(0);
	                    }

	                }

	                if (selected.isBefore(this.startDate))
	                    selected = this.startDate.clone();

	                if (maxDate && selected.isAfter(maxDate))
	                    selected = maxDate.clone();

	            }

	            //
	            // hours
	            //

	            html = '<select class="hourselect">';

	            var start = this.timePicker24Hour ? 0 : 1;
	            var end = this.timePicker24Hour ? 23 : 12;

	            for (var i = start; i <= end; i++) {
	                var i_in_24 = i;
	                if (!this.timePicker24Hour)
	                    i_in_24 = selected.hour() >= 12 ? (i == 12 ? 12 : i + 12) : (i == 12 ? 0 : i);

	                var time = selected.clone().hour(i_in_24);
	                var disabled = false;
	                if (minDate && time.minute(59).isBefore(minDate))
	                    disabled = true;
	                if (maxDate && time.minute(0).isAfter(maxDate))
	                    disabled = true;

	                if (i_in_24 == selected.hour() && !disabled) {
	                    html += '<option value="' + i + '" selected="selected">' + i + '</option>';
	                } else if (disabled) {
	                    html += '<option value="' + i + '" disabled="disabled" class="disabled">' + i + '</option>';
	                } else {
	                    html += '<option value="' + i + '">' + i + '</option>';
	                }
	            }

	            html += '</select> ';

	            //
	            // minutes
	            //

	            html += ': <select class="minuteselect">';

	            for (var i = 0; i < 60; i += this.timePickerIncrement) {
	                var padded = i < 10 ? '0' + i : i;
	                var time = selected.clone().minute(i);

	                var disabled = false;
	                if (minDate && time.second(59).isBefore(minDate))
	                    disabled = true;
	                if (maxDate && time.second(0).isAfter(maxDate))
	                    disabled = true;

	                if (selected.minute() == i && !disabled) {
	                    html += '<option value="' + i + '" selected="selected">' + padded + '</option>';
	                } else if (disabled) {
	                    html += '<option value="' + i + '" disabled="disabled" class="disabled">' + padded + '</option>';
	                } else {
	                    html += '<option value="' + i + '">' + padded + '</option>';
	                }
	            }

	            html += '</select> ';

	            //
	            // seconds
	            //

	            if (this.timePickerSeconds) {
	                html += ': <select class="secondselect">';

	                for (var i = 0; i < 60; i++) {
	                    var padded = i < 10 ? '0' + i : i;
	                    var time = selected.clone().second(i);

	                    var disabled = false;
	                    if (minDate && time.isBefore(minDate))
	                        disabled = true;
	                    if (maxDate && time.isAfter(maxDate))
	                        disabled = true;

	                    if (selected.second() == i && !disabled) {
	                        html += '<option value="' + i + '" selected="selected">' + padded + '</option>';
	                    } else if (disabled) {
	                        html += '<option value="' + i + '" disabled="disabled" class="disabled">' + padded + '</option>';
	                    } else {
	                        html += '<option value="' + i + '">' + padded + '</option>';
	                    }
	                }

	                html += '</select> ';
	            }

	            //
	            // AM/PM
	            //

	            if (!this.timePicker24Hour) {
	                html += '<select class="ampmselect">';

	                var am_html = '';
	                var pm_html = '';

	                if (minDate && selected.clone().hour(12).minute(0).second(0).isBefore(minDate))
	                    am_html = ' disabled="disabled" class="disabled"';

	                if (maxDate && selected.clone().hour(0).minute(0).second(0).isAfter(maxDate))
	                    pm_html = ' disabled="disabled" class="disabled"';

	                if (selected.hour() >= 12) {
	                    html += '<option value="AM"' + am_html + '>AM</option><option value="PM" selected="selected"' + pm_html + '>PM</option>';
	                } else {
	                    html += '<option value="AM" selected="selected"' + am_html + '>AM</option><option value="PM"' + pm_html + '>PM</option>';
	                }

	                html += '</select>';
	            }

	            this.container.find('.drp-calendar.' + side + ' .calendar-time').html(html);

	        },

	        updateFormInputs: function() {

	            if (this.singleDatePicker || (this.endDate && (this.startDate.isBefore(this.endDate) || this.startDate.isSame(this.endDate)))) {
	                this.container.find('button.applyBtn').prop('disabled', false);
	            } else {
	                this.container.find('button.applyBtn').prop('disabled', true);
	            }

	        },

	        move: function() {
	            var parentOffset = { top: 0, left: 0 },
	                containerTop,
	                drops = this.drops;

	            var parentRightEdge = $(window).width();
	            if (!this.parentEl.is('body')) {
	                parentOffset = {
	                    top: this.parentEl.offset().top - this.parentEl.scrollTop(),
	                    left: this.parentEl.offset().left - this.parentEl.scrollLeft()
	                };
	                parentRightEdge = this.parentEl[0].clientWidth + this.parentEl.offset().left;
	            }

	            switch (drops) {
	            case 'auto':
	                containerTop = this.element.offset().top + this.element.outerHeight() - parentOffset.top;
	                if (containerTop + this.container.outerHeight() >= this.parentEl[0].scrollHeight) {
	                    containerTop = this.element.offset().top - this.container.outerHeight() - parentOffset.top;
	                    drops = 'up';
	                }
	                break;
	            case 'up':
	                containerTop = this.element.offset().top - this.container.outerHeight() - parentOffset.top;
	                break;
	            default:
	                containerTop = this.element.offset().top + this.element.outerHeight() - parentOffset.top;
	                break;
	            }

	            // Force the container to it's actual width
	            this.container.css({
	              top: 0,
	              left: 0,
	              right: 'auto'
	            });
	            var containerWidth = this.container.outerWidth();

	            this.container.toggleClass('drop-up', drops == 'up');

	            if (this.opens == 'left') {
	                var containerRight = parentRightEdge - this.element.offset().left - this.element.outerWidth();
	                if (containerWidth + containerRight > $(window).width()) {
	                    this.container.css({
	                        top: containerTop,
	                        right: 'auto',
	                        left: 9
	                    });
	                } else {
	                    this.container.css({
	                        top: containerTop,
	                        right: containerRight,
	                        left: 'auto'
	                    });
	                }
	            } else if (this.opens == 'center') {
	                var containerLeft = this.element.offset().left - parentOffset.left + this.element.outerWidth() / 2
	                                        - containerWidth / 2;
	                if (containerLeft < 0) {
	                    this.container.css({
	                        top: containerTop,
	                        right: 'auto',
	                        left: 9
	                    });
	                } else if (containerLeft + containerWidth > $(window).width()) {
	                    this.container.css({
	                        top: containerTop,
	                        left: 'auto',
	                        right: 0
	                    });
	                } else {
	                    this.container.css({
	                        top: containerTop,
	                        left: containerLeft,
	                        right: 'auto'
	                    });
	                }
	            } else {
	                var containerLeft = this.element.offset().left - parentOffset.left;
	                if (containerLeft + containerWidth > $(window).width()) {
	                    this.container.css({
	                        top: containerTop,
	                        left: 'auto',
	                        right: 0
	                    });
	                } else {
	                    this.container.css({
	                        top: containerTop,
	                        left: containerLeft,
	                        right: 'auto'
	                    });
	                }
	            }
	        },

	        show: function(e) {
	            if (this.isShowing) return;

	            // Create a click proxy that is private to this instance of datepicker, for unbinding
	            this._outsideClickProxy = $.proxy(function(e) { this.outsideClick(e); }, this);

	            // Bind global datepicker mousedown for hiding and
	            $(document)
	              .on('mousedown.daterangepicker', this._outsideClickProxy)
	              // also support mobile devices
	              .on('touchend.daterangepicker', this._outsideClickProxy)
	              // also explicitly play nice with Bootstrap dropdowns, which stopPropagation when clicking them
	              .on('click.daterangepicker', '[data-toggle=dropdown]', this._outsideClickProxy)
	              // and also close when focus changes to outside the picker (eg. tabbing between controls)
	              .on('focusin.daterangepicker', this._outsideClickProxy);

	            // Reposition the picker if the window is resized while it's open
	            $(window).on('resize.daterangepicker', $.proxy(function(e) { this.move(e); }, this));

	            this.oldStartDate = this.startDate.clone();
	            this.oldEndDate = this.endDate.clone();
	            this.previousRightTime = this.endDate.clone();

	            this.updateView();
	            this.container.show();
	            this.move();
	            this.element.trigger('show.daterangepicker', this);
	            this.isShowing = true;
	        },

	        hide: function(e) {
	            if (!this.isShowing) return;

	            //incomplete date selection, revert to last values
	            if (!this.endDate) {
	                this.startDate = this.oldStartDate.clone();
	                this.endDate = this.oldEndDate.clone();
	            }

	            //if a new date range was selected, invoke the user callback function
	            if (!this.startDate.isSame(this.oldStartDate) || !this.endDate.isSame(this.oldEndDate))
	                this.callback(this.startDate.clone(), this.endDate.clone(), this.chosenLabel);

	            //if picker is attached to a text input, update it
	            this.updateElement();

	            $(document).off('.daterangepicker');
	            $(window).off('.daterangepicker');
	            this.container.hide();
	            this.element.trigger('hide.daterangepicker', this);
	            this.isShowing = false;
	        },

	        toggle: function(e) {
	            if (this.isShowing) {
	                this.hide();
	            } else {
	                this.show();
	            }
	        },

	        outsideClick: function(e) {
	            var target = $(e.target);
	            // if the page is clicked anywhere except within the daterangerpicker/button
	            // itself then call this.hide()
	            if (
	                // ie modal dialog fix
	                e.type == "focusin" ||
	                target.closest(this.element).length ||
	                target.closest(this.container).length ||
	                target.closest('.calendar-table').length
	                ) return;
	            this.hide();
	            this.element.trigger('outsideClick.daterangepicker', this);
	        },

	        showCalendars: function() {
	            this.container.addClass('show-calendar');
	            this.move();
	            this.element.trigger('showCalendar.daterangepicker', this);
	        },

	        hideCalendars: function() {
	            this.container.removeClass('show-calendar');
	            this.element.trigger('hideCalendar.daterangepicker', this);
	        },

	        clickRange: function(e) {
	            var label = e.target.getAttribute('data-range-key');
	            this.chosenLabel = label;
	            if (label == this.locale.customRangeLabel) {
	                this.showCalendars();
	            } else {
	                var dates = this.ranges[label];
	                this.startDate = dates[0];
	                this.endDate = dates[1];

	                if (!this.timePicker) {
	                    this.startDate.startOf('day');
	                    this.endDate.endOf('day');
	                }

	                if (!this.alwaysShowCalendars)
	                    this.hideCalendars();
	                this.clickApply();
	            }
	        },

	        clickPrev: function(e) {
	            var cal = $(e.target).parents('.drp-calendar');
	            if (cal.hasClass('left')) {
	                this.leftCalendar.month.subtract(1, 'month');
	                if (this.linkedCalendars)
	                    this.rightCalendar.month.subtract(1, 'month');
	            } else {
	                this.rightCalendar.month.subtract(1, 'month');
	            }
	            this.updateCalendars();
	        },

	        clickNext: function(e) {
	            var cal = $(e.target).parents('.drp-calendar');
	            if (cal.hasClass('left')) {
	                this.leftCalendar.month.add(1, 'month');
	            } else {
	                this.rightCalendar.month.add(1, 'month');
	                if (this.linkedCalendars)
	                    this.leftCalendar.month.add(1, 'month');
	            }
	            this.updateCalendars();
	        },

	        hoverDate: function(e) {

	            //ignore dates that can't be selected
	            if (!$(e.target).hasClass('available')) return;

	            var title = $(e.target).attr('data-title');
	            var row = title.substr(1, 1);
	            var col = title.substr(3, 1);
	            var cal = $(e.target).parents('.drp-calendar');
	            var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

	            //highlight the dates between the start date and the date being hovered as a potential end date
	            var leftCalendar = this.leftCalendar;
	            var rightCalendar = this.rightCalendar;
	            var startDate = this.startDate;
	            if (!this.endDate) {
	                this.container.find('.drp-calendar tbody td').each(function(index, el) {

	                    //skip week numbers, only look at dates
	                    if ($(el).hasClass('week')) return;

	                    var title = $(el).attr('data-title');
	                    var row = title.substr(1, 1);
	                    var col = title.substr(3, 1);
	                    var cal = $(el).parents('.drp-calendar');
	                    var dt = cal.hasClass('left') ? leftCalendar.calendar[row][col] : rightCalendar.calendar[row][col];

	                    if ((dt.isAfter(startDate) && dt.isBefore(date)) || dt.isSame(date, 'day')) {
	                        $(el).addClass('in-range');
	                    } else {
	                        $(el).removeClass('in-range');
	                    }

	                });
	            }

	        },

	        clickDate: function(e) {

	            if (!$(e.target).hasClass('available')) return;

	            var title = $(e.target).attr('data-title');
	            var row = title.substr(1, 1);
	            var col = title.substr(3, 1);
	            var cal = $(e.target).parents('.drp-calendar');
	            var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];

	            //
	            // this function needs to do a few things:
	            // * alternate between selecting a start and end date for the range,
	            // * if the time picker is enabled, apply the hour/minute/second from the select boxes to the clicked date
	            // * if autoapply is enabled, and an end date was chosen, apply the selection
	            // * if single date picker mode, and time picker isn't enabled, apply the selection immediately
	            // * if one of the inputs above the calendars was focused, cancel that manual input
	            //

	            if (this.endDate || date.isBefore(this.startDate, 'day')) { //picking start
	                if (this.timePicker) {
	                    var hour = parseInt(this.container.find('.left .hourselect').val(), 10);
	                    if (!this.timePicker24Hour) {
	                        var ampm = this.container.find('.left .ampmselect').val();
	                        if (ampm === 'PM' && hour < 12)
	                            hour += 12;
	                        if (ampm === 'AM' && hour === 12)
	                            hour = 0;
	                    }
	                    var minute = parseInt(this.container.find('.left .minuteselect').val(), 10);
	                    if (isNaN(minute)) {
	                        minute = parseInt(this.container.find('.left .minuteselect option:last').val(), 10);
	                    }
	                    var second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;
	                    date = date.clone().hour(hour).minute(minute).second(second);
	                }
	                this.endDate = null;
	                this.setStartDate(date.clone());
	            } else if (!this.endDate && date.isBefore(this.startDate)) {
	                //special case: clicking the same date for start/end,
	                //but the time of the end date is before the start date
	                this.setEndDate(this.startDate.clone());
	            } else { // picking end
	                if (this.timePicker) {
	                    var hour = parseInt(this.container.find('.right .hourselect').val(), 10);
	                    if (!this.timePicker24Hour) {
	                        var ampm = this.container.find('.right .ampmselect').val();
	                        if (ampm === 'PM' && hour < 12)
	                            hour += 12;
	                        if (ampm === 'AM' && hour === 12)
	                            hour = 0;
	                    }
	                    var minute = parseInt(this.container.find('.right .minuteselect').val(), 10);
	                    if (isNaN(minute)) {
	                        minute = parseInt(this.container.find('.right .minuteselect option:last').val(), 10);
	                    }
	                    var second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;
	                    date = date.clone().hour(hour).minute(minute).second(second);
	                }
	                this.setEndDate(date.clone());
	                if (this.autoApply) {
	                  this.calculateChosenLabel();
	                  this.clickApply();
	                }
	            }

	            if (this.singleDatePicker) {
	                this.setEndDate(this.startDate);
	                if (!this.timePicker && this.autoApply)
	                    this.clickApply();
	            }

	            this.updateView();

	            //This is to cancel the blur event handler if the mouse was in one of the inputs
	            e.stopPropagation();

	        },

	        calculateChosenLabel: function () {
	            var customRange = true;
	            var i = 0;
	            for (var range in this.ranges) {
	              if (this.timePicker) {
	                    var format = this.timePickerSeconds ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD HH:mm";
	                    //ignore times when comparing dates if time picker seconds is not enabled
	                    if (this.startDate.format(format) == this.ranges[range][0].format(format) && this.endDate.format(format) == this.ranges[range][1].format(format)) {
	                        customRange = false;
	                        this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').attr('data-range-key');
	                        break;
	                    }
	                } else {
	                    //ignore times when comparing dates if time picker is not enabled
	                    if (this.startDate.format('YYYY-MM-DD') == this.ranges[range][0].format('YYYY-MM-DD') && this.endDate.format('YYYY-MM-DD') == this.ranges[range][1].format('YYYY-MM-DD')) {
	                        customRange = false;
	                        this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').attr('data-range-key');
	                        break;
	                    }
	                }
	                i++;
	            }
	            if (customRange) {
	                if (this.showCustomRangeLabel) {
	                    this.chosenLabel = this.container.find('.ranges li:last').addClass('active').attr('data-range-key');
	                } else {
	                    this.chosenLabel = null;
	                }
	                this.showCalendars();
	            }
	        },

	        clickApply: function(e) {
	            this.hide();
	            this.element.trigger('apply.daterangepicker', this);
	        },

	        clickCancel: function(e) {
	            this.startDate = this.oldStartDate;
	            this.endDate = this.oldEndDate;
	            this.hide();
	            this.element.trigger('cancel.daterangepicker', this);
	        },

	        monthOrYearChanged: function(e) {
	            var isLeft = $(e.target).closest('.drp-calendar').hasClass('left'),
	                leftOrRight = isLeft ? 'left' : 'right',
	                cal = this.container.find('.drp-calendar.'+leftOrRight);

	            // Month must be Number for new moment versions
	            var month = parseInt(cal.find('.monthselect').val(), 10);
	            var year = cal.find('.yearselect').val();

	            if (!isLeft) {
	                if (year < this.startDate.year() || (year == this.startDate.year() && month < this.startDate.month())) {
	                    month = this.startDate.month();
	                    year = this.startDate.year();
	                }
	            }

	            if (this.minDate) {
	                if (year < this.minDate.year() || (year == this.minDate.year() && month < this.minDate.month())) {
	                    month = this.minDate.month();
	                    year = this.minDate.year();
	                }
	            }

	            if (this.maxDate) {
	                if (year > this.maxDate.year() || (year == this.maxDate.year() && month > this.maxDate.month())) {
	                    month = this.maxDate.month();
	                    year = this.maxDate.year();
	                }
	            }

	            if (isLeft) {
	                this.leftCalendar.month.month(month).year(year);
	                if (this.linkedCalendars)
	                    this.rightCalendar.month = this.leftCalendar.month.clone().add(1, 'month');
	            } else {
	                this.rightCalendar.month.month(month).year(year);
	                if (this.linkedCalendars)
	                    this.leftCalendar.month = this.rightCalendar.month.clone().subtract(1, 'month');
	            }
	            this.updateCalendars();
	        },

	        timeChanged: function(e) {

	            var cal = $(e.target).closest('.drp-calendar'),
	                isLeft = cal.hasClass('left');

	            var hour = parseInt(cal.find('.hourselect').val(), 10);
	            var minute = parseInt(cal.find('.minuteselect').val(), 10);
	            if (isNaN(minute)) {
	                minute = parseInt(cal.find('.minuteselect option:last').val(), 10);
	            }
	            var second = this.timePickerSeconds ? parseInt(cal.find('.secondselect').val(), 10) : 0;

	            if (!this.timePicker24Hour) {
	                var ampm = cal.find('.ampmselect').val();
	                if (ampm === 'PM' && hour < 12)
	                    hour += 12;
	                if (ampm === 'AM' && hour === 12)
	                    hour = 0;
	            }

	            if (isLeft) {
	                var start = this.startDate.clone();
	                start.hour(hour);
	                start.minute(minute);
	                start.second(second);
	                this.setStartDate(start);
	                if (this.singleDatePicker) {
	                    this.endDate = this.startDate.clone();
	                } else if (this.endDate && this.endDate.format('YYYY-MM-DD') == start.format('YYYY-MM-DD') && this.endDate.isBefore(start)) {
	                    this.setEndDate(start.clone());
	                }
	            } else if (this.endDate) {
	                var end = this.endDate.clone();
	                end.hour(hour);
	                end.minute(minute);
	                end.second(second);
	                this.setEndDate(end);
	            }

	            //update the calendars so all clickable dates reflect the new time component
	            this.updateCalendars();

	            //update the form inputs above the calendars with the new time
	            this.updateFormInputs();

	            //re-render the time pickers because changing one selection can affect what's enabled in another
	            this.renderTimePicker('left');
	            this.renderTimePicker('right');

	        },

	        elementChanged: function() {
	            if (!this.element.is('input')) return;
	            if (!this.element.val().length) return;

	            var dateString = this.element.val().split(this.locale.separator),
	                start = null,
	                end = null;

	            if (dateString.length === 2) {
	                start = moment(dateString[0], this.locale.format);
	                end = moment(dateString[1], this.locale.format);
	            }

	            if (this.singleDatePicker || start === null || end === null) {
	                start = moment(this.element.val(), this.locale.format);
	                end = start;
	            }

	            if (!start.isValid() || !end.isValid()) return;

	            this.setStartDate(start);
	            this.setEndDate(end);
	            this.updateView();
	        },

	        keydown: function(e) {
	            //hide on tab or enter
	            if ((e.keyCode === 9) || (e.keyCode === 13)) {
	                this.hide();
	            }

	            //hide on esc and prevent propagation
	            if (e.keyCode === 27) {
	                e.preventDefault();
	                e.stopPropagation();

	                this.hide();
	            }
	        },

	        updateElement: function() {
	            if (this.element.is('input') && this.autoUpdateInput) {
	                var newValue = this.startDate.format(this.locale.format);
	                if (!this.singleDatePicker) {
	                    newValue += this.locale.separator + this.endDate.format(this.locale.format);
	                }
	                if (newValue !== this.element.val()) {
	                    this.element.val(newValue).trigger('change');
	                }
	            }
	        },

	        remove: function() {
	            this.container.remove();
	            this.element.off('.daterangepicker');
	            this.element.removeData();
	        }

	    };

	    $.fn.daterangepicker = function(options, callback) {
	        var implementOptions = $.extend(true, {}, $.fn.daterangepicker.defaultOptions, options);
	        this.each(function() {
	            var el = $(this);
	            if (el.data('daterangepicker'))
	                el.data('daterangepicker').remove();
	            el.data('daterangepicker', new DateRangePicker(el, implementOptions, callback));
	        });
	        return this;
	    };

	    return DateRangePicker;

	}));
	});

	class Utils {
	  /**
	   * Gets the preset date ranges.
	   *
	   * @returns {{[p: number]: [Date,Date]}}
	   */
	  static getDateRanges() {
	    const today = new Date();
	    today.setHours(0, 0, 0, 0);
	    const last7Days = new Date(today);
	    last7Days.setDate(today.getDate() - 6);
	    const thisWeekStart = new Date(today);
	    thisWeekStart.setDate(today.getDate() - today.getDay());
	    const thisWeekEnd = new Date(thisWeekStart);
	    thisWeekEnd.setDate(thisWeekStart.getDate() + 6);
	    const last30Days = new Date(today);
	    last30Days.setDate(today.getDate() - 29);
	    const thisMonthStart = new Date(today.getFullYear(), today.getMonth(), 1);
	    const thisMonthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 0);
	    return {
	      [_SEARCHWP_METRICS_VARS.i18n.last_7_days]: [last7Days, today],
	      [_SEARCHWP_METRICS_VARS.i18n.last_30_days]: [last30Days, today],
	      [_SEARCHWP_METRICS_VARS.i18n.this_week]: [thisWeekStart, thisWeekEnd],
	      [_SEARCHWP_METRICS_VARS.i18n.this_month]: [thisMonthStart, thisMonthEnd]
	    };
	  }

	  /**
	   * Gets the Max Date for the date range control.
	   *
	   * @returns {Date}
	   */
	  static getDateRangesMaxDate() {
	    // Return the date of the end of next month.
	    const today = new Date();
	    const nextMonth = new Date(today.getFullYear(), today.getMonth() + 2, 0);
	    return nextMonth;
	  }

	  /**
	   * Gets the Min Date for the date range control.
	   *
	   * @returns {Date}
	   */
	  static getDateRangesMinDate() {
	    return new Date(_SEARCHWP_METRICS_VARS.options.min_year, 0, 1);
	  }

	  /**
	   * Gets the list of engines.
	   *
	   * @returns {*[]}
	   */
	  static getEngines() {
	    let {
	      engines,
	      engine_default
	    } = _SEARCHWP_METRICS_VARS;
	    const defaultEnginesNames = engine_default.map(engine => engine.name);
	    let enginesList = engines.map((engine, index) => ({
	      value: engine.name,
	      label: engine.label,
	      selected: defaultEnginesNames.includes(engine.name),
	      color: Utils.getColor(index)
	    }));
	    return enginesList;
	  }

	  /**
	   * Get the interval options for clearing metrics data.
	   *
	   * @since 1.4.5
	   *
	   * @returns {[{label: *, value: number, selected: boolean},{label: *, value: number, selected: boolean},{label: *, value: number, selected: boolean},{label: *, value: number, selected: boolean},{label: *, value: number, selected: boolean},null]}
	   */
	  static getClearMetricsDataIntervals() {
	    let selected = Utils.getSetting('clear_data_interval');
	    return [{
	      value: 0,
	      label: Utils.getI18nString('clear_metrics_interval_0'),
	      selected: 0 === selected.value
	    }, {
	      value: 30,
	      label: Utils.getI18nString('clear_metrics_interval_30'),
	      selected: 30 === selected.value
	    }, {
	      value: 90,
	      label: Utils.getI18nString('clear_metrics_interval_90'),
	      selected: 90 === selected.value
	    }, {
	      value: 180,
	      label: Utils.getI18nString('clear_metrics_interval_180'),
	      selected: 180 === selected.value
	    }, {
	      value: 365,
	      label: Utils.getI18nString('clear_metrics_interval_365'),
	      selected: 365 === selected.value
	    }, {
	      value: 'custom',
	      label: Utils.getI18nString('clear_metrics_interval_custom'),
	      selected: 'custom' === selected.value
	    }];
	  }

	  /**
	   * Get a setting from the global settings object.
	   *
	   * @since 1.4.5
	   *
	   * @param key
	   *
	   * @returns {*}
	   */
	  static getSetting(key) {
	    return _SEARCHWP_METRICS_VARS.settings[key];
	  }

	  /**
	   * Trigger a toggle menu item event.
	   *
	   * @since 1.4.5
	   *
	   * @param menuItem
	   * @param show
	   */
	  static triggerToggleMenuItem(menuItem) {
	    let show = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	    jQuery(document).trigger('searchwp-metrics__toggle-menu-item', {
	      id: menuItem,
	      show: show
	    });
	  }

	  /**
	   * Make a request to the API.
	   *
	   * @since 1.4.5
	   *
	   * @param data
	   *
	   * @returns {Promise<unknown>}
	   */
	  static apiRequest() {
	    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    data._ajax_nonce = _SEARCHWP_METRICS_VARS.nonce;
	    return new Promise(function (resolve, reject) {
	      jQuery.post(ajaxurl, data, function (response) {
	        if (response.success) {
	          resolve(response);
	        } else {
	          reject(response);
	        }
	      });
	    });
	  }

	  /**
	   * Gets the total count of a metric data entries.
	   *
	   * @since 1.4.5
	   *
	   * @param data
	   * @param metric
	   *
	   * @returns {*[]}
	   */
	  static getMetricCount(data, metric) {
	    let count = [];
	    data.forEach((engineData, index) => {
	      count.push({
	        [metric]: engineData.dataset.reduce((a, b) => a + b, 0)
	      });
	    });
	    return count;
	  }

	  /**
	   * Gets the formatted metric data.
	   *
	   * @param data
	   * @param metric
	   *
	   * @returns {*[]}
	   */
	  static getMetricStatistic(data, metric) {
	    let statistics = [];
	    data = Object.keys(data).map(key => data[key]);
	    data.forEach((engineData, index) => {
	      let statistic = '0' === engineData.statistic.toString() || '0.00' === engineData.statistic.toString() ? '--' : engineData.statistic;
	      statistics.push({
	        [metric]: statistic
	      });
	    });
	    return statistics;
	  }

	  /**
	   * Gets the formatted metric data for Searches Over Time.
	   *
	   * @since 1.4.5
	   *
	   * @param data
	   * @param metric
	   *
	   * @returns {*[]}
	   */
	  static getSearchesOverTimeMetric(data, metric) {
	    let searchesOverTime = [];
	    let labels = data.labels;
	    data.datasets.forEach(data => {
	      let searchesData = [];
	      data.dataset.forEach((count, index) => {
	        searchesData.push({
	          label: labels[index],
	          searches: count
	        });
	      });
	      searchesOverTime.push({
	        [metric]: searchesData
	      });
	    });
	    return searchesOverTime;
	  }

	  /**
	   * Gets the formatted metric data for Failed Searches.
	   *
	   * @since 1.4.5
	   *
	   * @param data
	   * @param metric
	   *
	   * @returns {*[]}
	   */
	  static getFailedSearchesList(data, metric) {
	    let failedSearches = [];
	    data.forEach((engineData, index) => {
	      let failedSearchesOverTime = [];
	      engineData.labels.forEach((label, index) => {
	        failedSearchesOverTime.push({
	          query: label,
	          count: engineData.dataset[index]
	        });
	      });
	      failedSearches.push({
	        [metric]: failedSearchesOverTime
	      });
	    });
	    return failedSearches;
	  }

	  /**
	   * Gets the formatted metric data for Popular Searches over Time.
	   *
	   * @since 1.4.5
	   *
	   * @param data
	   * @param metric
	   *
	   * @returns {*[]}
	   */
	  static getPopularSearchesOverTime(data, metric) {
	    let popularSearches = [];
	    data.forEach((engineData, index) => {
	      let popularSearchesOverTime = [];
	      engineData.labels.forEach((label, index) => {
	        popularSearchesOverTime.push({
	          query: label,
	          count: engineData.dataset[index],
	          color: Utils.getColor(index)
	        });
	      });
	      popularSearches.push({
	        [metric]: popularSearchesOverTime
	      });
	    });
	    return popularSearches;
	  }

	  /**
	   * Gets the formatted metric data for Insights.
	   *
	   * @since 1.4.5
	   *
	   * @param data
	   * @param metric
	   * @param limit
	   *
	   * @returns {*[]}
	   */
	  static getInsights(data, metric) {
	    let limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
	    let popularClicksOverTime = [];
	    data.forEach((engineData, index) => {
	      if (!engineData || !engineData.insights) {
	        popularClicksOverTime.push({
	          [metric]: []
	        });
	        return;
	      }
	      let insights = [];
	      let popular = engineData.insights.popular;
	      let underdogs = engineData.insights.underdogs;
	      let analysis = engineData.insights.analysis;
	      if (underdogs && underdogs.length) {
	        insights.push({
	          type: 'underdog',
	          postCount: underdogs.length,
	          posts: underdogs
	        });
	      }
	      if (popular && popular.length) {
	        insights.push({
	          type: 'popular',
	          postCount: popular.length,
	          posts: popular
	        });
	      }
	      for (let insight in analysis) {
	        if (analysis.hasOwnProperty(insight)) {
	          insights.push({
	            type: 'analysis',
	            query: analysis[insight].query,
	            clickCount: analysis[insight].clicks,
	            postCount: analysis[insight].posts.length,
	            posts: analysis[insight].posts
	          });
	        }

	        // We only want a maximum of 3 entries in Insights just so the UI is balanced.
	        if (limit > 0 && insights.length > limit - 1) {
	          break;
	        }
	      }
	      popularClicksOverTime.push({
	        [metric]: insights
	      });
	    });
	    return popularClicksOverTime;
	  }

	  /**
	   * Returns a translated string.
	   *
	   * @since 1.4.5
	   *
	   * @param key
	   * @param replacements
	   *
	   * @returns {*}
	   */
	  static getI18nString(key) {
	    let replacements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	    let string = _SEARCHWP_METRICS_VARS.i18n[key];

	    // If there are replacements, replace them.
	    if (replacements.length) {
	      replacements.forEach((replacement, index) => {
	        string = string.replace('{{ ' + replacement.placeholder + ' }}', replacement.value);
	      });
	    }
	    return string;
	  }

	  /**
	   * Downloads a CSV file.
	   *
	   * @since 1.4.5
	   *
	   * @param data
	   * @param filename
	   * @param headers
	   * @param engineName
	   */
	  static downloadCSV(data) {
	    let filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'searchwp-metrics';
	    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    let engineName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
	    // Get the date range from the date range picker.
	    const dateRange = searchwp_metrics.dateRangePicker.getDateRange();

	    // Get current date formatted as 2024-08-21.
	    new Date().toISOString().split('T')[0];

	    // Convert json data to CSV string.
	    const csv = Utils.jsonToCSV(data, headers);

	    // Create a blob object.
	    const blob = new Blob([csv], {
	      type: 'text/csv'
	    });

	    // Create a URL from the blob.
	    const url = window.URL.createObjectURL(blob);

	    // Create a link element.
	    const a = document.createElement('a');

	    // Set the link element's href attribute to the URL.
	    a.href = url;

	    // Set the link element's download attribute to the filename.
	    a.download = filename + '_' + engineName + '_' + dateRange.startDate + '_' + dateRange.endDate + '.csv';

	    // Append the link element to the body.
	    document.body.appendChild(a);

	    // Click the link element.
	    a.click();

	    // Remove the link element from the body.
	    a.remove();
	  }

	  /**
	   * Converts JSON data to a CSV string.
	   *
	   * @param jsonData
	   * @param headers
	   *
	   * @returns {string}
	   */
	  static jsonToCSV(jsonData) {
	    let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	    // Extract the field names from the headers object.
	    const csvFields = Object.keys(headers);
	    // Extract header labels from the headers object.
	    const csvHeaders = Object.values(headers);

	    // Initialize the CSV array with the header row.
	    const csvArray = [];
	    csvArray.push(csvHeaders.join(','));

	    // Loop through the JSON data and create a row for each entry.
	    jsonData.forEach(item => {
	      // Map each field from the JSON item to the corresponding CSV field.
	      const row = csvFields.map(
	      // phpcs:ignore
	      field => {
	        let cell = item[field] !== undefined && item[field] !== null ? item[field] : '';

	        // Escape double quotes within the data.
	        if (typeof cell === 'string') {
	          cell = cell.replace(/"/g, '""'); // Escape double quotes.
	        }

	        // Wrap every cell in double quotes and prepend an equal sign.
	        // phpcs:disable
	        return `="${cell}"`;
	        // phpcs:enable
	      });

	      // Join the row elements with commas and push to the CSV array.
	      csvArray.push(row.join(','));
	    });

	    // Return the CSV as a single string.
	    return csvArray.join('\n');
	  }

	  /**
	   * Gets the chart options for the Bar chart.
	   *
	   * @since 1.4.5
	   *
	   * @returns {{hover: {mode: null}, indexAxis: string, plugins: {legend: {display: boolean}, tooltip: {enabled: boolean}}, responsive: boolean, scales: {x: {stacked: boolean, max: number, ticks: {beginAtZero: boolean}, display: boolean}, y: {stacked: boolean, display: boolean}}, maintainAspectRatio: boolean}}
	   */
	  static getBarChartOptions() {
	    return {
	      responsive: true,
	      maintainAspectRatio: false,
	      indexAxis: 'y',
	      scales: {
	        x: {
	          stacked: true,
	          display: false,
	          max: 100,
	          ticks: {
	            beginAtZero: true
	          }
	        },
	        y: {
	          stacked: true,
	          display: false
	        }
	      },
	      plugins: {
	        legend: {
	          display: false
	        },
	        tooltip: {
	          enabled: false
	        }
	      },
	      hover: {
	        mode: null
	      }
	    };
	  }

	  /**
	   * Gets a color from the color scheme.
	   *
	   * @param i
	   * @param opacity
	   * @param adjustment
	   *
	   * @returns {string}
	   */
	  static getColor(i) {
	    let opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	    let adjustment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	    const colorScheme = ['rgba(69,170,242,1)', 'rgba(252,92,101,1)', 'rgba(165,94,234,1)', 'rgba(38,222,129,1)', 'rgba(253,150,68,1)', 'rgba(254,211,48,1)', 'rgba(43,203,186,1)', 'rgba(75,123,236,1)', 'rgba(209,216,224,1)', 'rgba(119,140,163,1)', 'rgba(45,152,218,1)', 'rgba(235,59,90,1)', 'rgba(136,84,208,1)', 'rgba(250,130,49,1)', 'rgba(32,191,107,1)', 'rgba(247,183,49,1)', 'rgba(15,185,177,1)', 'rgba(56,103,214,1)', 'rgba(165,177,194,1)', 'rgba(75,101,132,1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 99, 132, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)', 'rgba(75, 192, 192, 1)', 'rgba(201, 203, 207, 1)'];
	    let colorSchemeLength = colorScheme.length;
	    while (i > colorSchemeLength - 1) {
	      i -= colorScheme.length;
	    }
	    let color = colorScheme[i].replace('1)', opacity + ')');
	    let pieces = color.split(',');

	    // Apply adjustment.
	    let r = parseInt(pieces[0].replace('rgba(', ''), 10) * adjustment;
	    let g = parseInt(pieces[1]) * adjustment;
	    let b = parseInt(pieces[2]) * adjustment;

	    // When adjusting, desaturate as well.
	    if (adjustment !== 1) {
	      let f = 0.5; // desaturate by 20%.
	      let L = 0.3 * r + 0.6 * g + 0.1 * b;
	      let new_r = r + f * (L - r);
	      let new_g = g + f * (L - g);
	      let new_b = b + f * (L - b);
	      r = new_r;
	      g = new_g;
	      b = new_b;
	    }
	    color = 'rgba(' + r + ',' + g + ',' + b + ',' + pieces[3];
	    return color;
	  }
	}

	/**
	 * This class handles the Date Range Picker control.
	 *
	 * @since 1.4.5
	 */
	class DaterangePickerControl {
	  constructor($controls) {
	    this.startDate = null;
	    this.endDate = null;
	    this.$controls = $controls;
	    this.$control = this.initializeControl();
	    this.InitializeEvents();
	    return this;
	  }

	  /**
	   * Initialize the Date Range Picker control.
	   *
	   * @since 1.4.5
	   */
	  initializeControl() {
	    const {
	      options: {
	        default_start,
	        default_end
	      }
	    } = _SEARCHWP_METRICS_VARS;
	    const locale = {
	      format: 'YYYY-MM-DD',
	      separator: ` ${Utils.getI18nString('to')} `,
	      applyLabel: Utils.getI18nString('update'),
	      cancelLabel: Utils.getI18nString('close')
	    };
	    const config = {
	      parentEl: '.searchwp-metrics',
	      opens: 'right',
	      showDropdowns: true,
	      linkedCalendars: false,
	      showCustomRangeLabel: true,
	      alwaysShowCalendars: true,
	      autoApply: false,
	      locale,
	      ranges: Utils.getDateRanges(),
	      startDate: default_start,
	      endDate: default_end,
	      minDate: Utils.getDateRangesMinDate(),
	      maxDate: Utils.getDateRangesMaxDate()
	    };

	    // HTML structure for the date range picker control.
	    // phpcs:disable
	    const controlHTML = `
			<div class="searchwp-metrics__control">
				<h4>${Utils.getI18nString('date_range')}</h4>
				<div class="searchwp-metrics__daterange-picker searchwp-metrics__disable-on-loading">
					<input type="text" name="daterange">
				</div>
			</div>
		`;
	    // phpcs:enable

	    // Append the control HTML to the parent element.
	    if (this.$controls) {
	      this.$controls.append(controlHTML);
	    }
	    const $control = this.$controls.find('.searchwp-metrics__daterange-picker input[name="daterange"]');
	    $control.daterangepicker(config);

	    // Set the initial date range.
	    this.startDate = $control.data('daterangepicker').startDate.format('YYYY-MM-DD');
	    this.endDate = $control.data('daterangepicker').endDate.format('YYYY-MM-DD');
	    return $control;
	  }

	  /**
	   * Initialize the events for the Date Range Picker control.
	   *
	   * @since 1.4.5
	   */
	  InitializeEvents() {
	    let self = this;
	    this.$control.on('apply.daterangepicker', function (event, picker) {
	      // Update the date range.
	      self.startDate = picker.startDate.format('YYYY-MM-DD');
	      self.endDate = picker.endDate.format('YYYY-MM-DD');
	      jQuery(document).trigger('searchwp-metrics__needs-update');
	    });
	  }

	  /**
	   * Get the date range.
	   *
	   * @since 1.4.5
	   */
	  getDateRange() {
	    return {
	      startDate: this.startDate,
	      endDate: this.endDate
	    };
	  }
	}

	var choices = createCommonjsModule(function (module, exports) {
	/*! choices.js v10.2.0 |  2022 Josh Johnson | https://github.com/jshjohnson/Choices#readme */
	(function webpackUniversalModuleDefinition(root, factory) {
		module.exports = factory();
	})(window, function() {
	return /******/ (function() { // webpackBootstrap
	/******/ 	var __webpack_modules__ = ({

	/***/ 282:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.clearChoices = exports.activateChoices = exports.filterChoices = exports.addChoice = void 0;
	var constants_1 = __webpack_require__(883);
	var addChoice = function (_a) {
	  var value = _a.value,
	    label = _a.label,
	    id = _a.id,
	    groupId = _a.groupId,
	    disabled = _a.disabled,
	    elementId = _a.elementId,
	    customProperties = _a.customProperties,
	    placeholder = _a.placeholder,
	    keyCode = _a.keyCode;
	  return {
	    type: constants_1.ACTION_TYPES.ADD_CHOICE,
	    value: value,
	    label: label,
	    id: id,
	    groupId: groupId,
	    disabled: disabled,
	    elementId: elementId,
	    customProperties: customProperties,
	    placeholder: placeholder,
	    keyCode: keyCode
	  };
	};
	exports.addChoice = addChoice;
	var filterChoices = function (results) {
	  return {
	    type: constants_1.ACTION_TYPES.FILTER_CHOICES,
	    results: results
	  };
	};
	exports.filterChoices = filterChoices;
	var activateChoices = function (active) {
	  if (active === void 0) {
	    active = true;
	  }
	  return {
	    type: constants_1.ACTION_TYPES.ACTIVATE_CHOICES,
	    active: active
	  };
	};
	exports.activateChoices = activateChoices;
	var clearChoices = function () {
	  return {
	    type: constants_1.ACTION_TYPES.CLEAR_CHOICES
	  };
	};
	exports.clearChoices = clearChoices;

	/***/ }),

	/***/ 783:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.addGroup = void 0;
	var constants_1 = __webpack_require__(883);
	var addGroup = function (_a) {
	  var value = _a.value,
	    id = _a.id,
	    active = _a.active,
	    disabled = _a.disabled;
	  return {
	    type: constants_1.ACTION_TYPES.ADD_GROUP,
	    value: value,
	    id: id,
	    active: active,
	    disabled: disabled
	  };
	};
	exports.addGroup = addGroup;

	/***/ }),

	/***/ 464:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.highlightItem = exports.removeItem = exports.addItem = void 0;
	var constants_1 = __webpack_require__(883);
	var addItem = function (_a) {
	  var value = _a.value,
	    label = _a.label,
	    id = _a.id,
	    choiceId = _a.choiceId,
	    groupId = _a.groupId,
	    customProperties = _a.customProperties,
	    placeholder = _a.placeholder,
	    keyCode = _a.keyCode;
	  return {
	    type: constants_1.ACTION_TYPES.ADD_ITEM,
	    value: value,
	    label: label,
	    id: id,
	    choiceId: choiceId,
	    groupId: groupId,
	    customProperties: customProperties,
	    placeholder: placeholder,
	    keyCode: keyCode
	  };
	};
	exports.addItem = addItem;
	var removeItem = function (id, choiceId) {
	  return {
	    type: constants_1.ACTION_TYPES.REMOVE_ITEM,
	    id: id,
	    choiceId: choiceId
	  };
	};
	exports.removeItem = removeItem;
	var highlightItem = function (id, highlighted) {
	  return {
	    type: constants_1.ACTION_TYPES.HIGHLIGHT_ITEM,
	    id: id,
	    highlighted: highlighted
	  };
	};
	exports.highlightItem = highlightItem;

	/***/ }),

	/***/ 137:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.setIsLoading = exports.resetTo = exports.clearAll = void 0;
	var constants_1 = __webpack_require__(883);
	var clearAll = function () {
	  return {
	    type: constants_1.ACTION_TYPES.CLEAR_ALL
	  };
	};
	exports.clearAll = clearAll;
	var resetTo = function (state) {
	  return {
	    type: constants_1.ACTION_TYPES.RESET_TO,
	    state: state
	  };
	};
	exports.resetTo = resetTo;
	var setIsLoading = function (isLoading) {
	  return {
	    type: constants_1.ACTION_TYPES.SET_IS_LOADING,
	    isLoading: isLoading
	  };
	};
	exports.setIsLoading = setIsLoading;

	/***/ }),

	/***/ 373:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	var __spreadArray = this && this.__spreadArray || function (to, from, pack) {
	  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	    if (ar || !(i in from)) {
	      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	      ar[i] = from[i];
	    }
	  }
	  return to.concat(ar || Array.prototype.slice.call(from));
	};
	var __importDefault = this && this.__importDefault || function (mod) {
	  return mod && mod.__esModule ? mod : {
	    "default": mod
	  };
	};
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	var deepmerge_1 = __importDefault(__webpack_require__(996));
	/* eslint-disable @typescript-eslint/no-explicit-any */
	var fuse_js_1 = __importDefault(__webpack_require__(221));
	var choices_1 = __webpack_require__(282);
	var groups_1 = __webpack_require__(783);
	var items_1 = __webpack_require__(464);
	var misc_1 = __webpack_require__(137);
	var components_1 = __webpack_require__(520);
	var constants_1 = __webpack_require__(883);
	var defaults_1 = __webpack_require__(789);
	var utils_1 = __webpack_require__(799);
	var reducers_1 = __webpack_require__(655);
	var store_1 = __importDefault(__webpack_require__(744));
	var templates_1 = __importDefault(__webpack_require__(686));
	/** @see {@link http://browserhacks.com/#hack-acea075d0ac6954f275a70023906050c} */
	var IS_IE11 = '-ms-scroll-limit' in document.documentElement.style && '-ms-ime-align' in document.documentElement.style;
	var USER_DEFAULTS = {};
	/**
	 * Choices
	 * @author Josh Johnson<josh@joshuajohnson.co.uk>
	 */
	var Choices = /** @class */function () {
	  function Choices(element, userConfig) {
	    if (element === void 0) {
	      element = '[data-choice]';
	    }
	    if (userConfig === void 0) {
	      userConfig = {};
	    }
	    var _this = this;
	    if (userConfig.allowHTML === undefined) {
	      console.warn('Deprecation warning: allowHTML will default to false in a future release. To render HTML in Choices, you will need to set it to true. Setting allowHTML will suppress this message.');
	    }
	    this.config = deepmerge_1.default.all([defaults_1.DEFAULT_CONFIG, Choices.defaults.options, userConfig],
	    // When merging array configs, replace with a copy of the userConfig array,
	    // instead of concatenating with the default array
	    {
	      arrayMerge: function (_, sourceArray) {
	        return __spreadArray([], sourceArray, true);
	      }
	    });
	    var invalidConfigOptions = (0, utils_1.diff)(this.config, defaults_1.DEFAULT_CONFIG);
	    if (invalidConfigOptions.length) {
	      console.warn('Unknown config option(s) passed', invalidConfigOptions.join(', '));
	    }
	    var passedElement = typeof element === 'string' ? document.querySelector(element) : element;
	    if (!(passedElement instanceof HTMLInputElement || passedElement instanceof HTMLSelectElement)) {
	      throw TypeError('Expected one of the following types text|select-one|select-multiple');
	    }
	    this._isTextElement = passedElement.type === constants_1.TEXT_TYPE;
	    this._isSelectOneElement = passedElement.type === constants_1.SELECT_ONE_TYPE;
	    this._isSelectMultipleElement = passedElement.type === constants_1.SELECT_MULTIPLE_TYPE;
	    this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement;
	    this.config.searchEnabled = this._isSelectMultipleElement || this.config.searchEnabled;
	    if (!['auto', 'always'].includes("".concat(this.config.renderSelectedChoices))) {
	      this.config.renderSelectedChoices = 'auto';
	    }
	    if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== 'function') {
	      var re = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);
	      this.config.addItemFilter = re.test.bind(re);
	    }
	    if (this._isTextElement) {
	      this.passedElement = new components_1.WrappedInput({
	        element: passedElement,
	        classNames: this.config.classNames,
	        delimiter: this.config.delimiter
	      });
	    } else {
	      this.passedElement = new components_1.WrappedSelect({
	        element: passedElement,
	        classNames: this.config.classNames,
	        template: function (data) {
	          return _this._templates.option(data);
	        }
	      });
	    }
	    this.initialised = false;
	    this._store = new store_1.default();
	    this._initialState = reducers_1.defaultState;
	    this._currentState = reducers_1.defaultState;
	    this._prevState = reducers_1.defaultState;
	    this._currentValue = '';
	    this._canSearch = !!this.config.searchEnabled;
	    this._isScrollingOnIe = false;
	    this._highlightPosition = 0;
	    this._wasTap = true;
	    this._placeholderValue = this._generatePlaceholderValue();
	    this._baseId = (0, utils_1.generateId)(this.passedElement.element, 'choices-');
	    /**
	     * setting direction in cases where it's explicitly set on passedElement
	     * or when calculated direction is different from the document
	     */
	    this._direction = this.passedElement.dir;
	    if (!this._direction) {
	      var elementDirection = window.getComputedStyle(this.passedElement.element).direction;
	      var documentDirection = window.getComputedStyle(document.documentElement).direction;
	      if (elementDirection !== documentDirection) {
	        this._direction = elementDirection;
	      }
	    }
	    this._idNames = {
	      itemChoice: 'item-choice'
	    };
	    if (this._isSelectElement) {
	      // Assign preset groups from passed element
	      this._presetGroups = this.passedElement.optionGroups;
	      // Assign preset options from passed element
	      this._presetOptions = this.passedElement.options;
	    }
	    // Assign preset choices from passed object
	    this._presetChoices = this.config.choices;
	    // Assign preset items from passed object first
	    this._presetItems = this.config.items;
	    // Add any values passed from attribute
	    if (this.passedElement.value && this._isTextElement) {
	      var splitValues = this.passedElement.value.split(this.config.delimiter);
	      this._presetItems = this._presetItems.concat(splitValues);
	    }
	    // Create array of choices from option elements
	    if (this.passedElement.options) {
	      this.passedElement.options.forEach(function (option) {
	        _this._presetChoices.push({
	          value: option.value,
	          label: option.innerHTML,
	          selected: !!option.selected,
	          disabled: option.disabled || option.parentNode.disabled,
	          placeholder: option.value === '' || option.hasAttribute('placeholder'),
	          customProperties: (0, utils_1.parseCustomProperties)(option.dataset.customProperties)
	        });
	      });
	    }
	    this._render = this._render.bind(this);
	    this._onFocus = this._onFocus.bind(this);
	    this._onBlur = this._onBlur.bind(this);
	    this._onKeyUp = this._onKeyUp.bind(this);
	    this._onKeyDown = this._onKeyDown.bind(this);
	    this._onClick = this._onClick.bind(this);
	    this._onTouchMove = this._onTouchMove.bind(this);
	    this._onTouchEnd = this._onTouchEnd.bind(this);
	    this._onMouseDown = this._onMouseDown.bind(this);
	    this._onMouseOver = this._onMouseOver.bind(this);
	    this._onFormReset = this._onFormReset.bind(this);
	    this._onSelectKey = this._onSelectKey.bind(this);
	    this._onEnterKey = this._onEnterKey.bind(this);
	    this._onEscapeKey = this._onEscapeKey.bind(this);
	    this._onDirectionKey = this._onDirectionKey.bind(this);
	    this._onDeleteKey = this._onDeleteKey.bind(this);
	    // If element has already been initialised with Choices, fail silently
	    if (this.passedElement.isActive) {
	      if (!this.config.silent) {
	        console.warn('Trying to initialise Choices on element already initialised', {
	          element: element
	        });
	      }
	      this.initialised = true;
	      return;
	    }
	    // Let's go
	    this.init();
	  }
	  Object.defineProperty(Choices, "defaults", {
	    get: function () {
	      return Object.preventExtensions({
	        get options() {
	          return USER_DEFAULTS;
	        },
	        get templates() {
	          return templates_1.default;
	        }
	      });
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Choices.prototype.init = function () {
	    if (this.initialised) {
	      return;
	    }
	    this._createTemplates();
	    this._createElements();
	    this._createStructure();
	    this._store.subscribe(this._render);
	    this._render();
	    this._addEventListeners();
	    var shouldDisable = !this.config.addItems || this.passedElement.element.hasAttribute('disabled');
	    if (shouldDisable) {
	      this.disable();
	    }
	    this.initialised = true;
	    var callbackOnInit = this.config.callbackOnInit;
	    // Run callback if it is a function
	    if (callbackOnInit && typeof callbackOnInit === 'function') {
	      callbackOnInit.call(this);
	    }
	  };
	  Choices.prototype.destroy = function () {
	    if (!this.initialised) {
	      return;
	    }
	    this._removeEventListeners();
	    this.passedElement.reveal();
	    this.containerOuter.unwrap(this.passedElement.element);
	    this.clearStore();
	    if (this._isSelectElement) {
	      this.passedElement.options = this._presetOptions;
	    }
	    this._templates = templates_1.default;
	    this.initialised = false;
	  };
	  Choices.prototype.enable = function () {
	    if (this.passedElement.isDisabled) {
	      this.passedElement.enable();
	    }
	    if (this.containerOuter.isDisabled) {
	      this._addEventListeners();
	      this.input.enable();
	      this.containerOuter.enable();
	    }
	    return this;
	  };
	  Choices.prototype.disable = function () {
	    if (!this.passedElement.isDisabled) {
	      this.passedElement.disable();
	    }
	    if (!this.containerOuter.isDisabled) {
	      this._removeEventListeners();
	      this.input.disable();
	      this.containerOuter.disable();
	    }
	    return this;
	  };
	  Choices.prototype.highlightItem = function (item, runEvent) {
	    if (runEvent === void 0) {
	      runEvent = true;
	    }
	    if (!item || !item.id) {
	      return this;
	    }
	    var id = item.id,
	      _a = item.groupId,
	      groupId = _a === void 0 ? -1 : _a,
	      _b = item.value,
	      value = _b === void 0 ? '' : _b,
	      _c = item.label,
	      label = _c === void 0 ? '' : _c;
	    var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
	    this._store.dispatch((0, items_1.highlightItem)(id, true));
	    if (runEvent) {
	      this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
	        id: id,
	        value: value,
	        label: label,
	        groupValue: group && group.value ? group.value : null
	      });
	    }
	    return this;
	  };
	  Choices.prototype.unhighlightItem = function (item) {
	    if (!item || !item.id) {
	      return this;
	    }
	    var id = item.id,
	      _a = item.groupId,
	      groupId = _a === void 0 ? -1 : _a,
	      _b = item.value,
	      value = _b === void 0 ? '' : _b,
	      _c = item.label,
	      label = _c === void 0 ? '' : _c;
	    var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
	    this._store.dispatch((0, items_1.highlightItem)(id, false));
	    this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
	      id: id,
	      value: value,
	      label: label,
	      groupValue: group && group.value ? group.value : null
	    });
	    return this;
	  };
	  Choices.prototype.highlightAll = function () {
	    var _this = this;
	    this._store.items.forEach(function (item) {
	      return _this.highlightItem(item);
	    });
	    return this;
	  };
	  Choices.prototype.unhighlightAll = function () {
	    var _this = this;
	    this._store.items.forEach(function (item) {
	      return _this.unhighlightItem(item);
	    });
	    return this;
	  };
	  Choices.prototype.removeActiveItemsByValue = function (value) {
	    var _this = this;
	    this._store.activeItems.filter(function (item) {
	      return item.value === value;
	    }).forEach(function (item) {
	      return _this._removeItem(item);
	    });
	    return this;
	  };
	  Choices.prototype.removeActiveItems = function (excludedId) {
	    var _this = this;
	    this._store.activeItems.filter(function (_a) {
	      var id = _a.id;
	      return id !== excludedId;
	    }).forEach(function (item) {
	      return _this._removeItem(item);
	    });
	    return this;
	  };
	  Choices.prototype.removeHighlightedItems = function (runEvent) {
	    var _this = this;
	    if (runEvent === void 0) {
	      runEvent = false;
	    }
	    this._store.highlightedActiveItems.forEach(function (item) {
	      _this._removeItem(item);
	      // If this action was performed by the user
	      // trigger the event
	      if (runEvent) {
	        _this._triggerChange(item.value);
	      }
	    });
	    return this;
	  };
	  Choices.prototype.showDropdown = function (preventInputFocus) {
	    var _this = this;
	    if (this.dropdown.isActive) {
	      return this;
	    }
	    requestAnimationFrame(function () {
	      _this.dropdown.show();
	      _this.containerOuter.open(_this.dropdown.distanceFromTopWindow);
	      if (!preventInputFocus && _this._canSearch) {
	        _this.input.focus();
	      }
	      _this.passedElement.triggerEvent(constants_1.EVENTS.showDropdown, {});
	    });
	    return this;
	  };
	  Choices.prototype.hideDropdown = function (preventInputBlur) {
	    var _this = this;
	    if (!this.dropdown.isActive) {
	      return this;
	    }
	    requestAnimationFrame(function () {
	      _this.dropdown.hide();
	      _this.containerOuter.close();
	      if (!preventInputBlur && _this._canSearch) {
	        _this.input.removeActiveDescendant();
	        _this.input.blur();
	      }
	      _this.passedElement.triggerEvent(constants_1.EVENTS.hideDropdown, {});
	    });
	    return this;
	  };
	  Choices.prototype.getValue = function (valueOnly) {
	    if (valueOnly === void 0) {
	      valueOnly = false;
	    }
	    var values = this._store.activeItems.reduce(function (selectedItems, item) {
	      var itemValue = valueOnly ? item.value : item;
	      selectedItems.push(itemValue);
	      return selectedItems;
	    }, []);
	    return this._isSelectOneElement ? values[0] : values;
	  };
	  Choices.prototype.setValue = function (items) {
	    var _this = this;
	    if (!this.initialised) {
	      return this;
	    }
	    items.forEach(function (value) {
	      return _this._setChoiceOrItem(value);
	    });
	    return this;
	  };
	  Choices.prototype.setChoiceByValue = function (value) {
	    var _this = this;
	    if (!this.initialised || this._isTextElement) {
	      return this;
	    }
	    // If only one value has been passed, convert to array
	    var choiceValue = Array.isArray(value) ? value : [value];
	    // Loop through each value and
	    choiceValue.forEach(function (val) {
	      return _this._findAndSelectChoiceByValue(val);
	    });
	    return this;
	  };
	  /**
	   * Set choices of select input via an array of objects (or function that returns array of object or promise of it),
	   * a value field name and a label field name.
	   * This behaves the same as passing items via the choices option but can be called after initialising Choices.
	   * This can also be used to add groups of choices (see example 2); Optionally pass a true `replaceChoices` value to remove any existing choices.
	   * Optionally pass a `customProperties` object to add additional data to your choices (useful when searching/filtering etc).
	   *
	   * **Input types affected:** select-one, select-multiple
	   *
	   * @example
	   * ```js
	   * const example = new Choices(element);
	   *
	   * example.setChoices([
	   *   {value: 'One', label: 'Label One', disabled: true},
	   *   {value: 'Two', label: 'Label Two', selected: true},
	   *   {value: 'Three', label: 'Label Three'},
	   * ], 'value', 'label', false);
	   * ```
	   *
	   * @example
	   * ```js
	   * const example = new Choices(element);
	   *
	   * example.setChoices(async () => {
	   *   try {
	   *      const items = await fetch('/items');
	   *      return items.json()
	   *   } catch(err) {
	   *      console.error(err)
	   *   }
	   * });
	   * ```
	   *
	   * @example
	   * ```js
	   * const example = new Choices(element);
	   *
	   * example.setChoices([{
	   *   label: 'Group one',
	   *   id: 1,
	   *   disabled: false,
	   *   choices: [
	   *     {value: 'Child One', label: 'Child One', selected: true},
	   *     {value: 'Child Two', label: 'Child Two',  disabled: true},
	   *     {value: 'Child Three', label: 'Child Three'},
	   *   ]
	   * },
	   * {
	   *   label: 'Group two',
	   *   id: 2,
	   *   disabled: false,
	   *   choices: [
	   *     {value: 'Child Four', label: 'Child Four', disabled: true},
	   *     {value: 'Child Five', label: 'Child Five'},
	   *     {value: 'Child Six', label: 'Child Six', customProperties: {
	   *       description: 'Custom description about child six',
	   *       random: 'Another random custom property'
	   *     }},
	   *   ]
	   * }], 'value', 'label', false);
	   * ```
	   */
	  Choices.prototype.setChoices = function (choicesArrayOrFetcher, value, label, replaceChoices) {
	    var _this = this;
	    if (choicesArrayOrFetcher === void 0) {
	      choicesArrayOrFetcher = [];
	    }
	    if (value === void 0) {
	      value = 'value';
	    }
	    if (label === void 0) {
	      label = 'label';
	    }
	    if (replaceChoices === void 0) {
	      replaceChoices = false;
	    }
	    if (!this.initialised) {
	      throw new ReferenceError("setChoices was called on a non-initialized instance of Choices");
	    }
	    if (!this._isSelectElement) {
	      throw new TypeError("setChoices can't be used with INPUT based Choices");
	    }
	    if (typeof value !== 'string' || !value) {
	      throw new TypeError("value parameter must be a name of 'value' field in passed objects");
	    }
	    // Clear choices if needed
	    if (replaceChoices) {
	      this.clearChoices();
	    }
	    if (typeof choicesArrayOrFetcher === 'function') {
	      // it's a choices fetcher function
	      var fetcher_1 = choicesArrayOrFetcher(this);
	      if (typeof Promise === 'function' && fetcher_1 instanceof Promise) {
	        // that's a promise
	        // eslint-disable-next-line no-promise-executor-return
	        return new Promise(function (resolve) {
	          return requestAnimationFrame(resolve);
	        }).then(function () {
	          return _this._handleLoadingState(true);
	        }).then(function () {
	          return fetcher_1;
	        }).then(function (data) {
	          return _this.setChoices(data, value, label, replaceChoices);
	        }).catch(function (err) {
	          if (!_this.config.silent) {
	            console.error(err);
	          }
	        }).then(function () {
	          return _this._handleLoadingState(false);
	        }).then(function () {
	          return _this;
	        });
	      }
	      // function returned something else than promise, let's check if it's an array of choices
	      if (!Array.isArray(fetcher_1)) {
	        throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: ".concat(typeof fetcher_1));
	      }
	      // recursion with results, it's sync and choices were cleared already
	      return this.setChoices(fetcher_1, value, label, false);
	    }
	    if (!Array.isArray(choicesArrayOrFetcher)) {
	      throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
	    }
	    this.containerOuter.removeLoadingState();
	    this._startLoading();
	    choicesArrayOrFetcher.forEach(function (groupOrChoice) {
	      if (groupOrChoice.choices) {
	        _this._addGroup({
	          id: groupOrChoice.id ? parseInt("".concat(groupOrChoice.id), 10) : null,
	          group: groupOrChoice,
	          valueKey: value,
	          labelKey: label
	        });
	      } else {
	        var choice = groupOrChoice;
	        _this._addChoice({
	          value: choice[value],
	          label: choice[label],
	          isSelected: !!choice.selected,
	          isDisabled: !!choice.disabled,
	          placeholder: !!choice.placeholder,
	          customProperties: choice.customProperties
	        });
	      }
	    });
	    this._stopLoading();
	    return this;
	  };
	  Choices.prototype.clearChoices = function () {
	    this._store.dispatch((0, choices_1.clearChoices)());
	    return this;
	  };
	  Choices.prototype.clearStore = function () {
	    this._store.dispatch((0, misc_1.clearAll)());
	    return this;
	  };
	  Choices.prototype.clearInput = function () {
	    var shouldSetInputWidth = !this._isSelectOneElement;
	    this.input.clear(shouldSetInputWidth);
	    if (!this._isTextElement && this._canSearch) {
	      this._isSearching = false;
	      this._store.dispatch((0, choices_1.activateChoices)(true));
	    }
	    return this;
	  };
	  Choices.prototype._render = function () {
	    if (this._store.isLoading()) {
	      return;
	    }
	    this._currentState = this._store.state;
	    var stateChanged = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items;
	    var shouldRenderChoices = this._isSelectElement;
	    var shouldRenderItems = this._currentState.items !== this._prevState.items;
	    if (!stateChanged) {
	      return;
	    }
	    if (shouldRenderChoices) {
	      this._renderChoices();
	    }
	    if (shouldRenderItems) {
	      this._renderItems();
	    }
	    this._prevState = this._currentState;
	  };
	  Choices.prototype._renderChoices = function () {
	    var _this = this;
	    var _a = this._store,
	      activeGroups = _a.activeGroups,
	      activeChoices = _a.activeChoices;
	    var choiceListFragment = document.createDocumentFragment();
	    this.choiceList.clear();
	    if (this.config.resetScrollPosition) {
	      requestAnimationFrame(function () {
	        return _this.choiceList.scrollToTop();
	      });
	    }
	    // If we have grouped options
	    if (activeGroups.length >= 1 && !this._isSearching) {
	      // If we have a placeholder choice along with groups
	      var activePlaceholders = activeChoices.filter(function (activeChoice) {
	        return activeChoice.placeholder === true && activeChoice.groupId === -1;
	      });
	      if (activePlaceholders.length >= 1) {
	        choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);
	      }
	      choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);
	    } else if (activeChoices.length >= 1) {
	      choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);
	    }
	    // If we have choices to show
	    if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {
	      var activeItems = this._store.activeItems;
	      var canAddItem = this._canAddItem(activeItems, this.input.value);
	      // ...and we can select them
	      if (canAddItem.response) {
	        // ...append them and highlight the first choice
	        this.choiceList.append(choiceListFragment);
	        this._highlightChoice();
	      } else {
	        var notice = this._getTemplate('notice', canAddItem.notice);
	        this.choiceList.append(notice);
	      }
	    } else {
	      // Otherwise show a notice
	      var dropdownItem = void 0;
	      var notice = void 0;
	      if (this._isSearching) {
	        notice = typeof this.config.noResultsText === 'function' ? this.config.noResultsText() : this.config.noResultsText;
	        dropdownItem = this._getTemplate('notice', notice, 'no-results');
	      } else {
	        notice = typeof this.config.noChoicesText === 'function' ? this.config.noChoicesText() : this.config.noChoicesText;
	        dropdownItem = this._getTemplate('notice', notice, 'no-choices');
	      }
	      this.choiceList.append(dropdownItem);
	    }
	  };
	  Choices.prototype._renderItems = function () {
	    var activeItems = this._store.activeItems || [];
	    this.itemList.clear();
	    // Create a fragment to store our list items
	    // (so we don't have to update the DOM for each item)
	    var itemListFragment = this._createItemsFragment(activeItems);
	    // If we have items to add, append them
	    if (itemListFragment.childNodes) {
	      this.itemList.append(itemListFragment);
	    }
	  };
	  Choices.prototype._createGroupsFragment = function (groups, choices, fragment) {
	    var _this = this;
	    if (fragment === void 0) {
	      fragment = document.createDocumentFragment();
	    }
	    var getGroupChoices = function (group) {
	      return choices.filter(function (choice) {
	        if (_this._isSelectOneElement) {
	          return choice.groupId === group.id;
	        }
	        return choice.groupId === group.id && (_this.config.renderSelectedChoices === 'always' || !choice.selected);
	      });
	    };
	    // If sorting is enabled, filter groups
	    if (this.config.shouldSort) {
	      groups.sort(this.config.sorter);
	    }
	    groups.forEach(function (group) {
	      var groupChoices = getGroupChoices(group);
	      if (groupChoices.length >= 1) {
	        var dropdownGroup = _this._getTemplate('choiceGroup', group);
	        fragment.appendChild(dropdownGroup);
	        _this._createChoicesFragment(groupChoices, fragment, true);
	      }
	    });
	    return fragment;
	  };
	  Choices.prototype._createChoicesFragment = function (choices, fragment, withinGroup) {
	    var _this = this;
	    if (fragment === void 0) {
	      fragment = document.createDocumentFragment();
	    }
	    if (withinGroup === void 0) {
	      withinGroup = false;
	    }
	    // Create a fragment to store our list items (so we don't have to update the DOM for each item)
	    var _a = this.config,
	      renderSelectedChoices = _a.renderSelectedChoices,
	      searchResultLimit = _a.searchResultLimit,
	      renderChoiceLimit = _a.renderChoiceLimit;
	    var filter = this._isSearching ? utils_1.sortByScore : this.config.sorter;
	    var appendChoice = function (choice) {
	      var shouldRender = renderSelectedChoices === 'auto' ? _this._isSelectOneElement || !choice.selected : true;
	      if (shouldRender) {
	        var dropdownItem = _this._getTemplate('choice', choice, _this.config.itemSelectText);
	        fragment.appendChild(dropdownItem);
	      }
	    };
	    var rendererableChoices = choices;
	    if (renderSelectedChoices === 'auto' && !this._isSelectOneElement) {
	      rendererableChoices = choices.filter(function (choice) {
	        return !choice.selected;
	      });
	    }
	    // Split array into placeholders and "normal" choices
	    var _b = rendererableChoices.reduce(function (acc, choice) {
	        if (choice.placeholder) {
	          acc.placeholderChoices.push(choice);
	        } else {
	          acc.normalChoices.push(choice);
	        }
	        return acc;
	      }, {
	        placeholderChoices: [],
	        normalChoices: []
	      }),
	      placeholderChoices = _b.placeholderChoices,
	      normalChoices = _b.normalChoices;
	    // If sorting is enabled or the user is searching, filter choices
	    if (this.config.shouldSort || this._isSearching) {
	      normalChoices.sort(filter);
	    }
	    var choiceLimit = rendererableChoices.length;
	    // Prepend placeholeder
	    var sortedChoices = this._isSelectOneElement ? __spreadArray(__spreadArray([], placeholderChoices, true), normalChoices, true) : normalChoices;
	    if (this._isSearching) {
	      choiceLimit = searchResultLimit;
	    } else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {
	      choiceLimit = renderChoiceLimit;
	    }
	    // Add each choice to dropdown within range
	    for (var i = 0; i < choiceLimit; i += 1) {
	      if (sortedChoices[i]) {
	        appendChoice(sortedChoices[i]);
	      }
	    }
	    return fragment;
	  };
	  Choices.prototype._createItemsFragment = function (items, fragment) {
	    var _this = this;
	    if (fragment === void 0) {
	      fragment = document.createDocumentFragment();
	    }
	    // Create fragment to add elements to
	    var _a = this.config,
	      shouldSortItems = _a.shouldSortItems,
	      sorter = _a.sorter,
	      removeItemButton = _a.removeItemButton;
	    // If sorting is enabled, filter items
	    if (shouldSortItems && !this._isSelectOneElement) {
	      items.sort(sorter);
	    }
	    if (this._isTextElement) {
	      // Update the value of the hidden input
	      this.passedElement.value = items.map(function (_a) {
	        var value = _a.value;
	        return value;
	      }).join(this.config.delimiter);
	    } else {
	      // Update the options of the hidden input
	      this.passedElement.options = items;
	    }
	    var addItemToFragment = function (item) {
	      // Create new list element
	      var listItem = _this._getTemplate('item', item, removeItemButton);
	      // Append it to list
	      fragment.appendChild(listItem);
	    };
	    // Add each list item to list
	    items.forEach(addItemToFragment);
	    return fragment;
	  };
	  Choices.prototype._triggerChange = function (value) {
	    if (value === undefined || value === null) {
	      return;
	    }
	    this.passedElement.triggerEvent(constants_1.EVENTS.change, {
	      value: value
	    });
	  };
	  Choices.prototype._selectPlaceholderChoice = function (placeholderChoice) {
	    this._addItem({
	      value: placeholderChoice.value,
	      label: placeholderChoice.label,
	      choiceId: placeholderChoice.id,
	      groupId: placeholderChoice.groupId,
	      placeholder: placeholderChoice.placeholder
	    });
	    this._triggerChange(placeholderChoice.value);
	  };
	  Choices.prototype._handleButtonAction = function (activeItems, element) {
	    if (!activeItems || !element || !this.config.removeItems || !this.config.removeItemButton) {
	      return;
	    }
	    var itemId = element.parentNode && element.parentNode.dataset.id;
	    var itemToRemove = itemId && activeItems.find(function (item) {
	      return item.id === parseInt(itemId, 10);
	    });
	    if (!itemToRemove) {
	      return;
	    }
	    // Remove item associated with button
	    this._removeItem(itemToRemove);
	    this._triggerChange(itemToRemove.value);
	    if (this._isSelectOneElement && this._store.placeholderChoice) {
	      this._selectPlaceholderChoice(this._store.placeholderChoice);
	    }
	  };
	  Choices.prototype._handleItemAction = function (activeItems, element, hasShiftKey) {
	    var _this = this;
	    if (hasShiftKey === void 0) {
	      hasShiftKey = false;
	    }
	    if (!activeItems || !element || !this.config.removeItems || this._isSelectOneElement) {
	      return;
	    }
	    var passedId = element.dataset.id;
	    // We only want to select one item with a click
	    // so we deselect any items that aren't the target
	    // unless shift is being pressed
	    activeItems.forEach(function (item) {
	      if (item.id === parseInt("".concat(passedId), 10) && !item.highlighted) {
	        _this.highlightItem(item);
	      } else if (!hasShiftKey && item.highlighted) {
	        _this.unhighlightItem(item);
	      }
	    });
	    // Focus input as without focus, a user cannot do anything with a
	    // highlighted item
	    this.input.focus();
	  };
	  Choices.prototype._handleChoiceAction = function (activeItems, element) {
	    if (!activeItems || !element) {
	      return;
	    }
	    // If we are clicking on an option
	    var id = element.dataset.id;
	    var choice = id && this._store.getChoiceById(id);
	    if (!choice) {
	      return;
	    }
	    var passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : undefined;
	    var hasActiveDropdown = this.dropdown.isActive;
	    // Update choice keyCode
	    choice.keyCode = passedKeyCode;
	    this.passedElement.triggerEvent(constants_1.EVENTS.choice, {
	      choice: choice
	    });
	    if (!choice.selected && !choice.disabled) {
	      var canAddItem = this._canAddItem(activeItems, choice.value);
	      if (canAddItem.response) {
	        this._addItem({
	          value: choice.value,
	          label: choice.label,
	          choiceId: choice.id,
	          groupId: choice.groupId,
	          customProperties: choice.customProperties,
	          placeholder: choice.placeholder,
	          keyCode: choice.keyCode
	        });
	        this._triggerChange(choice.value);
	      }
	    }
	    this.clearInput();
	    // We want to close the dropdown if we are dealing with a single select box
	    if (hasActiveDropdown && this._isSelectOneElement) {
	      this.hideDropdown(true);
	      this.containerOuter.focus();
	    }
	  };
	  Choices.prototype._handleBackspace = function (activeItems) {
	    if (!this.config.removeItems || !activeItems) {
	      return;
	    }
	    var lastItem = activeItems[activeItems.length - 1];
	    var hasHighlightedItems = activeItems.some(function (item) {
	      return item.highlighted;
	    });
	    // If editing the last item is allowed and there are not other selected items,
	    // we can edit the item value. Otherwise if we can remove items, remove all selected items
	    if (this.config.editItems && !hasHighlightedItems && lastItem) {
	      this.input.value = lastItem.value;
	      this.input.setWidth();
	      this._removeItem(lastItem);
	      this._triggerChange(lastItem.value);
	    } else {
	      if (!hasHighlightedItems) {
	        // Highlight last item if none already highlighted
	        this.highlightItem(lastItem, false);
	      }
	      this.removeHighlightedItems(true);
	    }
	  };
	  Choices.prototype._startLoading = function () {
	    this._store.dispatch((0, misc_1.setIsLoading)(true));
	  };
	  Choices.prototype._stopLoading = function () {
	    this._store.dispatch((0, misc_1.setIsLoading)(false));
	  };
	  Choices.prototype._handleLoadingState = function (setLoading) {
	    if (setLoading === void 0) {
	      setLoading = true;
	    }
	    var placeholderItem = this.itemList.getChild(".".concat(this.config.classNames.placeholder));
	    if (setLoading) {
	      this.disable();
	      this.containerOuter.addLoadingState();
	      if (this._isSelectOneElement) {
	        if (!placeholderItem) {
	          placeholderItem = this._getTemplate('placeholder', this.config.loadingText);
	          if (placeholderItem) {
	            this.itemList.append(placeholderItem);
	          }
	        } else {
	          placeholderItem.innerHTML = this.config.loadingText;
	        }
	      } else {
	        this.input.placeholder = this.config.loadingText;
	      }
	    } else {
	      this.enable();
	      this.containerOuter.removeLoadingState();
	      if (this._isSelectOneElement) {
	        if (placeholderItem) {
	          placeholderItem.innerHTML = this._placeholderValue || '';
	        }
	      } else {
	        this.input.placeholder = this._placeholderValue || '';
	      }
	    }
	  };
	  Choices.prototype._handleSearch = function (value) {
	    if (!this.input.isFocussed) {
	      return;
	    }
	    var choices = this._store.choices;
	    var _a = this.config,
	      searchFloor = _a.searchFloor,
	      searchChoices = _a.searchChoices;
	    var hasUnactiveChoices = choices.some(function (option) {
	      return !option.active;
	    });
	    // Check that we have a value to search and the input was an alphanumeric character
	    if (value !== null && typeof value !== 'undefined' && value.length >= searchFloor) {
	      var resultCount = searchChoices ? this._searchChoices(value) : 0;
	      // Trigger search event
	      this.passedElement.triggerEvent(constants_1.EVENTS.search, {
	        value: value,
	        resultCount: resultCount
	      });
	    } else if (hasUnactiveChoices) {
	      // Otherwise reset choices to active
	      this._isSearching = false;
	      this._store.dispatch((0, choices_1.activateChoices)(true));
	    }
	  };
	  Choices.prototype._canAddItem = function (activeItems, value) {
	    var canAddItem = true;
	    var notice = typeof this.config.addItemText === 'function' ? this.config.addItemText(value) : this.config.addItemText;
	    if (!this._isSelectOneElement) {
	      var isDuplicateValue = (0, utils_1.existsInArray)(activeItems, value);
	      if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {
	        // If there is a max entry limit and we have reached that limit
	        // don't update
	        canAddItem = false;
	        notice = typeof this.config.maxItemText === 'function' ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;
	      }
	      if (!this.config.duplicateItemsAllowed && isDuplicateValue && canAddItem) {
	        canAddItem = false;
	        notice = typeof this.config.uniqueItemText === 'function' ? this.config.uniqueItemText(value) : this.config.uniqueItemText;
	      }
	      if (this._isTextElement && this.config.addItems && canAddItem && typeof this.config.addItemFilter === 'function' && !this.config.addItemFilter(value)) {
	        canAddItem = false;
	        notice = typeof this.config.customAddItemText === 'function' ? this.config.customAddItemText(value) : this.config.customAddItemText;
	      }
	    }
	    return {
	      response: canAddItem,
	      notice: notice
	    };
	  };
	  Choices.prototype._searchChoices = function (value) {
	    var newValue = typeof value === 'string' ? value.trim() : value;
	    var currentValue = typeof this._currentValue === 'string' ? this._currentValue.trim() : this._currentValue;
	    if (newValue.length < 1 && newValue === "".concat(currentValue, " ")) {
	      return 0;
	    }
	    // If new value matches the desired length and is not the same as the current value with a space
	    var haystack = this._store.searchableChoices;
	    var needle = newValue;
	    var options = Object.assign(this.config.fuseOptions, {
	      keys: __spreadArray([], this.config.searchFields, true),
	      includeMatches: true
	    });
	    var fuse = new fuse_js_1.default(haystack, options);
	    var results = fuse.search(needle); // see https://github.com/krisk/Fuse/issues/303
	    this._currentValue = newValue;
	    this._highlightPosition = 0;
	    this._isSearching = true;
	    this._store.dispatch((0, choices_1.filterChoices)(results));
	    return results.length;
	  };
	  Choices.prototype._addEventListeners = function () {
	    var documentElement = document.documentElement;
	    // capture events - can cancel event processing or propagation
	    documentElement.addEventListener('touchend', this._onTouchEnd, true);
	    this.containerOuter.element.addEventListener('keydown', this._onKeyDown, true);
	    this.containerOuter.element.addEventListener('mousedown', this._onMouseDown, true);
	    // passive events - doesn't call `preventDefault` or `stopPropagation`
	    documentElement.addEventListener('click', this._onClick, {
	      passive: true
	    });
	    documentElement.addEventListener('touchmove', this._onTouchMove, {
	      passive: true
	    });
	    this.dropdown.element.addEventListener('mouseover', this._onMouseOver, {
	      passive: true
	    });
	    if (this._isSelectOneElement) {
	      this.containerOuter.element.addEventListener('focus', this._onFocus, {
	        passive: true
	      });
	      this.containerOuter.element.addEventListener('blur', this._onBlur, {
	        passive: true
	      });
	    }
	    this.input.element.addEventListener('keyup', this._onKeyUp, {
	      passive: true
	    });
	    this.input.element.addEventListener('focus', this._onFocus, {
	      passive: true
	    });
	    this.input.element.addEventListener('blur', this._onBlur, {
	      passive: true
	    });
	    if (this.input.element.form) {
	      this.input.element.form.addEventListener('reset', this._onFormReset, {
	        passive: true
	      });
	    }
	    this.input.addEventListeners();
	  };
	  Choices.prototype._removeEventListeners = function () {
	    var documentElement = document.documentElement;
	    documentElement.removeEventListener('touchend', this._onTouchEnd, true);
	    this.containerOuter.element.removeEventListener('keydown', this._onKeyDown, true);
	    this.containerOuter.element.removeEventListener('mousedown', this._onMouseDown, true);
	    documentElement.removeEventListener('click', this._onClick);
	    documentElement.removeEventListener('touchmove', this._onTouchMove);
	    this.dropdown.element.removeEventListener('mouseover', this._onMouseOver);
	    if (this._isSelectOneElement) {
	      this.containerOuter.element.removeEventListener('focus', this._onFocus);
	      this.containerOuter.element.removeEventListener('blur', this._onBlur);
	    }
	    this.input.element.removeEventListener('keyup', this._onKeyUp);
	    this.input.element.removeEventListener('focus', this._onFocus);
	    this.input.element.removeEventListener('blur', this._onBlur);
	    if (this.input.element.form) {
	      this.input.element.form.removeEventListener('reset', this._onFormReset);
	    }
	    this.input.removeEventListeners();
	  };
	  Choices.prototype._onKeyDown = function (event) {
	    var keyCode = event.keyCode;
	    var activeItems = this._store.activeItems;
	    var hasFocusedInput = this.input.isFocussed;
	    var hasActiveDropdown = this.dropdown.isActive;
	    var hasItems = this.itemList.hasChildren();
	    var keyString = String.fromCharCode(keyCode);
	    // eslint-disable-next-line no-control-regex
	    var wasPrintableChar = /[^\x00-\x1F]/.test(keyString);
	    var BACK_KEY = constants_1.KEY_CODES.BACK_KEY,
	      DELETE_KEY = constants_1.KEY_CODES.DELETE_KEY,
	      ENTER_KEY = constants_1.KEY_CODES.ENTER_KEY,
	      A_KEY = constants_1.KEY_CODES.A_KEY,
	      ESC_KEY = constants_1.KEY_CODES.ESC_KEY,
	      UP_KEY = constants_1.KEY_CODES.UP_KEY,
	      DOWN_KEY = constants_1.KEY_CODES.DOWN_KEY,
	      PAGE_UP_KEY = constants_1.KEY_CODES.PAGE_UP_KEY,
	      PAGE_DOWN_KEY = constants_1.KEY_CODES.PAGE_DOWN_KEY;
	    if (!this._isTextElement && !hasActiveDropdown && wasPrintableChar) {
	      this.showDropdown();
	      if (!this.input.isFocussed) {
	        /*
	          We update the input value with the pressed key as
	          the input was not focussed at the time of key press
	          therefore does not have the value of the key.
	        */
	        this.input.value += event.key.toLowerCase();
	      }
	    }
	    switch (keyCode) {
	      case A_KEY:
	        return this._onSelectKey(event, hasItems);
	      case ENTER_KEY:
	        return this._onEnterKey(event, activeItems, hasActiveDropdown);
	      case ESC_KEY:
	        return this._onEscapeKey(hasActiveDropdown);
	      case UP_KEY:
	      case PAGE_UP_KEY:
	      case DOWN_KEY:
	      case PAGE_DOWN_KEY:
	        return this._onDirectionKey(event, hasActiveDropdown);
	      case DELETE_KEY:
	      case BACK_KEY:
	        return this._onDeleteKey(event, activeItems, hasFocusedInput);
	    }
	  };
	  Choices.prototype._onKeyUp = function (_a) {
	    var target = _a.target,
	      keyCode = _a.keyCode;
	    var value = this.input.value;
	    var activeItems = this._store.activeItems;
	    var canAddItem = this._canAddItem(activeItems, value);
	    var backKey = constants_1.KEY_CODES.BACK_KEY,
	      deleteKey = constants_1.KEY_CODES.DELETE_KEY;
	    // We are typing into a text input and have a value, we want to show a dropdown
	    // notice. Otherwise hide the dropdown
	    if (this._isTextElement) {
	      var canShowDropdownNotice = canAddItem.notice && value;
	      if (canShowDropdownNotice) {
	        var dropdownItem = this._getTemplate('notice', canAddItem.notice);
	        this.dropdown.element.innerHTML = dropdownItem.outerHTML;
	        this.showDropdown(true);
	      } else {
	        this.hideDropdown(true);
	      }
	    } else {
	      var wasRemovalKeyCode = keyCode === backKey || keyCode === deleteKey;
	      var userHasRemovedValue = wasRemovalKeyCode && target && !target.value;
	      var canReactivateChoices = !this._isTextElement && this._isSearching;
	      var canSearch = this._canSearch && canAddItem.response;
	      if (userHasRemovedValue && canReactivateChoices) {
	        this._isSearching = false;
	        this._store.dispatch((0, choices_1.activateChoices)(true));
	      } else if (canSearch) {
	        this._handleSearch(this.input.rawValue);
	      }
	    }
	    this._canSearch = this.config.searchEnabled;
	  };
	  Choices.prototype._onSelectKey = function (event, hasItems) {
	    var ctrlKey = event.ctrlKey,
	      metaKey = event.metaKey;
	    var hasCtrlDownKeyPressed = ctrlKey || metaKey;
	    // If CTRL + A or CMD + A have been pressed and there are items to select
	    if (hasCtrlDownKeyPressed && hasItems) {
	      this._canSearch = false;
	      var shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;
	      if (shouldHightlightAll) {
	        this.highlightAll();
	      }
	    }
	  };
	  Choices.prototype._onEnterKey = function (event, activeItems, hasActiveDropdown) {
	    var target = event.target;
	    var enterKey = constants_1.KEY_CODES.ENTER_KEY;
	    var targetWasButton = target && target.hasAttribute('data-button');
	    if (this._isTextElement && target && target.value) {
	      var value = this.input.value;
	      var canAddItem = this._canAddItem(activeItems, value);
	      if (canAddItem.response) {
	        this.hideDropdown(true);
	        this._addItem({
	          value: value
	        });
	        this._triggerChange(value);
	        this.clearInput();
	      }
	    }
	    if (targetWasButton) {
	      this._handleButtonAction(activeItems, target);
	      event.preventDefault();
	    }
	    if (hasActiveDropdown) {
	      var highlightedChoice = this.dropdown.getChild(".".concat(this.config.classNames.highlightedState));
	      if (highlightedChoice) {
	        // add enter keyCode value
	        if (activeItems[0]) {
	          activeItems[0].keyCode = enterKey; // eslint-disable-line no-param-reassign
	        }

	        this._handleChoiceAction(activeItems, highlightedChoice);
	      }
	      event.preventDefault();
	    } else if (this._isSelectOneElement) {
	      this.showDropdown();
	      event.preventDefault();
	    }
	  };
	  Choices.prototype._onEscapeKey = function (hasActiveDropdown) {
	    if (hasActiveDropdown) {
	      this.hideDropdown(true);
	      this.containerOuter.focus();
	    }
	  };
	  Choices.prototype._onDirectionKey = function (event, hasActiveDropdown) {
	    var keyCode = event.keyCode,
	      metaKey = event.metaKey;
	    var downKey = constants_1.KEY_CODES.DOWN_KEY,
	      pageUpKey = constants_1.KEY_CODES.PAGE_UP_KEY,
	      pageDownKey = constants_1.KEY_CODES.PAGE_DOWN_KEY;
	    // If up or down key is pressed, traverse through options
	    if (hasActiveDropdown || this._isSelectOneElement) {
	      this.showDropdown();
	      this._canSearch = false;
	      var directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;
	      var skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;
	      var selectableChoiceIdentifier = '[data-choice-selectable]';
	      var nextEl = void 0;
	      if (skipKey) {
	        if (directionInt > 0) {
	          nextEl = this.dropdown.element.querySelector("".concat(selectableChoiceIdentifier, ":last-of-type"));
	        } else {
	          nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
	        }
	      } else {
	        var currentEl = this.dropdown.element.querySelector(".".concat(this.config.classNames.highlightedState));
	        if (currentEl) {
	          nextEl = (0, utils_1.getAdjacentEl)(currentEl, selectableChoiceIdentifier, directionInt);
	        } else {
	          nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
	        }
	      }
	      if (nextEl) {
	        // We prevent default to stop the cursor moving
	        // when pressing the arrow
	        if (!(0, utils_1.isScrolledIntoView)(nextEl, this.choiceList.element, directionInt)) {
	          this.choiceList.scrollToChildElement(nextEl, directionInt);
	        }
	        this._highlightChoice(nextEl);
	      }
	      // Prevent default to maintain cursor position whilst
	      // traversing dropdown options
	      event.preventDefault();
	    }
	  };
	  Choices.prototype._onDeleteKey = function (event, activeItems, hasFocusedInput) {
	    var target = event.target;
	    // If backspace or delete key is pressed and the input has no value
	    if (!this._isSelectOneElement && !target.value && hasFocusedInput) {
	      this._handleBackspace(activeItems);
	      event.preventDefault();
	    }
	  };
	  Choices.prototype._onTouchMove = function () {
	    if (this._wasTap) {
	      this._wasTap = false;
	    }
	  };
	  Choices.prototype._onTouchEnd = function (event) {
	    var target = (event || event.touches[0]).target;
	    var touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);
	    if (touchWasWithinContainer) {
	      var containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;
	      if (containerWasExactTarget) {
	        if (this._isTextElement) {
	          this.input.focus();
	        } else if (this._isSelectMultipleElement) {
	          this.showDropdown();
	        }
	      }
	      // Prevents focus event firing
	      event.stopPropagation();
	    }
	    this._wasTap = true;
	  };
	  /**
	   * Handles mousedown event in capture mode for containetOuter.element
	   */
	  Choices.prototype._onMouseDown = function (event) {
	    var target = event.target;
	    if (!(target instanceof HTMLElement)) {
	      return;
	    }
	    // If we have our mouse down on the scrollbar and are on IE11...
	    if (IS_IE11 && this.choiceList.element.contains(target)) {
	      // check if click was on a scrollbar area
	      var firstChoice = this.choiceList.element.firstElementChild;
	      var isOnScrollbar = this._direction === 'ltr' ? event.offsetX >= firstChoice.offsetWidth : event.offsetX < firstChoice.offsetLeft;
	      this._isScrollingOnIe = isOnScrollbar;
	    }
	    if (target === this.input.element) {
	      return;
	    }
	    var item = target.closest('[data-button],[data-item],[data-choice]');
	    if (item instanceof HTMLElement) {
	      var hasShiftKey = event.shiftKey;
	      var activeItems = this._store.activeItems;
	      var dataset = item.dataset;
	      if ('button' in dataset) {
	        this._handleButtonAction(activeItems, item);
	      } else if ('item' in dataset) {
	        this._handleItemAction(activeItems, item, hasShiftKey);
	      } else if ('choice' in dataset) {
	        this._handleChoiceAction(activeItems, item);
	      }
	    }
	    event.preventDefault();
	  };
	  /**
	   * Handles mouseover event over this.dropdown
	   * @param {MouseEvent} event
	   */
	  Choices.prototype._onMouseOver = function (_a) {
	    var target = _a.target;
	    if (target instanceof HTMLElement && 'choice' in target.dataset) {
	      this._highlightChoice(target);
	    }
	  };
	  Choices.prototype._onClick = function (_a) {
	    var target = _a.target;
	    var clickWasWithinContainer = this.containerOuter.element.contains(target);
	    if (clickWasWithinContainer) {
	      if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {
	        if (this._isTextElement) {
	          if (document.activeElement !== this.input.element) {
	            this.input.focus();
	          }
	        } else {
	          this.showDropdown();
	          this.containerOuter.focus();
	        }
	      } else if (this._isSelectOneElement && target !== this.input.element && !this.dropdown.element.contains(target)) {
	        this.hideDropdown();
	      }
	    } else {
	      var hasHighlightedItems = this._store.highlightedActiveItems.length > 0;
	      if (hasHighlightedItems) {
	        this.unhighlightAll();
	      }
	      this.containerOuter.removeFocusState();
	      this.hideDropdown(true);
	    }
	  };
	  Choices.prototype._onFocus = function (_a) {
	    var _b;
	    var _this = this;
	    var target = _a.target;
	    var focusWasWithinContainer = target && this.containerOuter.element.contains(target);
	    if (!focusWasWithinContainer) {
	      return;
	    }
	    var focusActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function () {
	      if (target === _this.input.element) {
	        _this.containerOuter.addFocusState();
	      }
	    }, _b[constants_1.SELECT_ONE_TYPE] = function () {
	      _this.containerOuter.addFocusState();
	      if (target === _this.input.element) {
	        _this.showDropdown(true);
	      }
	    }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function () {
	      if (target === _this.input.element) {
	        _this.showDropdown(true);
	        // If element is a select box, the focused element is the container and the dropdown
	        // isn't already open, focus and show dropdown
	        _this.containerOuter.addFocusState();
	      }
	    }, _b);
	    focusActions[this.passedElement.element.type]();
	  };
	  Choices.prototype._onBlur = function (_a) {
	    var _b;
	    var _this = this;
	    var target = _a.target;
	    var blurWasWithinContainer = target && this.containerOuter.element.contains(target);
	    if (blurWasWithinContainer && !this._isScrollingOnIe) {
	      var activeItems = this._store.activeItems;
	      var hasHighlightedItems_1 = activeItems.some(function (item) {
	        return item.highlighted;
	      });
	      var blurActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function () {
	        if (target === _this.input.element) {
	          _this.containerOuter.removeFocusState();
	          if (hasHighlightedItems_1) {
	            _this.unhighlightAll();
	          }
	          _this.hideDropdown(true);
	        }
	      }, _b[constants_1.SELECT_ONE_TYPE] = function () {
	        _this.containerOuter.removeFocusState();
	        if (target === _this.input.element || target === _this.containerOuter.element && !_this._canSearch) {
	          _this.hideDropdown(true);
	        }
	      }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function () {
	        if (target === _this.input.element) {
	          _this.containerOuter.removeFocusState();
	          _this.hideDropdown(true);
	          if (hasHighlightedItems_1) {
	            _this.unhighlightAll();
	          }
	        }
	      }, _b);
	      blurActions[this.passedElement.element.type]();
	    } else {
	      // On IE11, clicking the scollbar blurs our input and thus
	      // closes the dropdown. To stop this, we refocus our input
	      // if we know we are on IE *and* are scrolling.
	      this._isScrollingOnIe = false;
	      this.input.element.focus();
	    }
	  };
	  Choices.prototype._onFormReset = function () {
	    this._store.dispatch((0, misc_1.resetTo)(this._initialState));
	  };
	  Choices.prototype._highlightChoice = function (el) {
	    var _this = this;
	    if (el === void 0) {
	      el = null;
	    }
	    var choices = Array.from(this.dropdown.element.querySelectorAll('[data-choice-selectable]'));
	    if (!choices.length) {
	      return;
	    }
	    var passedEl = el;
	    var highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(".".concat(this.config.classNames.highlightedState)));
	    // Remove any highlighted choices
	    highlightedChoices.forEach(function (choice) {
	      choice.classList.remove(_this.config.classNames.highlightedState);
	      choice.setAttribute('aria-selected', 'false');
	    });
	    if (passedEl) {
	      this._highlightPosition = choices.indexOf(passedEl);
	    } else {
	      // Highlight choice based on last known highlight location
	      if (choices.length > this._highlightPosition) {
	        // If we have an option to highlight
	        passedEl = choices[this._highlightPosition];
	      } else {
	        // Otherwise highlight the option before
	        passedEl = choices[choices.length - 1];
	      }
	      if (!passedEl) {
	        passedEl = choices[0];
	      }
	    }
	    passedEl.classList.add(this.config.classNames.highlightedState);
	    passedEl.setAttribute('aria-selected', 'true');
	    this.passedElement.triggerEvent(constants_1.EVENTS.highlightChoice, {
	      el: passedEl
	    });
	    if (this.dropdown.isActive) {
	      // IE11 ignores aria-label and blocks virtual keyboard
	      // if aria-activedescendant is set without a dropdown
	      this.input.setActiveDescendant(passedEl.id);
	      this.containerOuter.setActiveDescendant(passedEl.id);
	    }
	  };
	  Choices.prototype._addItem = function (_a) {
	    var value = _a.value,
	      _b = _a.label,
	      label = _b === void 0 ? null : _b,
	      _c = _a.choiceId,
	      choiceId = _c === void 0 ? -1 : _c,
	      _d = _a.groupId,
	      groupId = _d === void 0 ? -1 : _d,
	      _e = _a.customProperties,
	      customProperties = _e === void 0 ? {} : _e,
	      _f = _a.placeholder,
	      placeholder = _f === void 0 ? false : _f,
	      _g = _a.keyCode,
	      keyCode = _g === void 0 ? -1 : _g;
	    var passedValue = typeof value === 'string' ? value.trim() : value;
	    var items = this._store.items;
	    var passedLabel = label || passedValue;
	    var passedOptionId = choiceId || -1;
	    var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
	    var id = items ? items.length + 1 : 1;
	    // If a prepended value has been passed, prepend it
	    if (this.config.prependValue) {
	      passedValue = this.config.prependValue + passedValue.toString();
	    }
	    // If an appended value has been passed, append it
	    if (this.config.appendValue) {
	      passedValue += this.config.appendValue.toString();
	    }
	    this._store.dispatch((0, items_1.addItem)({
	      value: passedValue,
	      label: passedLabel,
	      id: id,
	      choiceId: passedOptionId,
	      groupId: groupId,
	      customProperties: customProperties,
	      placeholder: placeholder,
	      keyCode: keyCode
	    }));
	    if (this._isSelectOneElement) {
	      this.removeActiveItems(id);
	    }
	    // Trigger change event
	    this.passedElement.triggerEvent(constants_1.EVENTS.addItem, {
	      id: id,
	      value: passedValue,
	      label: passedLabel,
	      customProperties: customProperties,
	      groupValue: group && group.value ? group.value : null,
	      keyCode: keyCode
	    });
	  };
	  Choices.prototype._removeItem = function (item) {
	    var id = item.id,
	      value = item.value,
	      label = item.label,
	      customProperties = item.customProperties,
	      choiceId = item.choiceId,
	      groupId = item.groupId;
	    var group = groupId && groupId >= 0 ? this._store.getGroupById(groupId) : null;
	    if (!id || !choiceId) {
	      return;
	    }
	    this._store.dispatch((0, items_1.removeItem)(id, choiceId));
	    this.passedElement.triggerEvent(constants_1.EVENTS.removeItem, {
	      id: id,
	      value: value,
	      label: label,
	      customProperties: customProperties,
	      groupValue: group && group.value ? group.value : null
	    });
	  };
	  Choices.prototype._addChoice = function (_a) {
	    var value = _a.value,
	      _b = _a.label,
	      label = _b === void 0 ? null : _b,
	      _c = _a.isSelected,
	      isSelected = _c === void 0 ? false : _c,
	      _d = _a.isDisabled,
	      isDisabled = _d === void 0 ? false : _d,
	      _e = _a.groupId,
	      groupId = _e === void 0 ? -1 : _e,
	      _f = _a.customProperties,
	      customProperties = _f === void 0 ? {} : _f,
	      _g = _a.placeholder,
	      placeholder = _g === void 0 ? false : _g,
	      _h = _a.keyCode,
	      keyCode = _h === void 0 ? -1 : _h;
	    if (typeof value === 'undefined' || value === null) {
	      return;
	    }
	    // Generate unique id
	    var choices = this._store.choices;
	    var choiceLabel = label || value;
	    var choiceId = choices ? choices.length + 1 : 1;
	    var choiceElementId = "".concat(this._baseId, "-").concat(this._idNames.itemChoice, "-").concat(choiceId);
	    this._store.dispatch((0, choices_1.addChoice)({
	      id: choiceId,
	      groupId: groupId,
	      elementId: choiceElementId,
	      value: value,
	      label: choiceLabel,
	      disabled: isDisabled,
	      customProperties: customProperties,
	      placeholder: placeholder,
	      keyCode: keyCode
	    }));
	    if (isSelected) {
	      this._addItem({
	        value: value,
	        label: choiceLabel,
	        choiceId: choiceId,
	        customProperties: customProperties,
	        placeholder: placeholder,
	        keyCode: keyCode
	      });
	    }
	  };
	  Choices.prototype._addGroup = function (_a) {
	    var _this = this;
	    var group = _a.group,
	      id = _a.id,
	      _b = _a.valueKey,
	      valueKey = _b === void 0 ? 'value' : _b,
	      _c = _a.labelKey,
	      labelKey = _c === void 0 ? 'label' : _c;
	    var groupChoices = (0, utils_1.isType)('Object', group) ? group.choices : Array.from(group.getElementsByTagName('OPTION'));
	    var groupId = id || Math.floor(new Date().valueOf() * Math.random());
	    var isDisabled = group.disabled ? group.disabled : false;
	    if (groupChoices) {
	      this._store.dispatch((0, groups_1.addGroup)({
	        value: group.label,
	        id: groupId,
	        active: true,
	        disabled: isDisabled
	      }));
	      var addGroupChoices = function (choice) {
	        var isOptDisabled = choice.disabled || choice.parentNode && choice.parentNode.disabled;
	        _this._addChoice({
	          value: choice[valueKey],
	          label: (0, utils_1.isType)('Object', choice) ? choice[labelKey] : choice.innerHTML,
	          isSelected: choice.selected,
	          isDisabled: isOptDisabled,
	          groupId: groupId,
	          customProperties: choice.customProperties,
	          placeholder: choice.placeholder
	        });
	      };
	      groupChoices.forEach(addGroupChoices);
	    } else {
	      this._store.dispatch((0, groups_1.addGroup)({
	        value: group.label,
	        id: group.id,
	        active: false,
	        disabled: group.disabled
	      }));
	    }
	  };
	  Choices.prototype._getTemplate = function (template) {
	    var _a;
	    var args = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	      args[_i - 1] = arguments[_i];
	    }
	    return (_a = this._templates[template]).call.apply(_a, __spreadArray([this, this.config], args, false));
	  };
	  Choices.prototype._createTemplates = function () {
	    var callbackOnCreateTemplates = this.config.callbackOnCreateTemplates;
	    var userTemplates = {};
	    if (callbackOnCreateTemplates && typeof callbackOnCreateTemplates === 'function') {
	      userTemplates = callbackOnCreateTemplates.call(this, utils_1.strToEl);
	    }
	    this._templates = (0, deepmerge_1.default)(templates_1.default, userTemplates);
	  };
	  Choices.prototype._createElements = function () {
	    this.containerOuter = new components_1.Container({
	      element: this._getTemplate('containerOuter', this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type, this.config.labelId),
	      classNames: this.config.classNames,
	      type: this.passedElement.element.type,
	      position: this.config.position
	    });
	    this.containerInner = new components_1.Container({
	      element: this._getTemplate('containerInner'),
	      classNames: this.config.classNames,
	      type: this.passedElement.element.type,
	      position: this.config.position
	    });
	    this.input = new components_1.Input({
	      element: this._getTemplate('input', this._placeholderValue),
	      classNames: this.config.classNames,
	      type: this.passedElement.element.type,
	      preventPaste: !this.config.paste
	    });
	    this.choiceList = new components_1.List({
	      element: this._getTemplate('choiceList', this._isSelectOneElement)
	    });
	    this.itemList = new components_1.List({
	      element: this._getTemplate('itemList', this._isSelectOneElement)
	    });
	    this.dropdown = new components_1.Dropdown({
	      element: this._getTemplate('dropdown'),
	      classNames: this.config.classNames,
	      type: this.passedElement.element.type
	    });
	  };
	  Choices.prototype._createStructure = function () {
	    // Hide original element
	    this.passedElement.conceal();
	    // Wrap input in container preserving DOM ordering
	    this.containerInner.wrap(this.passedElement.element);
	    // Wrapper inner container with outer container
	    this.containerOuter.wrap(this.containerInner.element);
	    if (this._isSelectOneElement) {
	      this.input.placeholder = this.config.searchPlaceholderValue || '';
	    } else if (this._placeholderValue) {
	      this.input.placeholder = this._placeholderValue;
	      this.input.setWidth();
	    }
	    this.containerOuter.element.appendChild(this.containerInner.element);
	    this.containerOuter.element.appendChild(this.dropdown.element);
	    this.containerInner.element.appendChild(this.itemList.element);
	    if (!this._isTextElement) {
	      this.dropdown.element.appendChild(this.choiceList.element);
	    }
	    if (!this._isSelectOneElement) {
	      this.containerInner.element.appendChild(this.input.element);
	    } else if (this.config.searchEnabled) {
	      this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
	    }
	    if (this._isSelectElement) {
	      this._highlightPosition = 0;
	      this._isSearching = false;
	      this._startLoading();
	      if (this._presetGroups.length) {
	        this._addPredefinedGroups(this._presetGroups);
	      } else {
	        this._addPredefinedChoices(this._presetChoices);
	      }
	      this._stopLoading();
	    }
	    if (this._isTextElement) {
	      this._addPredefinedItems(this._presetItems);
	    }
	  };
	  Choices.prototype._addPredefinedGroups = function (groups) {
	    var _this = this;
	    // If we have a placeholder option
	    var placeholderChoice = this.passedElement.placeholderOption;
	    if (placeholderChoice && placeholderChoice.parentNode && placeholderChoice.parentNode.tagName === 'SELECT') {
	      this._addChoice({
	        value: placeholderChoice.value,
	        label: placeholderChoice.innerHTML,
	        isSelected: placeholderChoice.selected,
	        isDisabled: placeholderChoice.disabled,
	        placeholder: true
	      });
	    }
	    groups.forEach(function (group) {
	      return _this._addGroup({
	        group: group,
	        id: group.id || null
	      });
	    });
	  };
	  Choices.prototype._addPredefinedChoices = function (choices) {
	    var _this = this;
	    // If sorting is enabled or the user is searching, filter choices
	    if (this.config.shouldSort) {
	      choices.sort(this.config.sorter);
	    }
	    var hasSelectedChoice = choices.some(function (choice) {
	      return choice.selected;
	    });
	    var firstEnabledChoiceIndex = choices.findIndex(function (choice) {
	      return choice.disabled === undefined || !choice.disabled;
	    });
	    choices.forEach(function (choice, index) {
	      var _a = choice.value,
	        value = _a === void 0 ? '' : _a,
	        label = choice.label,
	        customProperties = choice.customProperties,
	        placeholder = choice.placeholder;
	      if (_this._isSelectElement) {
	        // If the choice is actually a group
	        if (choice.choices) {
	          _this._addGroup({
	            group: choice,
	            id: choice.id || null
	          });
	        } else {
	          /**
	           * If there is a selected choice already or the choice is not the first in
	           * the array, add each choice normally.
	           *
	           * Otherwise we pre-select the first enabled choice in the array ("select-one" only)
	           */
	          var shouldPreselect = _this._isSelectOneElement && !hasSelectedChoice && index === firstEnabledChoiceIndex;
	          var isSelected = shouldPreselect ? true : choice.selected;
	          var isDisabled = choice.disabled;
	          _this._addChoice({
	            value: value,
	            label: label,
	            isSelected: !!isSelected,
	            isDisabled: !!isDisabled,
	            placeholder: !!placeholder,
	            customProperties: customProperties
	          });
	        }
	      } else {
	        _this._addChoice({
	          value: value,
	          label: label,
	          isSelected: !!choice.selected,
	          isDisabled: !!choice.disabled,
	          placeholder: !!choice.placeholder,
	          customProperties: customProperties
	        });
	      }
	    });
	  };
	  Choices.prototype._addPredefinedItems = function (items) {
	    var _this = this;
	    items.forEach(function (item) {
	      if (typeof item === 'object' && item.value) {
	        _this._addItem({
	          value: item.value,
	          label: item.label,
	          choiceId: item.id,
	          customProperties: item.customProperties,
	          placeholder: item.placeholder
	        });
	      }
	      if (typeof item === 'string') {
	        _this._addItem({
	          value: item
	        });
	      }
	    });
	  };
	  Choices.prototype._setChoiceOrItem = function (item) {
	    var _this = this;
	    var itemType = (0, utils_1.getType)(item).toLowerCase();
	    var handleType = {
	      object: function () {
	        if (!item.value) {
	          return;
	        }
	        // If we are dealing with a select input, we need to create an option first
	        // that is then selected. For text inputs we can just add items normally.
	        if (!_this._isTextElement) {
	          _this._addChoice({
	            value: item.value,
	            label: item.label,
	            isSelected: true,
	            isDisabled: false,
	            customProperties: item.customProperties,
	            placeholder: item.placeholder
	          });
	        } else {
	          _this._addItem({
	            value: item.value,
	            label: item.label,
	            choiceId: item.id,
	            customProperties: item.customProperties,
	            placeholder: item.placeholder
	          });
	        }
	      },
	      string: function () {
	        if (!_this._isTextElement) {
	          _this._addChoice({
	            value: item,
	            label: item,
	            isSelected: true,
	            isDisabled: false
	          });
	        } else {
	          _this._addItem({
	            value: item
	          });
	        }
	      }
	    };
	    handleType[itemType]();
	  };
	  Choices.prototype._findAndSelectChoiceByValue = function (value) {
	    var _this = this;
	    var choices = this._store.choices;
	    // Check 'value' property exists and the choice isn't already selected
	    var foundChoice = choices.find(function (choice) {
	      return _this.config.valueComparer(choice.value, value);
	    });
	    if (foundChoice && !foundChoice.selected) {
	      this._addItem({
	        value: foundChoice.value,
	        label: foundChoice.label,
	        choiceId: foundChoice.id,
	        groupId: foundChoice.groupId,
	        customProperties: foundChoice.customProperties,
	        placeholder: foundChoice.placeholder,
	        keyCode: foundChoice.keyCode
	      });
	    }
	  };
	  Choices.prototype._generatePlaceholderValue = function () {
	    if (this._isSelectElement && this.passedElement.placeholderOption) {
	      var placeholderOption = this.passedElement.placeholderOption;
	      return placeholderOption ? placeholderOption.text : null;
	    }
	    var _a = this.config,
	      placeholder = _a.placeholder,
	      placeholderValue = _a.placeholderValue;
	    var dataset = this.passedElement.element.dataset;
	    if (placeholder) {
	      if (placeholderValue) {
	        return placeholderValue;
	      }
	      if (dataset.placeholder) {
	        return dataset.placeholder;
	      }
	    }
	    return null;
	  };
	  return Choices;
	}();
	exports["default"] = Choices;

	/***/ }),

	/***/ 613:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	var utils_1 = __webpack_require__(799);
	var constants_1 = __webpack_require__(883);
	var Container = /** @class */function () {
	  function Container(_a) {
	    var element = _a.element,
	      type = _a.type,
	      classNames = _a.classNames,
	      position = _a.position;
	    this.element = element;
	    this.classNames = classNames;
	    this.type = type;
	    this.position = position;
	    this.isOpen = false;
	    this.isFlipped = false;
	    this.isFocussed = false;
	    this.isDisabled = false;
	    this.isLoading = false;
	    this._onFocus = this._onFocus.bind(this);
	    this._onBlur = this._onBlur.bind(this);
	  }
	  Container.prototype.addEventListeners = function () {
	    this.element.addEventListener('focus', this._onFocus);
	    this.element.addEventListener('blur', this._onBlur);
	  };
	  Container.prototype.removeEventListeners = function () {
	    this.element.removeEventListener('focus', this._onFocus);
	    this.element.removeEventListener('blur', this._onBlur);
	  };
	  /**
	   * Determine whether container should be flipped based on passed
	   * dropdown position
	   */
	  Container.prototype.shouldFlip = function (dropdownPos) {
	    if (typeof dropdownPos !== 'number') {
	      return false;
	    }
	    // If flip is enabled and the dropdown bottom position is
	    // greater than the window height flip the dropdown.
	    var shouldFlip = false;
	    if (this.position === 'auto') {
	      shouldFlip = !window.matchMedia("(min-height: ".concat(dropdownPos + 1, "px)")).matches;
	    } else if (this.position === 'top') {
	      shouldFlip = true;
	    }
	    return shouldFlip;
	  };
	  Container.prototype.setActiveDescendant = function (activeDescendantID) {
	    this.element.setAttribute('aria-activedescendant', activeDescendantID);
	  };
	  Container.prototype.removeActiveDescendant = function () {
	    this.element.removeAttribute('aria-activedescendant');
	  };
	  Container.prototype.open = function (dropdownPos) {
	    this.element.classList.add(this.classNames.openState);
	    this.element.setAttribute('aria-expanded', 'true');
	    this.isOpen = true;
	    if (this.shouldFlip(dropdownPos)) {
	      this.element.classList.add(this.classNames.flippedState);
	      this.isFlipped = true;
	    }
	  };
	  Container.prototype.close = function () {
	    this.element.classList.remove(this.classNames.openState);
	    this.element.setAttribute('aria-expanded', 'false');
	    this.removeActiveDescendant();
	    this.isOpen = false;
	    // A dropdown flips if it does not have space within the page
	    if (this.isFlipped) {
	      this.element.classList.remove(this.classNames.flippedState);
	      this.isFlipped = false;
	    }
	  };
	  Container.prototype.focus = function () {
	    if (!this.isFocussed) {
	      this.element.focus();
	    }
	  };
	  Container.prototype.addFocusState = function () {
	    this.element.classList.add(this.classNames.focusState);
	  };
	  Container.prototype.removeFocusState = function () {
	    this.element.classList.remove(this.classNames.focusState);
	  };
	  Container.prototype.enable = function () {
	    this.element.classList.remove(this.classNames.disabledState);
	    this.element.removeAttribute('aria-disabled');
	    if (this.type === constants_1.SELECT_ONE_TYPE) {
	      this.element.setAttribute('tabindex', '0');
	    }
	    this.isDisabled = false;
	  };
	  Container.prototype.disable = function () {
	    this.element.classList.add(this.classNames.disabledState);
	    this.element.setAttribute('aria-disabled', 'true');
	    if (this.type === constants_1.SELECT_ONE_TYPE) {
	      this.element.setAttribute('tabindex', '-1');
	    }
	    this.isDisabled = true;
	  };
	  Container.prototype.wrap = function (element) {
	    (0, utils_1.wrap)(element, this.element);
	  };
	  Container.prototype.unwrap = function (element) {
	    if (this.element.parentNode) {
	      // Move passed element outside this element
	      this.element.parentNode.insertBefore(element, this.element);
	      // Remove this element
	      this.element.parentNode.removeChild(this.element);
	    }
	  };
	  Container.prototype.addLoadingState = function () {
	    this.element.classList.add(this.classNames.loadingState);
	    this.element.setAttribute('aria-busy', 'true');
	    this.isLoading = true;
	  };
	  Container.prototype.removeLoadingState = function () {
	    this.element.classList.remove(this.classNames.loadingState);
	    this.element.removeAttribute('aria-busy');
	    this.isLoading = false;
	  };
	  Container.prototype._onFocus = function () {
	    this.isFocussed = true;
	  };
	  Container.prototype._onBlur = function () {
	    this.isFocussed = false;
	  };
	  return Container;
	}();
	exports["default"] = Container;

	/***/ }),

	/***/ 217:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	var Dropdown = /** @class */function () {
	  function Dropdown(_a) {
	    var element = _a.element,
	      type = _a.type,
	      classNames = _a.classNames;
	    this.element = element;
	    this.classNames = classNames;
	    this.type = type;
	    this.isActive = false;
	  }
	  Object.defineProperty(Dropdown.prototype, "distanceFromTopWindow", {
	    /**
	     * Bottom position of dropdown in viewport coordinates
	     */
	    get: function () {
	      return this.element.getBoundingClientRect().bottom;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Dropdown.prototype.getChild = function (selector) {
	    return this.element.querySelector(selector);
	  };
	  /**
	   * Show dropdown to user by adding active state class
	   */
	  Dropdown.prototype.show = function () {
	    this.element.classList.add(this.classNames.activeState);
	    this.element.setAttribute('aria-expanded', 'true');
	    this.isActive = true;
	    return this;
	  };
	  /**
	   * Hide dropdown from user
	   */
	  Dropdown.prototype.hide = function () {
	    this.element.classList.remove(this.classNames.activeState);
	    this.element.setAttribute('aria-expanded', 'false');
	    this.isActive = false;
	    return this;
	  };
	  return Dropdown;
	}();
	exports["default"] = Dropdown;

	/***/ }),

	/***/ 520:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	var __importDefault = this && this.__importDefault || function (mod) {
	  return mod && mod.__esModule ? mod : {
	    "default": mod
	  };
	};
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.WrappedSelect = exports.WrappedInput = exports.List = exports.Input = exports.Container = exports.Dropdown = void 0;
	var dropdown_1 = __importDefault(__webpack_require__(217));
	exports.Dropdown = dropdown_1.default;
	var container_1 = __importDefault(__webpack_require__(613));
	exports.Container = container_1.default;
	var input_1 = __importDefault(__webpack_require__(11));
	exports.Input = input_1.default;
	var list_1 = __importDefault(__webpack_require__(624));
	exports.List = list_1.default;
	var wrapped_input_1 = __importDefault(__webpack_require__(541));
	exports.WrappedInput = wrapped_input_1.default;
	var wrapped_select_1 = __importDefault(__webpack_require__(982));
	exports.WrappedSelect = wrapped_select_1.default;

	/***/ }),

	/***/ 11:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	var utils_1 = __webpack_require__(799);
	var constants_1 = __webpack_require__(883);
	var Input = /** @class */function () {
	  function Input(_a) {
	    var element = _a.element,
	      type = _a.type,
	      classNames = _a.classNames,
	      preventPaste = _a.preventPaste;
	    this.element = element;
	    this.type = type;
	    this.classNames = classNames;
	    this.preventPaste = preventPaste;
	    this.isFocussed = this.element.isEqualNode(document.activeElement);
	    this.isDisabled = element.disabled;
	    this._onPaste = this._onPaste.bind(this);
	    this._onInput = this._onInput.bind(this);
	    this._onFocus = this._onFocus.bind(this);
	    this._onBlur = this._onBlur.bind(this);
	  }
	  Object.defineProperty(Input.prototype, "placeholder", {
	    set: function (placeholder) {
	      this.element.placeholder = placeholder;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Input.prototype, "value", {
	    get: function () {
	      return (0, utils_1.sanitise)(this.element.value);
	    },
	    set: function (value) {
	      this.element.value = value;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Input.prototype, "rawValue", {
	    get: function () {
	      return this.element.value;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Input.prototype.addEventListeners = function () {
	    this.element.addEventListener('paste', this._onPaste);
	    this.element.addEventListener('input', this._onInput, {
	      passive: true
	    });
	    this.element.addEventListener('focus', this._onFocus, {
	      passive: true
	    });
	    this.element.addEventListener('blur', this._onBlur, {
	      passive: true
	    });
	  };
	  Input.prototype.removeEventListeners = function () {
	    this.element.removeEventListener('input', this._onInput);
	    this.element.removeEventListener('paste', this._onPaste);
	    this.element.removeEventListener('focus', this._onFocus);
	    this.element.removeEventListener('blur', this._onBlur);
	  };
	  Input.prototype.enable = function () {
	    this.element.removeAttribute('disabled');
	    this.isDisabled = false;
	  };
	  Input.prototype.disable = function () {
	    this.element.setAttribute('disabled', '');
	    this.isDisabled = true;
	  };
	  Input.prototype.focus = function () {
	    if (!this.isFocussed) {
	      this.element.focus();
	    }
	  };
	  Input.prototype.blur = function () {
	    if (this.isFocussed) {
	      this.element.blur();
	    }
	  };
	  Input.prototype.clear = function (setWidth) {
	    if (setWidth === void 0) {
	      setWidth = true;
	    }
	    if (this.element.value) {
	      this.element.value = '';
	    }
	    if (setWidth) {
	      this.setWidth();
	    }
	    return this;
	  };
	  /**
	   * Set the correct input width based on placeholder
	   * value or input value
	   */
	  Input.prototype.setWidth = function () {
	    // Resize input to contents or placeholder
	    var _a = this.element,
	      style = _a.style,
	      value = _a.value,
	      placeholder = _a.placeholder;
	    style.minWidth = "".concat(placeholder.length + 1, "ch");
	    style.width = "".concat(value.length + 1, "ch");
	  };
	  Input.prototype.setActiveDescendant = function (activeDescendantID) {
	    this.element.setAttribute('aria-activedescendant', activeDescendantID);
	  };
	  Input.prototype.removeActiveDescendant = function () {
	    this.element.removeAttribute('aria-activedescendant');
	  };
	  Input.prototype._onInput = function () {
	    if (this.type !== constants_1.SELECT_ONE_TYPE) {
	      this.setWidth();
	    }
	  };
	  Input.prototype._onPaste = function (event) {
	    if (this.preventPaste) {
	      event.preventDefault();
	    }
	  };
	  Input.prototype._onFocus = function () {
	    this.isFocussed = true;
	  };
	  Input.prototype._onBlur = function () {
	    this.isFocussed = false;
	  };
	  return Input;
	}();
	exports["default"] = Input;

	/***/ }),

	/***/ 624:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	var constants_1 = __webpack_require__(883);
	var List = /** @class */function () {
	  function List(_a) {
	    var element = _a.element;
	    this.element = element;
	    this.scrollPos = this.element.scrollTop;
	    this.height = this.element.offsetHeight;
	  }
	  List.prototype.clear = function () {
	    this.element.innerHTML = '';
	  };
	  List.prototype.append = function (node) {
	    this.element.appendChild(node);
	  };
	  List.prototype.getChild = function (selector) {
	    return this.element.querySelector(selector);
	  };
	  List.prototype.hasChildren = function () {
	    return this.element.hasChildNodes();
	  };
	  List.prototype.scrollToTop = function () {
	    this.element.scrollTop = 0;
	  };
	  List.prototype.scrollToChildElement = function (element, direction) {
	    var _this = this;
	    if (!element) {
	      return;
	    }
	    var listHeight = this.element.offsetHeight;
	    // Scroll position of dropdown
	    var listScrollPosition = this.element.scrollTop + listHeight;
	    var elementHeight = element.offsetHeight;
	    // Distance from bottom of element to top of parent
	    var elementPos = element.offsetTop + elementHeight;
	    // Difference between the element and scroll position
	    var destination = direction > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;
	    requestAnimationFrame(function () {
	      _this._animateScroll(destination, direction);
	    });
	  };
	  List.prototype._scrollDown = function (scrollPos, strength, destination) {
	    var easing = (destination - scrollPos) / strength;
	    var distance = easing > 1 ? easing : 1;
	    this.element.scrollTop = scrollPos + distance;
	  };
	  List.prototype._scrollUp = function (scrollPos, strength, destination) {
	    var easing = (scrollPos - destination) / strength;
	    var distance = easing > 1 ? easing : 1;
	    this.element.scrollTop = scrollPos - distance;
	  };
	  List.prototype._animateScroll = function (destination, direction) {
	    var _this = this;
	    var strength = constants_1.SCROLLING_SPEED;
	    var choiceListScrollTop = this.element.scrollTop;
	    var continueAnimation = false;
	    if (direction > 0) {
	      this._scrollDown(choiceListScrollTop, strength, destination);
	      if (choiceListScrollTop < destination) {
	        continueAnimation = true;
	      }
	    } else {
	      this._scrollUp(choiceListScrollTop, strength, destination);
	      if (choiceListScrollTop > destination) {
	        continueAnimation = true;
	      }
	    }
	    if (continueAnimation) {
	      requestAnimationFrame(function () {
	        _this._animateScroll(destination, direction);
	      });
	    }
	  };
	  return List;
	}();
	exports["default"] = List;

	/***/ }),

	/***/ 730:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	var utils_1 = __webpack_require__(799);
	var WrappedElement = /** @class */function () {
	  function WrappedElement(_a) {
	    var element = _a.element,
	      classNames = _a.classNames;
	    this.element = element;
	    this.classNames = classNames;
	    if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLSelectElement)) {
	      throw new TypeError('Invalid element passed');
	    }
	    this.isDisabled = false;
	  }
	  Object.defineProperty(WrappedElement.prototype, "isActive", {
	    get: function () {
	      return this.element.dataset.choice === 'active';
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(WrappedElement.prototype, "dir", {
	    get: function () {
	      return this.element.dir;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(WrappedElement.prototype, "value", {
	    get: function () {
	      return this.element.value;
	    },
	    set: function (value) {
	      // you must define setter here otherwise it will be readonly property
	      this.element.value = value;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  WrappedElement.prototype.conceal = function () {
	    // Hide passed input
	    this.element.classList.add(this.classNames.input);
	    this.element.hidden = true;
	    // Remove element from tab index
	    this.element.tabIndex = -1;
	    // Backup original styles if any
	    var origStyle = this.element.getAttribute('style');
	    if (origStyle) {
	      this.element.setAttribute('data-choice-orig-style', origStyle);
	    }
	    this.element.setAttribute('data-choice', 'active');
	  };
	  WrappedElement.prototype.reveal = function () {
	    // Reinstate passed element
	    this.element.classList.remove(this.classNames.input);
	    this.element.hidden = false;
	    this.element.removeAttribute('tabindex');
	    // Recover original styles if any
	    var origStyle = this.element.getAttribute('data-choice-orig-style');
	    if (origStyle) {
	      this.element.removeAttribute('data-choice-orig-style');
	      this.element.setAttribute('style', origStyle);
	    } else {
	      this.element.removeAttribute('style');
	    }
	    this.element.removeAttribute('data-choice');
	    // Re-assign values - this is weird, I know
	    // @todo Figure out why we need to do this
	    this.element.value = this.element.value; // eslint-disable-line no-self-assign
	  };

	  WrappedElement.prototype.enable = function () {
	    this.element.removeAttribute('disabled');
	    this.element.disabled = false;
	    this.isDisabled = false;
	  };
	  WrappedElement.prototype.disable = function () {
	    this.element.setAttribute('disabled', '');
	    this.element.disabled = true;
	    this.isDisabled = true;
	  };
	  WrappedElement.prototype.triggerEvent = function (eventType, data) {
	    (0, utils_1.dispatchEvent)(this.element, eventType, data);
	  };
	  return WrappedElement;
	}();
	exports["default"] = WrappedElement;

	/***/ }),

	/***/ 541:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	var __extends = this && this.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	var __importDefault = this && this.__importDefault || function (mod) {
	  return mod && mod.__esModule ? mod : {
	    "default": mod
	  };
	};
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	var wrapped_element_1 = __importDefault(__webpack_require__(730));
	var WrappedInput = /** @class */function (_super) {
	  __extends(WrappedInput, _super);
	  function WrappedInput(_a) {
	    var element = _a.element,
	      classNames = _a.classNames,
	      delimiter = _a.delimiter;
	    var _this = _super.call(this, {
	      element: element,
	      classNames: classNames
	    }) || this;
	    _this.delimiter = delimiter;
	    return _this;
	  }
	  Object.defineProperty(WrappedInput.prototype, "value", {
	    get: function () {
	      return this.element.value;
	    },
	    set: function (value) {
	      this.element.setAttribute('value', value);
	      this.element.value = value;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  return WrappedInput;
	}(wrapped_element_1.default);
	exports["default"] = WrappedInput;

	/***/ }),

	/***/ 982:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	var __extends = this && this.__extends || function () {
	  var extendStatics = function (d, b) {
	    extendStatics = Object.setPrototypeOf || {
	      __proto__: []
	    } instanceof Array && function (d, b) {
	      d.__proto__ = b;
	    } || function (d, b) {
	      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
	    };
	    return extendStatics(d, b);
	  };
	  return function (d, b) {
	    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	    extendStatics(d, b);
	    function __() {
	      this.constructor = d;
	    }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	  };
	}();
	var __importDefault = this && this.__importDefault || function (mod) {
	  return mod && mod.__esModule ? mod : {
	    "default": mod
	  };
	};
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	var wrapped_element_1 = __importDefault(__webpack_require__(730));
	var WrappedSelect = /** @class */function (_super) {
	  __extends(WrappedSelect, _super);
	  function WrappedSelect(_a) {
	    var element = _a.element,
	      classNames = _a.classNames,
	      template = _a.template;
	    var _this = _super.call(this, {
	      element: element,
	      classNames: classNames
	    }) || this;
	    _this.template = template;
	    return _this;
	  }
	  Object.defineProperty(WrappedSelect.prototype, "placeholderOption", {
	    get: function () {
	      return this.element.querySelector('option[value=""]') ||
	      // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.
	      this.element.querySelector('option[placeholder]');
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(WrappedSelect.prototype, "optionGroups", {
	    get: function () {
	      return Array.from(this.element.getElementsByTagName('OPTGROUP'));
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(WrappedSelect.prototype, "options", {
	    get: function () {
	      return Array.from(this.element.options);
	    },
	    set: function (options) {
	      var _this = this;
	      var fragment = document.createDocumentFragment();
	      var addOptionToFragment = function (data) {
	        // Create a standard select option
	        var option = _this.template(data);
	        // Append it to fragment
	        fragment.appendChild(option);
	      };
	      // Add each list item to list
	      options.forEach(function (optionData) {
	        return addOptionToFragment(optionData);
	      });
	      this.appendDocFragment(fragment);
	    },
	    enumerable: false,
	    configurable: true
	  });
	  WrappedSelect.prototype.appendDocFragment = function (fragment) {
	    this.element.innerHTML = '';
	    this.element.appendChild(fragment);
	  };
	  return WrappedSelect;
	}(wrapped_element_1.default);
	exports["default"] = WrappedSelect;

	/***/ }),

	/***/ 883:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.SCROLLING_SPEED = exports.SELECT_MULTIPLE_TYPE = exports.SELECT_ONE_TYPE = exports.TEXT_TYPE = exports.KEY_CODES = exports.ACTION_TYPES = exports.EVENTS = void 0;
	exports.EVENTS = {
	  showDropdown: 'showDropdown',
	  hideDropdown: 'hideDropdown',
	  change: 'change',
	  choice: 'choice',
	  search: 'search',
	  addItem: 'addItem',
	  removeItem: 'removeItem',
	  highlightItem: 'highlightItem',
	  highlightChoice: 'highlightChoice',
	  unhighlightItem: 'unhighlightItem'
	};
	exports.ACTION_TYPES = {
	  ADD_CHOICE: 'ADD_CHOICE',
	  FILTER_CHOICES: 'FILTER_CHOICES',
	  ACTIVATE_CHOICES: 'ACTIVATE_CHOICES',
	  CLEAR_CHOICES: 'CLEAR_CHOICES',
	  ADD_GROUP: 'ADD_GROUP',
	  ADD_ITEM: 'ADD_ITEM',
	  REMOVE_ITEM: 'REMOVE_ITEM',
	  HIGHLIGHT_ITEM: 'HIGHLIGHT_ITEM',
	  CLEAR_ALL: 'CLEAR_ALL',
	  RESET_TO: 'RESET_TO',
	  SET_IS_LOADING: 'SET_IS_LOADING'
	};
	exports.KEY_CODES = {
	  BACK_KEY: 46,
	  DELETE_KEY: 8,
	  ENTER_KEY: 13,
	  A_KEY: 65,
	  ESC_KEY: 27,
	  UP_KEY: 38,
	  DOWN_KEY: 40,
	  PAGE_UP_KEY: 33,
	  PAGE_DOWN_KEY: 34
	};
	exports.TEXT_TYPE = 'text';
	exports.SELECT_ONE_TYPE = 'select-one';
	exports.SELECT_MULTIPLE_TYPE = 'select-multiple';
	exports.SCROLLING_SPEED = 4;

	/***/ }),

	/***/ 789:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.DEFAULT_CONFIG = exports.DEFAULT_CLASSNAMES = void 0;
	var utils_1 = __webpack_require__(799);
	exports.DEFAULT_CLASSNAMES = {
	  containerOuter: 'choices',
	  containerInner: 'choices__inner',
	  input: 'choices__input',
	  inputCloned: 'choices__input--cloned',
	  list: 'choices__list',
	  listItems: 'choices__list--multiple',
	  listSingle: 'choices__list--single',
	  listDropdown: 'choices__list--dropdown',
	  item: 'choices__item',
	  itemSelectable: 'choices__item--selectable',
	  itemDisabled: 'choices__item--disabled',
	  itemChoice: 'choices__item--choice',
	  placeholder: 'choices__placeholder',
	  group: 'choices__group',
	  groupHeading: 'choices__heading',
	  button: 'choices__button',
	  activeState: 'is-active',
	  focusState: 'is-focused',
	  openState: 'is-open',
	  disabledState: 'is-disabled',
	  highlightedState: 'is-highlighted',
	  selectedState: 'is-selected',
	  flippedState: 'is-flipped',
	  loadingState: 'is-loading',
	  noResults: 'has-no-results',
	  noChoices: 'has-no-choices'
	};
	exports.DEFAULT_CONFIG = {
	  items: [],
	  choices: [],
	  silent: false,
	  renderChoiceLimit: -1,
	  maxItemCount: -1,
	  addItems: true,
	  addItemFilter: null,
	  removeItems: true,
	  removeItemButton: false,
	  editItems: false,
	  allowHTML: true,
	  duplicateItemsAllowed: true,
	  delimiter: ',',
	  paste: true,
	  searchEnabled: true,
	  searchChoices: true,
	  searchFloor: 1,
	  searchResultLimit: 4,
	  searchFields: ['label', 'value'],
	  position: 'auto',
	  resetScrollPosition: true,
	  shouldSort: true,
	  shouldSortItems: false,
	  sorter: utils_1.sortByAlpha,
	  placeholder: true,
	  placeholderValue: null,
	  searchPlaceholderValue: null,
	  prependValue: null,
	  appendValue: null,
	  renderSelectedChoices: 'auto',
	  loadingText: 'Loading...',
	  noResultsText: 'No results found',
	  noChoicesText: 'No choices to choose from',
	  itemSelectText: 'Press to select',
	  uniqueItemText: 'Only unique values can be added',
	  customAddItemText: 'Only values matching specific conditions can be added',
	  addItemText: function (value) {
	    return "Press Enter to add <b>\"".concat((0, utils_1.sanitise)(value), "\"</b>");
	  },
	  maxItemText: function (maxItemCount) {
	    return "Only ".concat(maxItemCount, " values can be added");
	  },
	  valueComparer: function (value1, value2) {
	    return value1 === value2;
	  },
	  fuseOptions: {
	    includeScore: true
	  },
	  labelId: '',
	  callbackOnInit: null,
	  callbackOnCreateTemplates: null,
	  classNames: exports.DEFAULT_CLASSNAMES
	};

	/***/ }),

	/***/ 18:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 978:
	/***/ (function(__unused_webpack_module, exports) {



	/* eslint-disable @typescript-eslint/no-explicit-any */
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 948:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 359:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 285:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 533:
	/***/ (function(__unused_webpack_module, exports) {



	/* eslint-disable @typescript-eslint/no-explicit-any */
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 187:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
	  if (k2 === undefined) k2 = k;
	  var desc = Object.getOwnPropertyDescriptor(m, k);
	  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	    desc = {
	      enumerable: true,
	      get: function () {
	        return m[k];
	      }
	    };
	  }
	  Object.defineProperty(o, k2, desc);
	} : function (o, m, k, k2) {
	  if (k2 === undefined) k2 = k;
	  o[k2] = m[k];
	});
	var __exportStar = this && this.__exportStar || function (m, exports) {
	  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	__exportStar(__webpack_require__(18), exports);
	__exportStar(__webpack_require__(978), exports);
	__exportStar(__webpack_require__(948), exports);
	__exportStar(__webpack_require__(359), exports);
	__exportStar(__webpack_require__(285), exports);
	__exportStar(__webpack_require__(533), exports);
	__exportStar(__webpack_require__(287), exports);
	__exportStar(__webpack_require__(132), exports);
	__exportStar(__webpack_require__(837), exports);
	__exportStar(__webpack_require__(598), exports);
	__exportStar(__webpack_require__(369), exports);
	__exportStar(__webpack_require__(37), exports);
	__exportStar(__webpack_require__(47), exports);
	__exportStar(__webpack_require__(923), exports);
	__exportStar(__webpack_require__(876), exports);

	/***/ }),

	/***/ 287:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 132:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 837:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 598:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 37:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 369:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 47:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 923:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 876:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));

	/***/ }),

	/***/ 799:
	/***/ (function(__unused_webpack_module, exports) {



	/* eslint-disable @typescript-eslint/no-explicit-any */
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.parseCustomProperties = exports.diff = exports.cloneObject = exports.existsInArray = exports.dispatchEvent = exports.sortByScore = exports.sortByAlpha = exports.strToEl = exports.sanitise = exports.isScrolledIntoView = exports.getAdjacentEl = exports.wrap = exports.isType = exports.getType = exports.generateId = exports.generateChars = exports.getRandomNumber = void 0;
	var getRandomNumber = function (min, max) {
	  return Math.floor(Math.random() * (max - min) + min);
	};
	exports.getRandomNumber = getRandomNumber;
	var generateChars = function (length) {
	  return Array.from({
	    length: length
	  }, function () {
	    return (0, exports.getRandomNumber)(0, 36).toString(36);
	  }).join('');
	};
	exports.generateChars = generateChars;
	var generateId = function (element, prefix) {
	  var id = element.id || element.name && "".concat(element.name, "-").concat((0, exports.generateChars)(2)) || (0, exports.generateChars)(4);
	  id = id.replace(/(:|\.|\[|\]|,)/g, '');
	  id = "".concat(prefix, "-").concat(id);
	  return id;
	};
	exports.generateId = generateId;
	var getType = function (obj) {
	  return Object.prototype.toString.call(obj).slice(8, -1);
	};
	exports.getType = getType;
	var isType = function (type, obj) {
	  return obj !== undefined && obj !== null && (0, exports.getType)(obj) === type;
	};
	exports.isType = isType;
	var wrap = function (element, wrapper) {
	  if (wrapper === void 0) {
	    wrapper = document.createElement('div');
	  }
	  if (element.parentNode) {
	    if (element.nextSibling) {
	      element.parentNode.insertBefore(wrapper, element.nextSibling);
	    } else {
	      element.parentNode.appendChild(wrapper);
	    }
	  }
	  return wrapper.appendChild(element);
	};
	exports.wrap = wrap;
	var getAdjacentEl = function (startEl, selector, direction) {
	  if (direction === void 0) {
	    direction = 1;
	  }
	  var prop = "".concat(direction > 0 ? 'next' : 'previous', "ElementSibling");
	  var sibling = startEl[prop];
	  while (sibling) {
	    if (sibling.matches(selector)) {
	      return sibling;
	    }
	    sibling = sibling[prop];
	  }
	  return sibling;
	};
	exports.getAdjacentEl = getAdjacentEl;
	var isScrolledIntoView = function (element, parent, direction) {
	  if (direction === void 0) {
	    direction = 1;
	  }
	  if (!element) {
	    return false;
	  }
	  var isVisible;
	  if (direction > 0) {
	    // In view from bottom
	    isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;
	  } else {
	    // In view from top
	    isVisible = element.offsetTop >= parent.scrollTop;
	  }
	  return isVisible;
	};
	exports.isScrolledIntoView = isScrolledIntoView;
	var sanitise = function (value) {
	  if (typeof value !== 'string') {
	    return value;
	  }
	  return value.replace(/&/g, '&amp;').replace(/>/g, '&gt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
	};
	exports.sanitise = sanitise;
	exports.strToEl = function () {
	  var tmpEl = document.createElement('div');
	  return function (str) {
	    var cleanedInput = str.trim();
	    tmpEl.innerHTML = cleanedInput;
	    var firldChild = tmpEl.children[0];
	    while (tmpEl.firstChild) {
	      tmpEl.removeChild(tmpEl.firstChild);
	    }
	    return firldChild;
	  };
	}();
	var sortByAlpha = function (_a, _b) {
	  var value = _a.value,
	    _c = _a.label,
	    label = _c === void 0 ? value : _c;
	  var value2 = _b.value,
	    _d = _b.label,
	    label2 = _d === void 0 ? value2 : _d;
	  return label.localeCompare(label2, [], {
	    sensitivity: 'base',
	    ignorePunctuation: true,
	    numeric: true
	  });
	};
	exports.sortByAlpha = sortByAlpha;
	var sortByScore = function (a, b) {
	  var _a = a.score,
	    scoreA = _a === void 0 ? 0 : _a;
	  var _b = b.score,
	    scoreB = _b === void 0 ? 0 : _b;
	  return scoreA - scoreB;
	};
	exports.sortByScore = sortByScore;
	var dispatchEvent = function (element, type, customArgs) {
	  if (customArgs === void 0) {
	    customArgs = null;
	  }
	  var event = new CustomEvent(type, {
	    detail: customArgs,
	    bubbles: true,
	    cancelable: true
	  });
	  return element.dispatchEvent(event);
	};
	exports.dispatchEvent = dispatchEvent;
	var existsInArray = function (array, value, key) {
	  if (key === void 0) {
	    key = 'value';
	  }
	  return array.some(function (item) {
	    if (typeof value === 'string') {
	      return item[key] === value.trim();
	    }
	    return item[key] === value;
	  });
	};
	exports.existsInArray = existsInArray;
	var cloneObject = function (obj) {
	  return JSON.parse(JSON.stringify(obj));
	};
	exports.cloneObject = cloneObject;
	/**
	 * Returns an array of keys present on the first but missing on the second object
	 */
	var diff = function (a, b) {
	  var aKeys = Object.keys(a).sort();
	  var bKeys = Object.keys(b).sort();
	  return aKeys.filter(function (i) {
	    return bKeys.indexOf(i) < 0;
	  });
	};
	exports.diff = diff;
	var parseCustomProperties = function (customProperties) {
	  if (typeof customProperties !== 'undefined') {
	    try {
	      return JSON.parse(customProperties);
	    } catch (e) {
	      return customProperties;
	    }
	  }
	  return {};
	};
	exports.parseCustomProperties = parseCustomProperties;

	/***/ }),

	/***/ 273:
	/***/ (function(__unused_webpack_module, exports) {



	var __spreadArray = this && this.__spreadArray || function (to, from, pack) {
	  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	    if (ar || !(i in from)) {
	      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	      ar[i] = from[i];
	    }
	  }
	  return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.defaultState = void 0;
	exports.defaultState = [];
	function choices(state, action) {
	  if (state === void 0) {
	    state = exports.defaultState;
	  }
	  if (action === void 0) {
	    action = {};
	  }
	  switch (action.type) {
	    case 'ADD_CHOICE':
	      {
	        var addChoiceAction = action;
	        var choice = {
	          id: addChoiceAction.id,
	          elementId: addChoiceAction.elementId,
	          groupId: addChoiceAction.groupId,
	          value: addChoiceAction.value,
	          label: addChoiceAction.label || addChoiceAction.value,
	          disabled: addChoiceAction.disabled || false,
	          selected: false,
	          active: true,
	          score: 9999,
	          customProperties: addChoiceAction.customProperties,
	          placeholder: addChoiceAction.placeholder || false
	        };
	        /*
	          A disabled choice appears in the choice dropdown but cannot be selected
	          A selected choice has been added to the passed input's value (added as an item)
	          An active choice appears within the choice dropdown
	        */
	        return __spreadArray(__spreadArray([], state, true), [choice], false);
	      }
	    case 'ADD_ITEM':
	      {
	        var addItemAction_1 = action;
	        // When an item is added and it has an associated choice,
	        // we want to disable it so it can't be chosen again
	        if (addItemAction_1.choiceId > -1) {
	          return state.map(function (obj) {
	            var choice = obj;
	            if (choice.id === parseInt("".concat(addItemAction_1.choiceId), 10)) {
	              choice.selected = true;
	            }
	            return choice;
	          });
	        }
	        return state;
	      }
	    case 'REMOVE_ITEM':
	      {
	        var removeItemAction_1 = action;
	        // When an item is removed and it has an associated choice,
	        // we want to re-enable it so it can be chosen again
	        if (removeItemAction_1.choiceId && removeItemAction_1.choiceId > -1) {
	          return state.map(function (obj) {
	            var choice = obj;
	            if (choice.id === parseInt("".concat(removeItemAction_1.choiceId), 10)) {
	              choice.selected = false;
	            }
	            return choice;
	          });
	        }
	        return state;
	      }
	    case 'FILTER_CHOICES':
	      {
	        var filterChoicesAction_1 = action;
	        return state.map(function (obj) {
	          var choice = obj;
	          // Set active state based on whether choice is
	          // within filtered results
	          choice.active = filterChoicesAction_1.results.some(function (_a) {
	            var item = _a.item,
	              score = _a.score;
	            if (item.id === choice.id) {
	              choice.score = score;
	              return true;
	            }
	            return false;
	          });
	          return choice;
	        });
	      }
	    case 'ACTIVATE_CHOICES':
	      {
	        var activateChoicesAction_1 = action;
	        return state.map(function (obj) {
	          var choice = obj;
	          choice.active = activateChoicesAction_1.active;
	          return choice;
	        });
	      }
	    case 'CLEAR_CHOICES':
	      {
	        return exports.defaultState;
	      }
	    default:
	      {
	        return state;
	      }
	  }
	}
	exports["default"] = choices;

	/***/ }),

	/***/ 871:
	/***/ (function(__unused_webpack_module, exports) {



	var __spreadArray = this && this.__spreadArray || function (to, from, pack) {
	  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	    if (ar || !(i in from)) {
	      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	      ar[i] = from[i];
	    }
	  }
	  return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.defaultState = void 0;
	exports.defaultState = [];
	function groups(state, action) {
	  if (state === void 0) {
	    state = exports.defaultState;
	  }
	  if (action === void 0) {
	    action = {};
	  }
	  switch (action.type) {
	    case 'ADD_GROUP':
	      {
	        var addGroupAction = action;
	        return __spreadArray(__spreadArray([], state, true), [{
	          id: addGroupAction.id,
	          value: addGroupAction.value,
	          active: addGroupAction.active,
	          disabled: addGroupAction.disabled
	        }], false);
	      }
	    case 'CLEAR_CHOICES':
	      {
	        return [];
	      }
	    default:
	      {
	        return state;
	      }
	  }
	}
	exports["default"] = groups;

	/***/ }),

	/***/ 655:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	var __importDefault = this && this.__importDefault || function (mod) {
	  return mod && mod.__esModule ? mod : {
	    "default": mod
	  };
	};
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.defaultState = void 0;
	var redux_1 = __webpack_require__(791);
	var items_1 = __importDefault(__webpack_require__(52));
	var groups_1 = __importDefault(__webpack_require__(871));
	var choices_1 = __importDefault(__webpack_require__(273));
	var loading_1 = __importDefault(__webpack_require__(502));
	var utils_1 = __webpack_require__(799);
	exports.defaultState = {
	  groups: [],
	  items: [],
	  choices: [],
	  loading: false
	};
	var appReducer = (0, redux_1.combineReducers)({
	  items: items_1.default,
	  groups: groups_1.default,
	  choices: choices_1.default,
	  loading: loading_1.default
	});
	var rootReducer = function (passedState, action) {
	  var state = passedState;
	  // If we are clearing all items, groups and options we reassign
	  // state and then pass that state to our proper reducer. This isn't
	  // mutating our actual state
	  // See: http://stackoverflow.com/a/35641992
	  if (action.type === 'CLEAR_ALL') {
	    state = exports.defaultState;
	  } else if (action.type === 'RESET_TO') {
	    return (0, utils_1.cloneObject)(action.state);
	  }
	  return appReducer(state, action);
	};
	exports["default"] = rootReducer;

	/***/ }),

	/***/ 52:
	/***/ (function(__unused_webpack_module, exports) {



	var __spreadArray = this && this.__spreadArray || function (to, from, pack) {
	  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	    if (ar || !(i in from)) {
	      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	      ar[i] = from[i];
	    }
	  }
	  return to.concat(ar || Array.prototype.slice.call(from));
	};
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.defaultState = void 0;
	exports.defaultState = [];
	function items(state, action) {
	  if (state === void 0) {
	    state = exports.defaultState;
	  }
	  if (action === void 0) {
	    action = {};
	  }
	  switch (action.type) {
	    case 'ADD_ITEM':
	      {
	        var addItemAction = action;
	        // Add object to items array
	        var newState = __spreadArray(__spreadArray([], state, true), [{
	          id: addItemAction.id,
	          choiceId: addItemAction.choiceId,
	          groupId: addItemAction.groupId,
	          value: addItemAction.value,
	          label: addItemAction.label,
	          active: true,
	          highlighted: false,
	          customProperties: addItemAction.customProperties,
	          placeholder: addItemAction.placeholder || false,
	          keyCode: null
	        }], false);
	        return newState.map(function (obj) {
	          var item = obj;
	          item.highlighted = false;
	          return item;
	        });
	      }
	    case 'REMOVE_ITEM':
	      {
	        // Set item to inactive
	        return state.map(function (obj) {
	          var item = obj;
	          if (item.id === action.id) {
	            item.active = false;
	          }
	          return item;
	        });
	      }
	    case 'HIGHLIGHT_ITEM':
	      {
	        var highlightItemAction_1 = action;
	        return state.map(function (obj) {
	          var item = obj;
	          if (item.id === highlightItemAction_1.id) {
	            item.highlighted = highlightItemAction_1.highlighted;
	          }
	          return item;
	        });
	      }
	    default:
	      {
	        return state;
	      }
	  }
	}
	exports["default"] = items;

	/***/ }),

	/***/ 502:
	/***/ (function(__unused_webpack_module, exports) {



	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	exports.defaultState = void 0;
	exports.defaultState = false;
	var general = function (state, action) {
	  if (state === void 0) {
	    state = exports.defaultState;
	  }
	  if (action === void 0) {
	    action = {};
	  }
	  switch (action.type) {
	    case 'SET_IS_LOADING':
	      {
	        return action.isLoading;
	      }
	    default:
	      {
	        return state;
	      }
	  }
	};
	exports["default"] = general;

	/***/ }),

	/***/ 744:
	/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



	var __spreadArray = this && this.__spreadArray || function (to, from, pack) {
	  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	    if (ar || !(i in from)) {
	      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	      ar[i] = from[i];
	    }
	  }
	  return to.concat(ar || Array.prototype.slice.call(from));
	};
	var __importDefault = this && this.__importDefault || function (mod) {
	  return mod && mod.__esModule ? mod : {
	    "default": mod
	  };
	};
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	/* eslint-disable @typescript-eslint/no-explicit-any */
	var redux_1 = __webpack_require__(791);
	var index_1 = __importDefault(__webpack_require__(655));
	var Store = /** @class */function () {
	  function Store() {
	    this._store = (0, redux_1.createStore)(index_1.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
	  }
	  /**
	   * Subscribe store to function call (wrapped Redux method)
	   */
	  Store.prototype.subscribe = function (onChange) {
	    this._store.subscribe(onChange);
	  };
	  /**
	   * Dispatch event to store (wrapped Redux method)
	   */
	  Store.prototype.dispatch = function (action) {
	    this._store.dispatch(action);
	  };
	  Object.defineProperty(Store.prototype, "state", {
	    /**
	     * Get store object (wrapping Redux method)
	     */
	    get: function () {
	      return this._store.getState();
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Store.prototype, "items", {
	    /**
	     * Get items from store
	     */
	    get: function () {
	      return this.state.items;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Store.prototype, "activeItems", {
	    /**
	     * Get active items from store
	     */
	    get: function () {
	      return this.items.filter(function (item) {
	        return item.active === true;
	      });
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Store.prototype, "highlightedActiveItems", {
	    /**
	     * Get highlighted items from store
	     */
	    get: function () {
	      return this.items.filter(function (item) {
	        return item.active && item.highlighted;
	      });
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Store.prototype, "choices", {
	    /**
	     * Get choices from store
	     */
	    get: function () {
	      return this.state.choices;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Store.prototype, "activeChoices", {
	    /**
	     * Get active choices from store
	     */
	    get: function () {
	      return this.choices.filter(function (choice) {
	        return choice.active === true;
	      });
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Store.prototype, "selectableChoices", {
	    /**
	     * Get selectable choices from store
	     */
	    get: function () {
	      return this.choices.filter(function (choice) {
	        return choice.disabled !== true;
	      });
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Store.prototype, "searchableChoices", {
	    /**
	     * Get choices that can be searched (excluding placeholders)
	     */
	    get: function () {
	      return this.selectableChoices.filter(function (choice) {
	        return choice.placeholder !== true;
	      });
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Store.prototype, "placeholderChoice", {
	    /**
	     * Get placeholder choice from store
	     */
	    get: function () {
	      return __spreadArray([], this.choices, true).reverse().find(function (choice) {
	        return choice.placeholder === true;
	      });
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Store.prototype, "groups", {
	    /**
	     * Get groups from store
	     */
	    get: function () {
	      return this.state.groups;
	    },
	    enumerable: false,
	    configurable: true
	  });
	  Object.defineProperty(Store.prototype, "activeGroups", {
	    /**
	     * Get active groups from store
	     */
	    get: function () {
	      var _a = this,
	        groups = _a.groups,
	        choices = _a.choices;
	      return groups.filter(function (group) {
	        var isActive = group.active === true && group.disabled === false;
	        var hasActiveOptions = choices.some(function (choice) {
	          return choice.active === true && choice.disabled === false;
	        });
	        return isActive && hasActiveOptions;
	      }, []);
	    },
	    enumerable: false,
	    configurable: true
	  });
	  /**
	   * Get loading state from store
	   */
	  Store.prototype.isLoading = function () {
	    return this.state.loading;
	  };
	  /**
	   * Get single choice by it's ID
	   */
	  Store.prototype.getChoiceById = function (id) {
	    return this.activeChoices.find(function (choice) {
	      return choice.id === parseInt(id, 10);
	    });
	  };
	  /**
	   * Get group by group id
	   */
	  Store.prototype.getGroupById = function (id) {
	    return this.groups.find(function (group) {
	      return group.id === id;
	    });
	  };
	  return Store;
	}();
	exports["default"] = Store;

	/***/ }),

	/***/ 686:
	/***/ (function(__unused_webpack_module, exports) {



	/**
	 * Helpers to create HTML elements used by Choices
	 * Can be overridden by providing `callbackOnCreateTemplates` option
	 */
	Object.defineProperty(exports, "__esModule", ({
	  value: true
	}));
	var templates = {
	  containerOuter: function (_a, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType, labelId) {
	    var containerOuter = _a.classNames.containerOuter;
	    var div = Object.assign(document.createElement('div'), {
	      className: containerOuter
	    });
	    div.dataset.type = passedElementType;
	    if (dir) {
	      div.dir = dir;
	    }
	    if (isSelectOneElement) {
	      div.tabIndex = 0;
	    }
	    if (isSelectElement) {
	      div.setAttribute('role', searchEnabled ? 'combobox' : 'listbox');
	      if (searchEnabled) {
	        div.setAttribute('aria-autocomplete', 'list');
	      }
	    }
	    div.setAttribute('aria-haspopup', 'true');
	    div.setAttribute('aria-expanded', 'false');
	    if (labelId) {
	      div.setAttribute('aria-labelledby', labelId);
	    }
	    return div;
	  },
	  containerInner: function (_a) {
	    var containerInner = _a.classNames.containerInner;
	    return Object.assign(document.createElement('div'), {
	      className: containerInner
	    });
	  },
	  itemList: function (_a, isSelectOneElement) {
	    var _b = _a.classNames,
	      list = _b.list,
	      listSingle = _b.listSingle,
	      listItems = _b.listItems;
	    return Object.assign(document.createElement('div'), {
	      className: "".concat(list, " ").concat(isSelectOneElement ? listSingle : listItems)
	    });
	  },
	  placeholder: function (_a, value) {
	    var _b;
	    var allowHTML = _a.allowHTML,
	      placeholder = _a.classNames.placeholder;
	    return Object.assign(document.createElement('div'), (_b = {
	      className: placeholder
	    }, _b[allowHTML ? 'innerHTML' : 'innerText'] = value, _b));
	  },
	  item: function (_a, _b, removeItemButton) {
	    var _c, _d;
	    var allowHTML = _a.allowHTML,
	      _e = _a.classNames,
	      item = _e.item,
	      button = _e.button,
	      highlightedState = _e.highlightedState,
	      itemSelectable = _e.itemSelectable,
	      placeholder = _e.placeholder;
	    var id = _b.id,
	      value = _b.value,
	      label = _b.label,
	      customProperties = _b.customProperties,
	      active = _b.active,
	      disabled = _b.disabled,
	      highlighted = _b.highlighted,
	      isPlaceholder = _b.placeholder;
	    var div = Object.assign(document.createElement('div'), (_c = {
	      className: item
	    }, _c[allowHTML ? 'innerHTML' : 'innerText'] = label, _c));
	    Object.assign(div.dataset, {
	      item: '',
	      id: id,
	      value: value,
	      customProperties: customProperties
	    });
	    if (active) {
	      div.setAttribute('aria-selected', 'true');
	    }
	    if (disabled) {
	      div.setAttribute('aria-disabled', 'true');
	    }
	    if (isPlaceholder) {
	      div.classList.add(placeholder);
	    }
	    div.classList.add(highlighted ? highlightedState : itemSelectable);
	    if (removeItemButton) {
	      if (disabled) {
	        div.classList.remove(itemSelectable);
	      }
	      div.dataset.deletable = '';
	      /** @todo This MUST be localizable, not hardcoded! */
	      var REMOVE_ITEM_TEXT = 'Remove item';
	      var removeButton = Object.assign(document.createElement('button'), (_d = {
	        type: 'button',
	        className: button
	      }, _d[allowHTML ? 'innerHTML' : 'innerText'] = REMOVE_ITEM_TEXT, _d));
	      removeButton.setAttribute('aria-label', "".concat(REMOVE_ITEM_TEXT, ": '").concat(value, "'"));
	      removeButton.dataset.button = '';
	      div.appendChild(removeButton);
	    }
	    return div;
	  },
	  choiceList: function (_a, isSelectOneElement) {
	    var list = _a.classNames.list;
	    var div = Object.assign(document.createElement('div'), {
	      className: list
	    });
	    if (!isSelectOneElement) {
	      div.setAttribute('aria-multiselectable', 'true');
	    }
	    div.setAttribute('role', 'listbox');
	    return div;
	  },
	  choiceGroup: function (_a, _b) {
	    var _c;
	    var allowHTML = _a.allowHTML,
	      _d = _a.classNames,
	      group = _d.group,
	      groupHeading = _d.groupHeading,
	      itemDisabled = _d.itemDisabled;
	    var id = _b.id,
	      value = _b.value,
	      disabled = _b.disabled;
	    var div = Object.assign(document.createElement('div'), {
	      className: "".concat(group, " ").concat(disabled ? itemDisabled : '')
	    });
	    div.setAttribute('role', 'group');
	    Object.assign(div.dataset, {
	      group: '',
	      id: id,
	      value: value
	    });
	    if (disabled) {
	      div.setAttribute('aria-disabled', 'true');
	    }
	    div.appendChild(Object.assign(document.createElement('div'), (_c = {
	      className: groupHeading
	    }, _c[allowHTML ? 'innerHTML' : 'innerText'] = value, _c)));
	    return div;
	  },
	  choice: function (_a, _b, selectText) {
	    var _c;
	    var allowHTML = _a.allowHTML,
	      _d = _a.classNames,
	      item = _d.item,
	      itemChoice = _d.itemChoice,
	      itemSelectable = _d.itemSelectable,
	      selectedState = _d.selectedState,
	      itemDisabled = _d.itemDisabled,
	      placeholder = _d.placeholder;
	    var id = _b.id,
	      value = _b.value,
	      label = _b.label,
	      groupId = _b.groupId,
	      elementId = _b.elementId,
	      isDisabled = _b.disabled,
	      isSelected = _b.selected,
	      isPlaceholder = _b.placeholder;
	    var div = Object.assign(document.createElement('div'), (_c = {
	      id: elementId
	    }, _c[allowHTML ? 'innerHTML' : 'innerText'] = label, _c.className = "".concat(item, " ").concat(itemChoice), _c));
	    if (isSelected) {
	      div.classList.add(selectedState);
	    }
	    if (isPlaceholder) {
	      div.classList.add(placeholder);
	    }
	    div.setAttribute('role', groupId && groupId > 0 ? 'treeitem' : 'option');
	    Object.assign(div.dataset, {
	      choice: '',
	      id: id,
	      value: value,
	      selectText: selectText
	    });
	    if (isDisabled) {
	      div.classList.add(itemDisabled);
	      div.dataset.choiceDisabled = '';
	      div.setAttribute('aria-disabled', 'true');
	    } else {
	      div.classList.add(itemSelectable);
	      div.dataset.choiceSelectable = '';
	    }
	    return div;
	  },
	  input: function (_a, placeholderValue) {
	    var _b = _a.classNames,
	      input = _b.input,
	      inputCloned = _b.inputCloned;
	    var inp = Object.assign(document.createElement('input'), {
	      type: 'search',
	      name: 'search_terms',
	      className: "".concat(input, " ").concat(inputCloned),
	      autocomplete: 'off',
	      autocapitalize: 'off',
	      spellcheck: false
	    });
	    inp.setAttribute('role', 'textbox');
	    inp.setAttribute('aria-autocomplete', 'list');
	    inp.setAttribute('aria-label', placeholderValue);
	    return inp;
	  },
	  dropdown: function (_a) {
	    var _b = _a.classNames,
	      list = _b.list,
	      listDropdown = _b.listDropdown;
	    var div = document.createElement('div');
	    div.classList.add(list, listDropdown);
	    div.setAttribute('aria-expanded', 'false');
	    return div;
	  },
	  notice: function (_a, innerText, type) {
	    var _b;
	    var allowHTML = _a.allowHTML,
	      _c = _a.classNames,
	      item = _c.item,
	      itemChoice = _c.itemChoice,
	      noResults = _c.noResults,
	      noChoices = _c.noChoices;
	    if (type === void 0) {
	      type = '';
	    }
	    var classes = [item, itemChoice];
	    if (type === 'no-choices') {
	      classes.push(noChoices);
	    } else if (type === 'no-results') {
	      classes.push(noResults);
	    }
	    return Object.assign(document.createElement('div'), (_b = {}, _b[allowHTML ? 'innerHTML' : 'innerText'] = innerText, _b.className = classes.join(' '), _b));
	  },
	  option: function (_a) {
	    var label = _a.label,
	      value = _a.value,
	      customProperties = _a.customProperties,
	      active = _a.active,
	      disabled = _a.disabled;
	    var opt = new Option(label, value, false, active);
	    if (customProperties) {
	      opt.dataset.customProperties = "".concat(customProperties);
	    }
	    opt.disabled = !!disabled;
	    return opt;
	  }
	};
	exports["default"] = templates;

	/***/ }),

	/***/ 996:
	/***/ (function(module) {



	var isMergeableObject = function isMergeableObject(value) {
		return isNonNullObject(value)
			&& !isSpecial(value)
	};

	function isNonNullObject(value) {
		return !!value && typeof value === 'object'
	}

	function isSpecial(value) {
		var stringValue = Object.prototype.toString.call(value);

		return stringValue === '[object RegExp]'
			|| stringValue === '[object Date]'
			|| isReactElement(value)
	}

	// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
	var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

	function isReactElement(value) {
		return value.$$typeof === REACT_ELEMENT_TYPE
	}

	function emptyTarget(val) {
		return Array.isArray(val) ? [] : {}
	}

	function cloneUnlessOtherwiseSpecified(value, options) {
		return (options.clone !== false && options.isMergeableObject(value))
			? deepmerge(emptyTarget(value), value, options)
			: value
	}

	function defaultArrayMerge(target, source, options) {
		return target.concat(source).map(function(element) {
			return cloneUnlessOtherwiseSpecified(element, options)
		})
	}

	function getMergeFunction(key, options) {
		if (!options.customMerge) {
			return deepmerge
		}
		var customMerge = options.customMerge(key);
		return typeof customMerge === 'function' ? customMerge : deepmerge
	}

	function getEnumerableOwnPropertySymbols(target) {
		return Object.getOwnPropertySymbols
			? Object.getOwnPropertySymbols(target).filter(function(symbol) {
				return target.propertyIsEnumerable(symbol)
			})
			: []
	}

	function getKeys(target) {
		return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
	}

	function propertyIsOnObject(object, property) {
		try {
			return property in object
		} catch(_) {
			return false
		}
	}

	// Protects from prototype poisoning and unexpected merging up the prototype chain.
	function propertyIsUnsafe(target, key) {
		return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
			&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
				&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
	}

	function mergeObject(target, source, options) {
		var destination = {};
		if (options.isMergeableObject(target)) {
			getKeys(target).forEach(function(key) {
				destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
			});
		}
		getKeys(source).forEach(function(key) {
			if (propertyIsUnsafe(target, key)) {
				return
			}

			if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
				destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
			} else {
				destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
			}
		});
		return destination
	}

	function deepmerge(target, source, options) {
		options = options || {};
		options.arrayMerge = options.arrayMerge || defaultArrayMerge;
		options.isMergeableObject = options.isMergeableObject || isMergeableObject;
		// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
		// implementations can use it. The caller may not replace it.
		options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

		var sourceIsArray = Array.isArray(source);
		var targetIsArray = Array.isArray(target);
		var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

		if (!sourceAndTargetTypesMatch) {
			return cloneUnlessOtherwiseSpecified(source, options)
		} else if (sourceIsArray) {
			return options.arrayMerge(target, source, options)
		} else {
			return mergeObject(target, source, options)
		}
	}

	deepmerge.all = function deepmergeAll(array, options) {
		if (!Array.isArray(array)) {
			throw new Error('first argument should be an array')
		}

		return array.reduce(function(prev, next) {
			return deepmerge(prev, next, options)
		}, {})
	};

	var deepmerge_1 = deepmerge;

	module.exports = deepmerge_1;


	/***/ }),

	/***/ 221:
	/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	__webpack_require__.r(__webpack_exports__);
	/* harmony export */ __webpack_require__.d(__webpack_exports__, {
	/* harmony export */   "default": function() { return /* binding */ Fuse; }
	/* harmony export */ });
	/**
	 * Fuse.js v6.6.2 - Lightweight fuzzy-search (http://fusejs.io)
	 *
	 * Copyright (c) 2022 Kiro Risk (http://kiro.me)
	 * All Rights Reserved. Apache Software License 2.0
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 */

	function isArray(value) {
	  return !Array.isArray
	    ? getTag(value) === '[object Array]'
	    : Array.isArray(value)
	}

	// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
	const INFINITY = 1 / 0;
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value
	  }
	  let result = value + '';
	  return result == '0' && 1 / value == -INFINITY ? '-0' : result
	}

	function toString(value) {
	  return value == null ? '' : baseToString(value)
	}

	function isString(value) {
	  return typeof value === 'string'
	}

	function isNumber(value) {
	  return typeof value === 'number'
	}

	// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
	function isBoolean(value) {
	  return (
	    value === true ||
	    value === false ||
	    (isObjectLike(value) && getTag(value) == '[object Boolean]')
	  )
	}

	function isObject(value) {
	  return typeof value === 'object'
	}

	// Checks if `value` is object-like.
	function isObjectLike(value) {
	  return isObject(value) && value !== null
	}

	function isDefined(value) {
	  return value !== undefined && value !== null
	}

	function isBlank(value) {
	  return !value.trim().length
	}

	// Gets the `toStringTag` of `value`.
	// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
	function getTag(value) {
	  return value == null
	    ? value === undefined
	      ? '[object Undefined]'
	      : '[object Null]'
	    : Object.prototype.toString.call(value)
	}

	const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";

	const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>
	  `Invalid value for key ${key}`;

	const PATTERN_LENGTH_TOO_LARGE = (max) =>
	  `Pattern length exceeds max of ${max}.`;

	const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;

	const INVALID_KEY_WEIGHT_VALUE = (key) =>
	  `Property 'weight' in key '${key}' must be a positive integer`;

	const hasOwn = Object.prototype.hasOwnProperty;

	class KeyStore {
	  constructor(keys) {
	    this._keys = [];
	    this._keyMap = {};

	    let totalWeight = 0;

	    keys.forEach((key) => {
	      let obj = createKey(key);

	      totalWeight += obj.weight;

	      this._keys.push(obj);
	      this._keyMap[obj.id] = obj;

	      totalWeight += obj.weight;
	    });

	    // Normalize weights so that their sum is equal to 1
	    this._keys.forEach((key) => {
	      key.weight /= totalWeight;
	    });
	  }
	  get(keyId) {
	    return this._keyMap[keyId]
	  }
	  keys() {
	    return this._keys
	  }
	  toJSON() {
	    return JSON.stringify(this._keys)
	  }
	}

	function createKey(key) {
	  let path = null;
	  let id = null;
	  let src = null;
	  let weight = 1;
	  let getFn = null;

	  if (isString(key) || isArray(key)) {
	    src = key;
	    path = createKeyPath(key);
	    id = createKeyId(key);
	  } else {
	    if (!hasOwn.call(key, 'name')) {
	      throw new Error(MISSING_KEY_PROPERTY('name'))
	    }

	    const name = key.name;
	    src = name;

	    if (hasOwn.call(key, 'weight')) {
	      weight = key.weight;

	      if (weight <= 0) {
	        throw new Error(INVALID_KEY_WEIGHT_VALUE(name))
	      }
	    }

	    path = createKeyPath(name);
	    id = createKeyId(name);
	    getFn = key.getFn;
	  }

	  return { path, id, weight, src, getFn }
	}

	function createKeyPath(key) {
	  return isArray(key) ? key : key.split('.')
	}

	function createKeyId(key) {
	  return isArray(key) ? key.join('.') : key
	}

	function get(obj, path) {
	  let list = [];
	  let arr = false;

	  const deepGet = (obj, path, index) => {
	    if (!isDefined(obj)) {
	      return
	    }
	    if (!path[index]) {
	      // If there's no path left, we've arrived at the object we care about.
	      list.push(obj);
	    } else {
	      let key = path[index];

	      const value = obj[key];

	      if (!isDefined(value)) {
	        return
	      }

	      // If we're at the last value in the path, and if it's a string/number/bool,
	      // add it to the list
	      if (
	        index === path.length - 1 &&
	        (isString(value) || isNumber(value) || isBoolean(value))
	      ) {
	        list.push(toString(value));
	      } else if (isArray(value)) {
	        arr = true;
	        // Search each item in the array.
	        for (let i = 0, len = value.length; i < len; i += 1) {
	          deepGet(value[i], path, index + 1);
	        }
	      } else if (path.length) {
	        // An object. Recurse further.
	        deepGet(value, path, index + 1);
	      }
	    }
	  };

	  // Backwards compatibility (since path used to be a string)
	  deepGet(obj, isString(path) ? path.split('.') : path, 0);

	  return arr ? list : list[0]
	}

	const MatchOptions = {
	  // Whether the matches should be included in the result set. When `true`, each record in the result
	  // set will include the indices of the matched characters.
	  // These can consequently be used for highlighting purposes.
	  includeMatches: false,
	  // When `true`, the matching function will continue to the end of a search pattern even if
	  // a perfect match has already been located in the string.
	  findAllMatches: false,
	  // Minimum number of characters that must be matched before a result is considered a match
	  minMatchCharLength: 1
	};

	const BasicOptions = {
	  // When `true`, the algorithm continues searching to the end of the input even if a perfect
	  // match is found before the end of the same input.
	  isCaseSensitive: false,
	  // When true, the matching function will continue to the end of a search pattern even if
	  includeScore: false,
	  // List of properties that will be searched. This also supports nested properties.
	  keys: [],
	  // Whether to sort the result list, by score
	  shouldSort: true,
	  // Default sort function: sort by ascending score, ascending index
	  sortFn: (a, b) =>
	    a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1
	};

	const FuzzyOptions = {
	  // Approximately where in the text is the pattern expected to be found?
	  location: 0,
	  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
	  // (of both letters and location), a threshold of '1.0' would match anything.
	  threshold: 0.6,
	  // Determines how close the match must be to the fuzzy location (specified above).
	  // An exact letter match which is 'distance' characters away from the fuzzy location
	  // would score as a complete mismatch. A distance of '0' requires the match be at
	  // the exact location specified, a threshold of '1000' would require a perfect match
	  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
	  distance: 100
	};

	const AdvancedOptions = {
	  // When `true`, it enables the use of unix-like search commands
	  useExtendedSearch: false,
	  // The get function to use when fetching an object's properties.
	  // The default will search nested paths *ie foo.bar.baz*
	  getFn: get,
	  // When `true`, search will ignore `location` and `distance`, so it won't matter
	  // where in the string the pattern appears.
	  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
	  ignoreLocation: false,
	  // When `true`, the calculation for the relevance score (used for sorting) will
	  // ignore the field-length norm.
	  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
	  ignoreFieldNorm: false,
	  // The weight to determine how much field length norm effects scoring.
	  fieldNormWeight: 1
	};

	var Config = {
	  ...BasicOptions,
	  ...MatchOptions,
	  ...FuzzyOptions,
	  ...AdvancedOptions
	};

	const SPACE = /[^ ]+/g;

	// Field-length norm: the shorter the field, the higher the weight.
	// Set to 3 decimals to reduce index size.
	function norm(weight = 1, mantissa = 3) {
	  const cache = new Map();
	  const m = Math.pow(10, mantissa);

	  return {
	    get(value) {
	      const numTokens = value.match(SPACE).length;

	      if (cache.has(numTokens)) {
	        return cache.get(numTokens)
	      }

	      // Default function is 1/sqrt(x), weight makes that variable
	      const norm = 1 / Math.pow(numTokens, 0.5 * weight);

	      // In place of `toFixed(mantissa)`, for faster computation
	      const n = parseFloat(Math.round(norm * m) / m);

	      cache.set(numTokens, n);

	      return n
	    },
	    clear() {
	      cache.clear();
	    }
	  }
	}

	class FuseIndex {
	  constructor({
	    getFn = Config.getFn,
	    fieldNormWeight = Config.fieldNormWeight
	  } = {}) {
	    this.norm = norm(fieldNormWeight, 3);
	    this.getFn = getFn;
	    this.isCreated = false;

	    this.setIndexRecords();
	  }
	  setSources(docs = []) {
	    this.docs = docs;
	  }
	  setIndexRecords(records = []) {
	    this.records = records;
	  }
	  setKeys(keys = []) {
	    this.keys = keys;
	    this._keysMap = {};
	    keys.forEach((key, idx) => {
	      this._keysMap[key.id] = idx;
	    });
	  }
	  create() {
	    if (this.isCreated || !this.docs.length) {
	      return
	    }

	    this.isCreated = true;

	    // List is Array<String>
	    if (isString(this.docs[0])) {
	      this.docs.forEach((doc, docIndex) => {
	        this._addString(doc, docIndex);
	      });
	    } else {
	      // List is Array<Object>
	      this.docs.forEach((doc, docIndex) => {
	        this._addObject(doc, docIndex);
	      });
	    }

	    this.norm.clear();
	  }
	  // Adds a doc to the end of the index
	  add(doc) {
	    const idx = this.size();

	    if (isString(doc)) {
	      this._addString(doc, idx);
	    } else {
	      this._addObject(doc, idx);
	    }
	  }
	  // Removes the doc at the specified index of the index
	  removeAt(idx) {
	    this.records.splice(idx, 1);

	    // Change ref index of every subsquent doc
	    for (let i = idx, len = this.size(); i < len; i += 1) {
	      this.records[i].i -= 1;
	    }
	  }
	  getValueForItemAtKeyId(item, keyId) {
	    return item[this._keysMap[keyId]]
	  }
	  size() {
	    return this.records.length
	  }
	  _addString(doc, docIndex) {
	    if (!isDefined(doc) || isBlank(doc)) {
	      return
	    }

	    let record = {
	      v: doc,
	      i: docIndex,
	      n: this.norm.get(doc)
	    };

	    this.records.push(record);
	  }
	  _addObject(doc, docIndex) {
	    let record = { i: docIndex, $: {} };

	    // Iterate over every key (i.e, path), and fetch the value at that key
	    this.keys.forEach((key, keyIndex) => {
	      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);

	      if (!isDefined(value)) {
	        return
	      }

	      if (isArray(value)) {
	        let subRecords = [];
	        const stack = [{ nestedArrIndex: -1, value }];

	        while (stack.length) {
	          const { nestedArrIndex, value } = stack.pop();

	          if (!isDefined(value)) {
	            continue
	          }

	          if (isString(value) && !isBlank(value)) {
	            let subRecord = {
	              v: value,
	              i: nestedArrIndex,
	              n: this.norm.get(value)
	            };

	            subRecords.push(subRecord);
	          } else if (isArray(value)) {
	            value.forEach((item, k) => {
	              stack.push({
	                nestedArrIndex: k,
	                value: item
	              });
	            });
	          } else ;
	        }
	        record.$[keyIndex] = subRecords;
	      } else if (isString(value) && !isBlank(value)) {
	        let subRecord = {
	          v: value,
	          n: this.norm.get(value)
	        };

	        record.$[keyIndex] = subRecord;
	      }
	    });

	    this.records.push(record);
	  }
	  toJSON() {
	    return {
	      keys: this.keys,
	      records: this.records
	    }
	  }
	}

	function createIndex(
	  keys,
	  docs,
	  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
	) {
	  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
	  myIndex.setKeys(keys.map(createKey));
	  myIndex.setSources(docs);
	  myIndex.create();
	  return myIndex
	}

	function parseIndex(
	  data,
	  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
	) {
	  const { keys, records } = data;
	  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
	  myIndex.setKeys(keys);
	  myIndex.setIndexRecords(records);
	  return myIndex
	}

	function computeScore$1(
	  pattern,
	  {
	    errors = 0,
	    currentLocation = 0,
	    expectedLocation = 0,
	    distance = Config.distance,
	    ignoreLocation = Config.ignoreLocation
	  } = {}
	) {
	  const accuracy = errors / pattern.length;

	  if (ignoreLocation) {
	    return accuracy
	  }

	  const proximity = Math.abs(expectedLocation - currentLocation);

	  if (!distance) {
	    // Dodge divide by zero error.
	    return proximity ? 1.0 : accuracy
	  }

	  return accuracy + proximity / distance
	}

	function convertMaskToIndices(
	  matchmask = [],
	  minMatchCharLength = Config.minMatchCharLength
	) {
	  let indices = [];
	  let start = -1;
	  let end = -1;
	  let i = 0;

	  for (let len = matchmask.length; i < len; i += 1) {
	    let match = matchmask[i];
	    if (match && start === -1) {
	      start = i;
	    } else if (!match && start !== -1) {
	      end = i - 1;
	      if (end - start + 1 >= minMatchCharLength) {
	        indices.push([start, end]);
	      }
	      start = -1;
	    }
	  }

	  // (i-1 - start) + 1 => i - start
	  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
	    indices.push([start, i - 1]);
	  }

	  return indices
	}

	// Machine word size
	const MAX_BITS = 32;

	function search(
	  text,
	  pattern,
	  patternAlphabet,
	  {
	    location = Config.location,
	    distance = Config.distance,
	    threshold = Config.threshold,
	    findAllMatches = Config.findAllMatches,
	    minMatchCharLength = Config.minMatchCharLength,
	    includeMatches = Config.includeMatches,
	    ignoreLocation = Config.ignoreLocation
	  } = {}
	) {
	  if (pattern.length > MAX_BITS) {
	    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))
	  }

	  const patternLen = pattern.length;
	  // Set starting location at beginning text and initialize the alphabet.
	  const textLen = text.length;
	  // Handle the case when location > text.length
	  const expectedLocation = Math.max(0, Math.min(location, textLen));
	  // Highest score beyond which we give up.
	  let currentThreshold = threshold;
	  // Is there a nearby exact match? (speedup)
	  let bestLocation = expectedLocation;

	  // Performance: only computer matches when the minMatchCharLength > 1
	  // OR if `includeMatches` is true.
	  const computeMatches = minMatchCharLength > 1 || includeMatches;
	  // A mask of the matches, used for building the indices
	  const matchMask = computeMatches ? Array(textLen) : [];

	  let index;

	  // Get all exact matches, here for speed up
	  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
	    let score = computeScore$1(pattern, {
	      currentLocation: index,
	      expectedLocation,
	      distance,
	      ignoreLocation
	    });

	    currentThreshold = Math.min(score, currentThreshold);
	    bestLocation = index + patternLen;

	    if (computeMatches) {
	      let i = 0;
	      while (i < patternLen) {
	        matchMask[index + i] = 1;
	        i += 1;
	      }
	    }
	  }

	  // Reset the best location
	  bestLocation = -1;

	  let lastBitArr = [];
	  let finalScore = 1;
	  let binMax = patternLen + textLen;

	  const mask = 1 << (patternLen - 1);

	  for (let i = 0; i < patternLen; i += 1) {
	    // Scan for the best match; each iteration allows for one more error.
	    // Run a binary search to determine how far from the match location we can stray
	    // at this error level.
	    let binMin = 0;
	    let binMid = binMax;

	    while (binMin < binMid) {
	      const score = computeScore$1(pattern, {
	        errors: i,
	        currentLocation: expectedLocation + binMid,
	        expectedLocation,
	        distance,
	        ignoreLocation
	      });

	      if (score <= currentThreshold) {
	        binMin = binMid;
	      } else {
	        binMax = binMid;
	      }

	      binMid = Math.floor((binMax - binMin) / 2 + binMin);
	    }

	    // Use the result from this iteration as the maximum for the next.
	    binMax = binMid;

	    let start = Math.max(1, expectedLocation - binMid + 1);
	    let finish = findAllMatches
	      ? textLen
	      : Math.min(expectedLocation + binMid, textLen) + patternLen;

	    // Initialize the bit array
	    let bitArr = Array(finish + 2);

	    bitArr[finish + 1] = (1 << i) - 1;

	    for (let j = finish; j >= start; j -= 1) {
	      let currentLocation = j - 1;
	      let charMatch = patternAlphabet[text.charAt(currentLocation)];

	      if (computeMatches) {
	        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
	        matchMask[currentLocation] = +!!charMatch;
	      }

	      // First pass: exact match
	      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;

	      // Subsequent passes: fuzzy match
	      if (i) {
	        bitArr[j] |=
	          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];
	      }

	      if (bitArr[j] & mask) {
	        finalScore = computeScore$1(pattern, {
	          errors: i,
	          currentLocation,
	          expectedLocation,
	          distance,
	          ignoreLocation
	        });

	        // This match will almost certainly be better than any existing match.
	        // But check anyway.
	        if (finalScore <= currentThreshold) {
	          // Indeed it is
	          currentThreshold = finalScore;
	          bestLocation = currentLocation;

	          // Already passed `loc`, downhill from here on in.
	          if (bestLocation <= expectedLocation) {
	            break
	          }

	          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
	          start = Math.max(1, 2 * expectedLocation - bestLocation);
	        }
	      }
	    }

	    // No hope for a (better) match at greater error levels.
	    const score = computeScore$1(pattern, {
	      errors: i + 1,
	      currentLocation: expectedLocation,
	      expectedLocation,
	      distance,
	      ignoreLocation
	    });

	    if (score > currentThreshold) {
	      break
	    }

	    lastBitArr = bitArr;
	  }

	  const result = {
	    isMatch: bestLocation >= 0,
	    // Count exact matches (those with a score of 0) to be "almost" exact
	    score: Math.max(0.001, finalScore)
	  };

	  if (computeMatches) {
	    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
	    if (!indices.length) {
	      result.isMatch = false;
	    } else if (includeMatches) {
	      result.indices = indices;
	    }
	  }

	  return result
	}

	function createPatternAlphabet(pattern) {
	  let mask = {};

	  for (let i = 0, len = pattern.length; i < len; i += 1) {
	    const char = pattern.charAt(i);
	    mask[char] = (mask[char] || 0) | (1 << (len - i - 1));
	  }

	  return mask
	}

	class BitapSearch {
	  constructor(
	    pattern,
	    {
	      location = Config.location,
	      threshold = Config.threshold,
	      distance = Config.distance,
	      includeMatches = Config.includeMatches,
	      findAllMatches = Config.findAllMatches,
	      minMatchCharLength = Config.minMatchCharLength,
	      isCaseSensitive = Config.isCaseSensitive,
	      ignoreLocation = Config.ignoreLocation
	    } = {}
	  ) {
	    this.options = {
	      location,
	      threshold,
	      distance,
	      includeMatches,
	      findAllMatches,
	      minMatchCharLength,
	      isCaseSensitive,
	      ignoreLocation
	    };

	    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();

	    this.chunks = [];

	    if (!this.pattern.length) {
	      return
	    }

	    const addChunk = (pattern, startIndex) => {
	      this.chunks.push({
	        pattern,
	        alphabet: createPatternAlphabet(pattern),
	        startIndex
	      });
	    };

	    const len = this.pattern.length;

	    if (len > MAX_BITS) {
	      let i = 0;
	      const remainder = len % MAX_BITS;
	      const end = len - remainder;

	      while (i < end) {
	        addChunk(this.pattern.substr(i, MAX_BITS), i);
	        i += MAX_BITS;
	      }

	      if (remainder) {
	        const startIndex = len - MAX_BITS;
	        addChunk(this.pattern.substr(startIndex), startIndex);
	      }
	    } else {
	      addChunk(this.pattern, 0);
	    }
	  }

	  searchIn(text) {
	    const { isCaseSensitive, includeMatches } = this.options;

	    if (!isCaseSensitive) {
	      text = text.toLowerCase();
	    }

	    // Exact match
	    if (this.pattern === text) {
	      let result = {
	        isMatch: true,
	        score: 0
	      };

	      if (includeMatches) {
	        result.indices = [[0, text.length - 1]];
	      }

	      return result
	    }

	    // Otherwise, use Bitap algorithm
	    const {
	      location,
	      distance,
	      threshold,
	      findAllMatches,
	      minMatchCharLength,
	      ignoreLocation
	    } = this.options;

	    let allIndices = [];
	    let totalScore = 0;
	    let hasMatches = false;

	    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
	      const { isMatch, score, indices } = search(text, pattern, alphabet, {
	        location: location + startIndex,
	        distance,
	        threshold,
	        findAllMatches,
	        minMatchCharLength,
	        includeMatches,
	        ignoreLocation
	      });

	      if (isMatch) {
	        hasMatches = true;
	      }

	      totalScore += score;

	      if (isMatch && indices) {
	        allIndices = [...allIndices, ...indices];
	      }
	    });

	    let result = {
	      isMatch: hasMatches,
	      score: hasMatches ? totalScore / this.chunks.length : 1
	    };

	    if (hasMatches && includeMatches) {
	      result.indices = allIndices;
	    }

	    return result
	  }
	}

	class BaseMatch {
	  constructor(pattern) {
	    this.pattern = pattern;
	  }
	  static isMultiMatch(pattern) {
	    return getMatch(pattern, this.multiRegex)
	  }
	  static isSingleMatch(pattern) {
	    return getMatch(pattern, this.singleRegex)
	  }
	  search(/*text*/) {}
	}

	function getMatch(pattern, exp) {
	  const matches = pattern.match(exp);
	  return matches ? matches[1] : null
	}

	// Token: 'file

	class ExactMatch extends BaseMatch {
	  constructor(pattern) {
	    super(pattern);
	  }
	  static get type() {
	    return 'exact'
	  }
	  static get multiRegex() {
	    return /^="(.*)"$/
	  }
	  static get singleRegex() {
	    return /^=(.*)$/
	  }
	  search(text) {
	    const isMatch = text === this.pattern;

	    return {
	      isMatch,
	      score: isMatch ? 0 : 1,
	      indices: [0, this.pattern.length - 1]
	    }
	  }
	}

	// Token: !fire

	class InverseExactMatch extends BaseMatch {
	  constructor(pattern) {
	    super(pattern);
	  }
	  static get type() {
	    return 'inverse-exact'
	  }
	  static get multiRegex() {
	    return /^!"(.*)"$/
	  }
	  static get singleRegex() {
	    return /^!(.*)$/
	  }
	  search(text) {
	    const index = text.indexOf(this.pattern);
	    const isMatch = index === -1;

	    return {
	      isMatch,
	      score: isMatch ? 0 : 1,
	      indices: [0, text.length - 1]
	    }
	  }
	}

	// Token: ^file

	class PrefixExactMatch extends BaseMatch {
	  constructor(pattern) {
	    super(pattern);
	  }
	  static get type() {
	    return 'prefix-exact'
	  }
	  static get multiRegex() {
	    return /^\^"(.*)"$/
	  }
	  static get singleRegex() {
	    return /^\^(.*)$/
	  }
	  search(text) {
	    const isMatch = text.startsWith(this.pattern);

	    return {
	      isMatch,
	      score: isMatch ? 0 : 1,
	      indices: [0, this.pattern.length - 1]
	    }
	  }
	}

	// Token: !^fire

	class InversePrefixExactMatch extends BaseMatch {
	  constructor(pattern) {
	    super(pattern);
	  }
	  static get type() {
	    return 'inverse-prefix-exact'
	  }
	  static get multiRegex() {
	    return /^!\^"(.*)"$/
	  }
	  static get singleRegex() {
	    return /^!\^(.*)$/
	  }
	  search(text) {
	    const isMatch = !text.startsWith(this.pattern);

	    return {
	      isMatch,
	      score: isMatch ? 0 : 1,
	      indices: [0, text.length - 1]
	    }
	  }
	}

	// Token: .file$

	class SuffixExactMatch extends BaseMatch {
	  constructor(pattern) {
	    super(pattern);
	  }
	  static get type() {
	    return 'suffix-exact'
	  }
	  static get multiRegex() {
	    return /^"(.*)"\$$/
	  }
	  static get singleRegex() {
	    return /^(.*)\$$/
	  }
	  search(text) {
	    const isMatch = text.endsWith(this.pattern);

	    return {
	      isMatch,
	      score: isMatch ? 0 : 1,
	      indices: [text.length - this.pattern.length, text.length - 1]
	    }
	  }
	}

	// Token: !.file$

	class InverseSuffixExactMatch extends BaseMatch {
	  constructor(pattern) {
	    super(pattern);
	  }
	  static get type() {
	    return 'inverse-suffix-exact'
	  }
	  static get multiRegex() {
	    return /^!"(.*)"\$$/
	  }
	  static get singleRegex() {
	    return /^!(.*)\$$/
	  }
	  search(text) {
	    const isMatch = !text.endsWith(this.pattern);
	    return {
	      isMatch,
	      score: isMatch ? 0 : 1,
	      indices: [0, text.length - 1]
	    }
	  }
	}

	class FuzzyMatch extends BaseMatch {
	  constructor(
	    pattern,
	    {
	      location = Config.location,
	      threshold = Config.threshold,
	      distance = Config.distance,
	      includeMatches = Config.includeMatches,
	      findAllMatches = Config.findAllMatches,
	      minMatchCharLength = Config.minMatchCharLength,
	      isCaseSensitive = Config.isCaseSensitive,
	      ignoreLocation = Config.ignoreLocation
	    } = {}
	  ) {
	    super(pattern);
	    this._bitapSearch = new BitapSearch(pattern, {
	      location,
	      threshold,
	      distance,
	      includeMatches,
	      findAllMatches,
	      minMatchCharLength,
	      isCaseSensitive,
	      ignoreLocation
	    });
	  }
	  static get type() {
	    return 'fuzzy'
	  }
	  static get multiRegex() {
	    return /^"(.*)"$/
	  }
	  static get singleRegex() {
	    return /^(.*)$/
	  }
	  search(text) {
	    return this._bitapSearch.searchIn(text)
	  }
	}

	// Token: 'file

	class IncludeMatch extends BaseMatch {
	  constructor(pattern) {
	    super(pattern);
	  }
	  static get type() {
	    return 'include'
	  }
	  static get multiRegex() {
	    return /^'"(.*)"$/
	  }
	  static get singleRegex() {
	    return /^'(.*)$/
	  }
	  search(text) {
	    let location = 0;
	    let index;

	    const indices = [];
	    const patternLen = this.pattern.length;

	    // Get all exact matches
	    while ((index = text.indexOf(this.pattern, location)) > -1) {
	      location = index + patternLen;
	      indices.push([index, location - 1]);
	    }

	    const isMatch = !!indices.length;

	    return {
	      isMatch,
	      score: isMatch ? 0 : 1,
	      indices
	    }
	  }
	}

	// Order is important. DO NOT CHANGE.
	const searchers = [
	  ExactMatch,
	  IncludeMatch,
	  PrefixExactMatch,
	  InversePrefixExactMatch,
	  InverseSuffixExactMatch,
	  SuffixExactMatch,
	  InverseExactMatch,
	  FuzzyMatch
	];

	const searchersLen = searchers.length;

	// Regex to split by spaces, but keep anything in quotes together
	const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
	const OR_TOKEN = '|';

	// Return a 2D array representation of the query, for simpler parsing.
	// Example:
	// "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
	function parseQuery(pattern, options = {}) {
	  return pattern.split(OR_TOKEN).map((item) => {
	    let query = item
	      .trim()
	      .split(SPACE_RE)
	      .filter((item) => item && !!item.trim());

	    let results = [];
	    for (let i = 0, len = query.length; i < len; i += 1) {
	      const queryItem = query[i];

	      // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
	      let found = false;
	      let idx = -1;
	      while (!found && ++idx < searchersLen) {
	        const searcher = searchers[idx];
	        let token = searcher.isMultiMatch(queryItem);
	        if (token) {
	          results.push(new searcher(token, options));
	          found = true;
	        }
	      }

	      if (found) {
	        continue
	      }

	      // 2. Handle single query matches (i.e, once that are *not* quoted)
	      idx = -1;
	      while (++idx < searchersLen) {
	        const searcher = searchers[idx];
	        let token = searcher.isSingleMatch(queryItem);
	        if (token) {
	          results.push(new searcher(token, options));
	          break
	        }
	      }
	    }

	    return results
	  })
	}

	// These extended matchers can return an array of matches, as opposed
	// to a singl match
	const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

	/**
	 * Command-like searching
	 * ======================
	 *
	 * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
	 * search in a given text.
	 *
	 * Search syntax:
	 *
	 * | Token       | Match type                 | Description                            |
	 * | ----------- | -------------------------- | -------------------------------------- |
	 * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
	 * | `=scheme`   | exact-match                | Items that are `scheme`                |
	 * | `'python`   | include-match              | Items that include `python`            |
	 * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
	 * | `^java`     | prefix-exact-match         | Items that start with `java`           |
	 * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
	 * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
	 * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
	 *
	 * A single pipe character acts as an OR operator. For example, the following
	 * query matches entries that start with `core` and end with either`go`, `rb`,
	 * or`py`.
	 *
	 * ```
	 * ^core go$ | rb$ | py$
	 * ```
	 */
	class ExtendedSearch {
	  constructor(
	    pattern,
	    {
	      isCaseSensitive = Config.isCaseSensitive,
	      includeMatches = Config.includeMatches,
	      minMatchCharLength = Config.minMatchCharLength,
	      ignoreLocation = Config.ignoreLocation,
	      findAllMatches = Config.findAllMatches,
	      location = Config.location,
	      threshold = Config.threshold,
	      distance = Config.distance
	    } = {}
	  ) {
	    this.query = null;
	    this.options = {
	      isCaseSensitive,
	      includeMatches,
	      minMatchCharLength,
	      findAllMatches,
	      ignoreLocation,
	      location,
	      threshold,
	      distance
	    };

	    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
	    this.query = parseQuery(this.pattern, this.options);
	  }

	  static condition(_, options) {
	    return options.useExtendedSearch
	  }

	  searchIn(text) {
	    const query = this.query;

	    if (!query) {
	      return {
	        isMatch: false,
	        score: 1
	      }
	    }

	    const { includeMatches, isCaseSensitive } = this.options;

	    text = isCaseSensitive ? text : text.toLowerCase();

	    let numMatches = 0;
	    let allIndices = [];
	    let totalScore = 0;

	    // ORs
	    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
	      const searchers = query[i];

	      // Reset indices
	      allIndices.length = 0;
	      numMatches = 0;

	      // ANDs
	      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {
	        const searcher = searchers[j];
	        const { isMatch, indices, score } = searcher.search(text);

	        if (isMatch) {
	          numMatches += 1;
	          totalScore += score;
	          if (includeMatches) {
	            const type = searcher.constructor.type;
	            if (MultiMatchSet.has(type)) {
	              allIndices = [...allIndices, ...indices];
	            } else {
	              allIndices.push(indices);
	            }
	          }
	        } else {
	          totalScore = 0;
	          numMatches = 0;
	          allIndices.length = 0;
	          break
	        }
	      }

	      // OR condition, so if TRUE, return
	      if (numMatches) {
	        let result = {
	          isMatch: true,
	          score: totalScore / numMatches
	        };

	        if (includeMatches) {
	          result.indices = allIndices;
	        }

	        return result
	      }
	    }

	    // Nothing was matched
	    return {
	      isMatch: false,
	      score: 1
	    }
	  }
	}

	const registeredSearchers = [];

	function register(...args) {
	  registeredSearchers.push(...args);
	}

	function createSearcher(pattern, options) {
	  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
	    let searcherClass = registeredSearchers[i];
	    if (searcherClass.condition(pattern, options)) {
	      return new searcherClass(pattern, options)
	    }
	  }

	  return new BitapSearch(pattern, options)
	}

	const LogicalOperator = {
	  AND: '$and',
	  OR: '$or'
	};

	const KeyType = {
	  PATH: '$path',
	  PATTERN: '$val'
	};

	const isExpression = (query) =>
	  !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);

	const isPath = (query) => !!query[KeyType.PATH];

	const isLeaf = (query) =>
	  !isArray(query) && isObject(query) && !isExpression(query);

	const convertToExplicit = (query) => ({
	  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
	    [key]: query[key]
	  }))
	});

	// When `auto` is `true`, the parse function will infer and initialize and add
	// the appropriate `Searcher` instance
	function parse(query, options, { auto = true } = {}) {
	  const next = (query) => {
	    let keys = Object.keys(query);

	    const isQueryPath = isPath(query);

	    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
	      return next(convertToExplicit(query))
	    }

	    if (isLeaf(query)) {
	      const key = isQueryPath ? query[KeyType.PATH] : keys[0];

	      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];

	      if (!isString(pattern)) {
	        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))
	      }

	      const obj = {
	        keyId: createKeyId(key),
	        pattern
	      };

	      if (auto) {
	        obj.searcher = createSearcher(pattern, options);
	      }

	      return obj
	    }

	    let node = {
	      children: [],
	      operator: keys[0]
	    };

	    keys.forEach((key) => {
	      const value = query[key];

	      if (isArray(value)) {
	        value.forEach((item) => {
	          node.children.push(next(item));
	        });
	      }
	    });

	    return node
	  };

	  if (!isExpression(query)) {
	    query = convertToExplicit(query);
	  }

	  return next(query)
	}

	// Practical scoring function
	function computeScore(
	  results,
	  { ignoreFieldNorm = Config.ignoreFieldNorm }
	) {
	  results.forEach((result) => {
	    let totalScore = 1;

	    result.matches.forEach(({ key, norm, score }) => {
	      const weight = key ? key.weight : null;

	      totalScore *= Math.pow(
	        score === 0 && weight ? Number.EPSILON : score,
	        (weight || 1) * (ignoreFieldNorm ? 1 : norm)
	      );
	    });

	    result.score = totalScore;
	  });
	}

	function transformMatches(result, data) {
	  const matches = result.matches;
	  data.matches = [];

	  if (!isDefined(matches)) {
	    return
	  }

	  matches.forEach((match) => {
	    if (!isDefined(match.indices) || !match.indices.length) {
	      return
	    }

	    const { indices, value } = match;

	    let obj = {
	      indices,
	      value
	    };

	    if (match.key) {
	      obj.key = match.key.src;
	    }

	    if (match.idx > -1) {
	      obj.refIndex = match.idx;
	    }

	    data.matches.push(obj);
	  });
	}

	function transformScore(result, data) {
	  data.score = result.score;
	}

	function format(
	  results,
	  docs,
	  {
	    includeMatches = Config.includeMatches,
	    includeScore = Config.includeScore
	  } = {}
	) {
	  const transformers = [];

	  if (includeMatches) transformers.push(transformMatches);
	  if (includeScore) transformers.push(transformScore);

	  return results.map((result) => {
	    const { idx } = result;

	    const data = {
	      item: docs[idx],
	      refIndex: idx
	    };

	    if (transformers.length) {
	      transformers.forEach((transformer) => {
	        transformer(result, data);
	      });
	    }

	    return data
	  })
	}

	class Fuse {
	  constructor(docs, options = {}, index) {
	    this.options = { ...Config, ...options };

	    if (
	      this.options.useExtendedSearch &&
	      !true
	    ) ;

	    this._keyStore = new KeyStore(this.options.keys);

	    this.setCollection(docs, index);
	  }

	  setCollection(docs, index) {
	    this._docs = docs;

	    if (index && !(index instanceof FuseIndex)) {
	      throw new Error(INCORRECT_INDEX_TYPE)
	    }

	    this._myIndex =
	      index ||
	      createIndex(this.options.keys, this._docs, {
	        getFn: this.options.getFn,
	        fieldNormWeight: this.options.fieldNormWeight
	      });
	  }

	  add(doc) {
	    if (!isDefined(doc)) {
	      return
	    }

	    this._docs.push(doc);
	    this._myIndex.add(doc);
	  }

	  remove(predicate = (/* doc, idx */) => false) {
	    const results = [];

	    for (let i = 0, len = this._docs.length; i < len; i += 1) {
	      const doc = this._docs[i];
	      if (predicate(doc, i)) {
	        this.removeAt(i);
	        i -= 1;
	        len -= 1;

	        results.push(doc);
	      }
	    }

	    return results
	  }

	  removeAt(idx) {
	    this._docs.splice(idx, 1);
	    this._myIndex.removeAt(idx);
	  }

	  getIndex() {
	    return this._myIndex
	  }

	  search(query, { limit = -1 } = {}) {
	    const {
	      includeMatches,
	      includeScore,
	      shouldSort,
	      sortFn,
	      ignoreFieldNorm
	    } = this.options;

	    let results = isString(query)
	      ? isString(this._docs[0])
	        ? this._searchStringList(query)
	        : this._searchObjectList(query)
	      : this._searchLogical(query);

	    computeScore(results, { ignoreFieldNorm });

	    if (shouldSort) {
	      results.sort(sortFn);
	    }

	    if (isNumber(limit) && limit > -1) {
	      results = results.slice(0, limit);
	    }

	    return format(results, this._docs, {
	      includeMatches,
	      includeScore
	    })
	  }

	  _searchStringList(query) {
	    const searcher = createSearcher(query, this.options);
	    const { records } = this._myIndex;
	    const results = [];

	    // Iterate over every string in the index
	    records.forEach(({ v: text, i: idx, n: norm }) => {
	      if (!isDefined(text)) {
	        return
	      }

	      const { isMatch, score, indices } = searcher.searchIn(text);

	      if (isMatch) {
	        results.push({
	          item: text,
	          idx,
	          matches: [{ score, value: text, norm, indices }]
	        });
	      }
	    });

	    return results
	  }

	  _searchLogical(query) {

	    const expression = parse(query, this.options);

	    const evaluate = (node, item, idx) => {
	      if (!node.children) {
	        const { keyId, searcher } = node;

	        const matches = this._findMatches({
	          key: this._keyStore.get(keyId),
	          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
	          searcher
	        });

	        if (matches && matches.length) {
	          return [
	            {
	              idx,
	              item,
	              matches
	            }
	          ]
	        }

	        return []
	      }

	      const res = [];
	      for (let i = 0, len = node.children.length; i < len; i += 1) {
	        const child = node.children[i];
	        const result = evaluate(child, item, idx);
	        if (result.length) {
	          res.push(...result);
	        } else if (node.operator === LogicalOperator.AND) {
	          return []
	        }
	      }
	      return res
	    };

	    const records = this._myIndex.records;
	    const resultMap = {};
	    const results = [];

	    records.forEach(({ $: item, i: idx }) => {
	      if (isDefined(item)) {
	        let expResults = evaluate(expression, item, idx);

	        if (expResults.length) {
	          // Dedupe when adding
	          if (!resultMap[idx]) {
	            resultMap[idx] = { idx, item, matches: [] };
	            results.push(resultMap[idx]);
	          }
	          expResults.forEach(({ matches }) => {
	            resultMap[idx].matches.push(...matches);
	          });
	        }
	      }
	    });

	    return results
	  }

	  _searchObjectList(query) {
	    const searcher = createSearcher(query, this.options);
	    const { keys, records } = this._myIndex;
	    const results = [];

	    // List is Array<Object>
	    records.forEach(({ $: item, i: idx }) => {
	      if (!isDefined(item)) {
	        return
	      }

	      let matches = [];

	      // Iterate over every key (i.e, path), and fetch the value at that key
	      keys.forEach((key, keyIndex) => {
	        matches.push(
	          ...this._findMatches({
	            key,
	            value: item[keyIndex],
	            searcher
	          })
	        );
	      });

	      if (matches.length) {
	        results.push({
	          idx,
	          item,
	          matches
	        });
	      }
	    });

	    return results
	  }
	  _findMatches({ key, value, searcher }) {
	    if (!isDefined(value)) {
	      return []
	    }

	    let matches = [];

	    if (isArray(value)) {
	      value.forEach(({ v: text, i: idx, n: norm }) => {
	        if (!isDefined(text)) {
	          return
	        }

	        const { isMatch, score, indices } = searcher.searchIn(text);

	        if (isMatch) {
	          matches.push({
	            score,
	            key,
	            value: text,
	            idx,
	            norm,
	            indices
	          });
	        }
	      });
	    } else {
	      const { v: text, n: norm } = value;

	      const { isMatch, score, indices } = searcher.searchIn(text);

	      if (isMatch) {
	        matches.push({ score, key, value: text, norm, indices });
	      }
	    }

	    return matches
	  }
	}

	Fuse.version = '6.6.2';
	Fuse.createIndex = createIndex;
	Fuse.parseIndex = parseIndex;
	Fuse.config = Config;

	{
	  Fuse.parseQuery = parse;
	}

	{
	  register(ExtendedSearch);
	}




	/***/ }),

	/***/ 791:
	/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	// ESM COMPAT FLAG
	__webpack_require__.r(__webpack_exports__);

	// EXPORTS
	__webpack_require__.d(__webpack_exports__, {
	  "__DO_NOT_USE__ActionTypes": function() { return /* binding */ ActionTypes; },
	  "applyMiddleware": function() { return /* binding */ applyMiddleware; },
	  "bindActionCreators": function() { return /* binding */ bindActionCreators; },
	  "combineReducers": function() { return /* binding */ combineReducers; },
	  "compose": function() { return /* binding */ compose; },
	  "createStore": function() { return /* binding */ createStore; },
	  "legacy_createStore": function() { return /* binding */ legacy_createStore; }
	});
	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  }, _typeof(obj);
	}

	function _toPrimitive(input, hint) {
	  if (_typeof(input) !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];
	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (_typeof(res) !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (hint === "string" ? String : Number)(input);
	}


	function _toPropertyKey(arg) {
	  var key = _toPrimitive(arg, "string");
	  return _typeof(key) === "symbol" ? key : String(key);
	}

	function _defineProperty(obj, key, value) {
	  key = _toPropertyKey(key);
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}

	function ownKeys(object, enumerableOnly) {
	  var keys = Object.keys(object);
	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    enumerableOnly && (symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    })), keys.push.apply(keys, symbols);
	  }
	  return keys;
	}
	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = null != arguments[i] ? arguments[i] : {};
	    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
	      _defineProperty(target, key, source[key]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
	      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	    });
	  }
	  return target;
	}


	/**
	 * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
	 *
	 * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
	 * during build.
	 * @param {number} code
	 */
	function formatProdErrorMessage(code) {
	  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
	}

	// Inlined version of the `symbol-observable` polyfill
	var $$observable = (function () {
	  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
	})();

	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var randomString = function randomString() {
	  return Math.random().toString(36).substring(7).split('').join('.');
	};

	var ActionTypes = {
	  INIT: "@@redux/INIT" + randomString(),
	  REPLACE: "@@redux/REPLACE" + randomString(),
	  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
	    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
	  }
	};

	/**
	 * @param {any} obj The object to inspect.
	 * @returns {boolean} True if the argument appears to be a plain object.
	 */
	function isPlainObject(obj) {
	  if (typeof obj !== 'object' || obj === null) return false;
	  var proto = obj;

	  while (Object.getPrototypeOf(proto) !== null) {
	    proto = Object.getPrototypeOf(proto);
	  }

	  return Object.getPrototypeOf(obj) === proto;
	}

	/**
	 * @deprecated
	 *
	 * **We recommend using the `configureStore` method
	 * of the `@reduxjs/toolkit` package**, which replaces `createStore`.
	 *
	 * Redux Toolkit is our recommended approach for writing Redux logic today,
	 * including store setup, reducers, data fetching, and more.
	 *
	 * **For more details, please read this Redux docs page:**
	 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
	 *
	 * `configureStore` from Redux Toolkit is an improved version of `createStore` that
	 * simplifies setup and helps avoid common bugs.
	 *
	 * You should not be using the `redux` core package by itself today, except for learning purposes.
	 * The `createStore` method from the core `redux` package will not be removed, but we encourage
	 * all users to migrate to using Redux Toolkit for all Redux code.
	 *
	 * If you want to use `createStore` without this visual deprecation warning, use
	 * the `legacy_createStore` import instead:
	 *
	 * `import { legacy_createStore as createStore} from 'redux'`
	 *
	 */

	function createStore(reducer, preloadedState, enhancer) {
	  var _ref2;

	  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
	    throw new Error( formatProdErrorMessage(0) );
	  }

	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = preloadedState;
	    preloadedState = undefined;
	  }

	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error( formatProdErrorMessage(1) );
	    }

	    return enhancer(createStore)(reducer, preloadedState);
	  }

	  if (typeof reducer !== 'function') {
	    throw new Error( formatProdErrorMessage(2) );
	  }

	  var currentReducer = reducer;
	  var currentState = preloadedState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	  /**
	   * This makes a shallow copy of currentListeners so we can use
	   * nextListeners as a temporary list while dispatching.
	   *
	   * This prevents any bugs around consumers calling
	   * subscribe/unsubscribe in the middle of a dispatch.
	   */

	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }
	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */


	  function getState() {
	    if (isDispatching) {
	      throw new Error( formatProdErrorMessage(3) );
	    }

	    return currentState;
	  }
	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */


	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error( formatProdErrorMessage(4) );
	    }

	    if (isDispatching) {
	      throw new Error( formatProdErrorMessage(5) );
	    }

	    var isSubscribed = true;
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }

	      if (isDispatching) {
	        throw new Error( formatProdErrorMessage(6) );
	      }

	      isSubscribed = false;
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	      currentListeners = null;
	    };
	  }
	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing what changed. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */


	  function dispatch(action) {
	    if (!isPlainObject(action)) {
	      throw new Error( formatProdErrorMessage(7) );
	    }

	    if (typeof action.type === 'undefined') {
	      throw new Error( formatProdErrorMessage(8) );
	    }

	    if (isDispatching) {
	      throw new Error( formatProdErrorMessage(9) );
	    }

	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }

	    var listeners = currentListeners = nextListeners;

	    for (var i = 0; i < listeners.length; i++) {
	      var listener = listeners[i];
	      listener();
	    }

	    return action;
	  }
	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */


	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error( formatProdErrorMessage(10) );
	    }

	    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
	    // Any reducers that existed in both the new and old rootReducer
	    // will receive the previous state. This effectively populates
	    // the new state tree with any relevant data from the old one.

	    dispatch({
	      type: ActionTypes.REPLACE
	    });
	  }
	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/tc39/proposal-observable
	   */


	  function observable() {
	    var _ref;

	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object' || observer === null) {
	          throw new Error( formatProdErrorMessage(11) );
	        }

	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }

	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return {
	          unsubscribe: unsubscribe
	        };
	      }
	    }, _ref[$$observable] = function () {
	      return this;
	    }, _ref;
	  } // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.


	  dispatch({
	    type: ActionTypes.INIT
	  });
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[$$observable] = observable, _ref2;
	}
	/**
	 * Creates a Redux store that holds the state tree.
	 *
	 * **We recommend using `configureStore` from the
	 * `@reduxjs/toolkit` package**, which replaces `createStore`:
	 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
	 *
	 * The only way to change the data in the store is to call `dispatch()` on it.
	 *
	 * There should only be a single store in your app. To specify how different
	 * parts of the state tree respond to actions, you may combine several reducers
	 * into a single reducer function by using `combineReducers`.
	 *
	 * @param {Function} reducer A function that returns the next state tree, given
	 * the current state tree and the action to handle.
	 *
	 * @param {any} [preloadedState] The initial state. You may optionally specify it
	 * to hydrate the state from the server in universal apps, or to restore a
	 * previously serialized user session.
	 * If you use `combineReducers` to produce the root reducer function, this must be
	 * an object with the same shape as `combineReducers` keys.
	 *
	 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
	 * to enhance the store with third-party capabilities such as middleware,
	 * time travel, persistence, etc. The only store enhancer that ships with Redux
	 * is `applyMiddleware()`.
	 *
	 * @returns {Store} A Redux store that lets you read the state, dispatch actions
	 * and subscribe to changes.
	 */

	var legacy_createStore = createStore;

	function assertReducerShape(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, {
	      type: ActionTypes.INIT
	    });

	    if (typeof initialState === 'undefined') {
	      throw new Error( formatProdErrorMessage(12) );
	    }

	    if (typeof reducer(undefined, {
	      type: ActionTypes.PROBE_UNKNOWN_ACTION()
	    }) === 'undefined') {
	      throw new Error( formatProdErrorMessage(13) );
	    }
	  });
	}
	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */


	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};

	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];

	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }

	  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same

	  var shapeAssertionError;

	  try {
	    assertReducerShape(finalReducers);
	  } catch (e) {
	    shapeAssertionError = e;
	  }

	  return function combination(state, action) {
	    if (state === void 0) {
	      state = {};
	    }

	    if (shapeAssertionError) {
	      throw shapeAssertionError;
	    }

	    var hasChanged = false;
	    var nextState = {};

	    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
	      var _key = finalReducerKeys[_i];
	      var reducer = finalReducers[_key];
	      var previousStateForKey = state[_key];
	      var nextStateForKey = reducer(previousStateForKey, action);

	      if (typeof nextStateForKey === 'undefined') {
	        action && action.type;
	        throw new Error( formatProdErrorMessage(14) );
	      }

	      nextState[_key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }

	    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
	    return hasChanged ? nextState : state;
	  };
	}

	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(this, arguments));
	  };
	}
	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass an action creator as the first argument,
	 * and get a dispatch wrapped function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */


	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }

	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error( formatProdErrorMessage(16) );
	  }

	  var boundActionCreators = {};

	  for (var key in actionCreators) {
	    var actionCreator = actionCreators[key];

	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }

	  return boundActionCreators;
	}

	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */
	function compose() {
	  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }

	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  }

	  if (funcs.length === 1) {
	    return funcs[0];
	  }

	  return funcs.reduce(function (a, b) {
	    return function () {
	      return a(b.apply(void 0, arguments));
	    };
	  });
	}

	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */

	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }

	  return function (createStore) {
	    return function () {
	      var store = createStore.apply(void 0, arguments);

	      var _dispatch = function dispatch() {
	        throw new Error( formatProdErrorMessage(15) );
	      };

	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch() {
	          return _dispatch.apply(void 0, arguments);
	        }
	      };
	      var chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = compose.apply(void 0, chain)(store.dispatch);
	      return _objectSpread2(_objectSpread2({}, store), {}, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}




	/***/ })

	/******/ 	});
	/************************************************************************/
	/******/ 	// The module cache
	/******/ 	var __webpack_module_cache__ = {};
	/******/ 	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/ 		// Check if module is in cache
	/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
	/******/ 		if (cachedModule !== undefined) {
	/******/ 			return cachedModule.exports;
	/******/ 		}
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = __webpack_module_cache__[moduleId] = {
	/******/ 			// no module.id needed
	/******/ 			// no module.loaded needed
	/******/ 			exports: {}
	/******/ 		};
	/******/ 	
	/******/ 		// Execute the module function
	/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/ 	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/ 	
	/************************************************************************/
	/******/ 	/* webpack/runtime/compat get default export */
	/******/ 	!function() {
	/******/ 		// getDefaultExport function for compatibility with non-harmony modules
	/******/ 		__webpack_require__.n = function(module) {
	/******/ 			var getter = module && module.__esModule ?
	/******/ 				function() { return module['default']; } :
	/******/ 				function() { return module; };
	/******/ 			__webpack_require__.d(getter, { a: getter });
	/******/ 			return getter;
	/******/ 		};
	/******/ 	}();
	/******/ 	
	/******/ 	/* webpack/runtime/define property getters */
	/******/ 	!function() {
	/******/ 		// define getter functions for harmony exports
	/******/ 		__webpack_require__.d = function(exports, definition) {
	/******/ 			for(var key in definition) {
	/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
	/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
	/******/ 				}
	/******/ 			}
	/******/ 		};
	/******/ 	}();
	/******/ 	
	/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
	/******/ 	!function() {
	/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); };
	/******/ 	}();
	/******/ 	
	/******/ 	/* webpack/runtime/make namespace object */
	/******/ 	!function() {
	/******/ 		// define __esModule on exports
	/******/ 		__webpack_require__.r = function(exports) {
	/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
	/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
	/******/ 			}
	/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
	/******/ 		};
	/******/ 	}();
	/******/ 	
	/************************************************************************/
	var __webpack_exports__ = {};
	// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
	!function() {
	/* harmony import */ var _scripts_choices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(373);
	/* harmony import */ var _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_scripts_choices__WEBPACK_IMPORTED_MODULE_0__);
	/* harmony import */ __webpack_require__(187);
	/* harmony import */ __webpack_require__(883);
	/* harmony import */ __webpack_require__(789);
	/* harmony import */ __webpack_require__(686);







	/* harmony default export */ __webpack_exports__["default"] = ((_scripts_choices__WEBPACK_IMPORTED_MODULE_0___default()));

	}();
	__webpack_exports__ = __webpack_exports__["default"];
	/******/ 	return __webpack_exports__;
	/******/ })()
	;
	});
	});

	var Choices = unwrapExports(choices);

	/**
	 * This class is responsible for setting up the Modal component.
	 *
	 * @since 1.4.5
	 */
	class ModalComponent {
	  /**
	   * Constructor.
	   *
	   * @param modalData
	   */
	  constructor(modalData) {
	    this.modalData = modalData;
	    this.$parent = jQuery('body');
	    this.isScrollable = this.modalData.scrollable || false;
	    this.initializeModal();
	    this.cacheModalElements();
	    this.initializeModalEvents();
	  }

	  /**
	   * Initialize the modal.
	   *
	   * @since 1.4.5
	   */
	  initializeModal() {
	    let scrollableClass = this.isScrollable ? ' searchwp-metrics__modal-scrollable' : '';

	    // HTML structure for the Modal.
	    // phpcs:disable
	    const modalHTML = `
			<div class="searchwp-metrics__modal ${this.modalData.classes}" data-swp-modal="${this.modalData.name}">
				<div class="searchwp-metrics__modal-overlay"></div>
				<div class="searchwp-metrics__modal-content${scrollableClass}" style="width:${this.modalData.width};">
					<div class="searchwp-metrics__modal-header">
						<h4>${this.modalData.title}</h4>
						<div class="searchwp-metrics__modal-close" aria-label="Close Modal">
							<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" fill="#292c34"></path></svg>
						</div>
					</div>
					<div class="searchwp-metrics__modal-body"></div>
				</div>
			</div>
		`;
	    // phpcs:enable

	    // Append the modal HTML to the body element.
	    jQuery('body').append(modalHTML);
	  }

	  /**
	   * Cache the modal elements.
	   *
	   * @since 1.4.5
	   */
	  cacheModalElements() {
	    this.$modal = jQuery('[data-swp-modal="' + this.modalData.name + '"]').last();
	    this.$close = this.$modal.find('.searchwp-metrics__modal-close');
	    this.$content = this.$modal.find('.searchwp-metrics__modal-body');
	  }

	  /**
	   * Initialize the modal events.
	   *
	   * @since 1.4.5
	   */
	  initializeModalEvents() {
	    let self = this;
	    this.$close.on('click', this.closeModal.bind(self));

	    // Close modal if clicked outside the modal.
	    jQuery(document).on('click', '.searchwp-metrics__modal-overlay', function () {
	      if (self.$modal.hasClass('show')) {
	        self.closeModal();
	      }
	    });

	    // Close modal if the escape key is pressed and the modal is open.
	    jQuery(document).on('keydown', function (event) {
	      if (event.key === 'Escape' && self.$modal.hasClass('show')) {
	        self.closeModal();
	      }
	    });
	  }

	  /**
	   * Open the modal.
	   *
	   * @since 1.4.5
	   */
	  openModal() {
	    this.$modal.addClass('show');

	    // Prevent scrolling on the body.
	    jQuery('body').css('overflow', 'hidden');
	  }

	  /**
	   * Close the modal.
	   *
	   * @since 1.4.5
	   */
	  closeModal() {
	    this.$modal.removeClass('show');

	    // Allow scrolling on the body.
	    jQuery('body').css('overflow', 'auto');
	  }
	}

	/**
	 * This class is responsible for setting up the Ignored Queries modal.
	 *
	 * @since 1.4.5
	 */
	class IgnoredQueriesModal extends ModalComponent {
	  constructor() {
	    super({
	      name: 'ignored-queries',
	      title: Utils.getI18nString('ignored_searches'),
	      width: '600px',
	      classes: 'searchwp-metrics__ignored-queries-modal',
	      scrollable: true
	    });
	    this.ignoredQueries = null;
	    this.updateOnCLose = false;
	    this.isInputOpen = false;
	    this.updateContent();
	    this.initializeEvents();
	  }

	  /**
	   * Update the content of the modal.
	   *
	   * @since 1.4.5
	   *
	   * @param ignoredQueries
	   */
	  updateContent(ignoredQueries) {
	    this.ignoredQueries = ignoredQueries || null;

	    // phpcs:disable
	    this.$content.html(`
			<p>${Utils.getI18nString('ignored_message')}</p>
			<p>
				<input type="text" id="searchwp-metrics__ignore_query_input" class="searchwp-metrics__hidden" placeholder="${Utils.getI18nString('ignore_query_prompt')}">
				<span class="loading-spinner searchwp-metrics__modal-loading-spinner searchwp-metrics__hidden"></span>
				<button class="button searchwp-metrics__ignore_query">${Utils.getI18nString('add')}</button>
			</p>
			${this.getIgnoredQueriesElements(ignoredQueries)}
		`);
	    // phpcs:enable
	  }

	  /**
	   * Get the ignored queries elements.
	   *
	   * @since 1.4.5
	   *
	   * @param ignoredQueries
	   *
	   * @returns {string}
	   */
	  getIgnoredQueriesElements(ignoredQueries) {
	    // If this.engineData.failedSearches is not an array or is empty, return a message.
	    if (!Array.isArray(ignoredQueries) || !ignoredQueries.length) {
	      // phpcs:disable
	      return `
				<div class="searchwp-metrics__note">
					<span class="dashicons dashicons-info"></span>
					<div><p>${Utils.getI18nString('no_ignored_queries')}</p></div>
				</div>
			`;
	      // phpcs:enable
	    }
	    let tableElements = '';

	    // phpcs:disable
	    tableElements = `
			<table>
				<thead>
					<tr>
						<th>${Utils.getI18nString('ignored_search_query')}</th>
					</tr>
				</thead>
				<tbody>
					${this.getIgnoredQueriesRows(ignoredQueries)}
				</tbody>
			</table>
		`;
	    // phpcs:enable

	    return tableElements;
	  }

	  /**
	   * Get the ignored queries rows.
	   *
	   * @since 1.4.5
	   *
	   * @param ignoredQueries
	   *
	   * @returns {*}
	   */
	  getIgnoredQueriesRows(ignoredQueries) {
	    return ignoredQueries.map((ignoredQuery, index) => {
	      // phpcs:disable
	      return `
				<tr>
					<td>
						<button title="${Utils.getI18nString('stop_ignoring_query')}" class="searchwp-delete dashicons dashicons-dismiss" data-ignored-query-hash="${ignoredQuery.hash}"></button>
						${ignoredQuery.query}
					</td>
				</tr>
			`;
	      // phpcs:enable
	    }).join('');
	  }

	  /**
	   * Initialize the events for the Ignored Queries modal.
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    let self = this;
	    this.$content.on('click', '.searchwp-delete', function () {
	      self.unignoreQuery(jQuery(this).data('ignored-query-hash')).then(() => {
	        self.updateOnCLose = true;
	      });
	    });
	    jQuery(document).on('searchwp-metrics__ignore-query', function (event, query, triggerUpdate) {
	      self.ignoreQuery(query, triggerUpdate);
	    });

	    // If Add button is clicked, show an input field to ask for a query to ignore.
	    self.$content.on('click', '.searchwp-metrics__ignore_query', function () {
	      if (self.isInputOpen) {
	        let $input = jQuery('#searchwp-metrics__ignore_query_input');
	        let newIgnoredSearch = $input.val().trim();
	        $input.val('');
	        if (newIgnoredSearch && newIgnoredSearch.length) {
	          self.ignoreQuery(newIgnoredSearch);
	        }
	        jQuery('#searchwp-metrics__ignore_query_input').addClass('searchwp-metrics__hidden');
	        self.updateOnCLose = true;
	        self.isInputOpen = false;
	      } else {
	        jQuery('#searchwp-metrics__ignore_query_input').removeClass('searchwp-metrics__hidden').focus();
	        self.isInputOpen = true;
	      }
	    });
	  }

	  /**
	   * Ignore a query.
	   *
	   * @since 1.4.5
	   *
	   * @param ignoredQuery
	   * @param triggerUpdate
	   *
	   * @returns {Promise<void>}
	   */
	  ignoreQuery(ignoredQuery) {
	    let triggerUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    // Make query lowercase.
	    ignoredQuery = ignoredQuery.toLowerCase();

	    // If the ignored query is already in the list, return.
	    if (this.ignoredQueries.some(query => query.query === ignoredQuery)) {
	      return;
	    }
	    this.$content.find('.loading-spinner').removeClass('searchwp-metrics__hidden');
	    let payload = {
	      action: 'searchwp_metrics_ignore_query',
	      query: ignoredQuery
	    };
	    return Utils.apiRequest(payload).then(response => {
	      // Add the new ignored query to the list.
	      this.ignoredQueries.push({
	        query: ignoredQuery,
	        hash: response.data.hash
	      });
	      this.updateContent(this.ignoredQueries);
	      this.$content.find('.loading-spinner').addClass('searchwp-metrics__hidden');
	      if (triggerUpdate) {
	        jQuery(document).trigger('searchwp-metrics__needs-update');
	      }
	    });
	  }

	  /**
	   * Unignore a query.
	   *
	   * @since 1.4.5
	   *
	   * @param hash
	   *
	   * @returns {Promise<unknown>}
	   */
	  unignoreQuery(hash) {
	    // Remove the ignored query from the list using the hash.
	    this.ignoredQueries = this.ignoredQueries.filter(ignoredQuery => ignoredQuery.hash !== hash);
	    this.updateContent(this.ignoredQueries);
	    this.updateOnCLose = true;
	    let payload = {
	      action: 'searchwp_metrics_unignore_query',
	      hash: hash
	    };
	    return Utils.apiRequest(payload);
	  }

	  /**
	   * Open the modal.
	   *
	   * @since 1.4.5
	   */
	  closeModal() {
	    super.closeModal();
	    if (this.updateOnCLose) {
	      this.updateOnCLose = false;
	      jQuery(document).trigger('searchwp-metrics__needs-update');
	    }
	  }
	}

	class SearchQueryControl {
	  constructor($controls) {
	    this.$controls = $controls;
	    this.choices = null;
	    this.ignoredQueries = [];
	    this.$control = this.initializeControl();
	    this.cacheElements();
	    this.initializeEvents();
	  }
	  initializeControl() {
	    // HTML structure for the choices.js control.
	    // phpcs:disable
	    const controlHTML = `
            <div class="searchwp-metrics__control">
                <h4>${Utils.getI18nString('search_query_controls')}</h4>
                <div class="searchwp-metrics__control-queries searchwp-metrics__disable-on-loading">
                    <select class="multiselect" multiple></select>
                    <button class="button">${Utils.getI18nString('ignored')}: <span>0</span></button>
                </div>
            </div>
        `;
	    // phpcs:enable

	    // Append the control HTML to the parent element.
	    if (this.$controls) {
	      this.$controls.append(controlHTML);
	    }

	    // Add a modal for the ignored searches.
	    this.ignoredQueriesModal = new IgnoredQueriesModal();

	    // Get new select element.
	    const $select = this.$controls.find('.searchwp-metrics__control-queries select')[0];

	    // Initialize choices.js with the following configuration.
	    this.choices = new Choices($select, {
	      allowHTML: false,
	      removeItemButton: true,
	      searchEnabled: true,
	      searchPlaceholderValue: Utils.getI18nString('limit_metrics_to_queries'),
	      placeholder: true,
	      placeholderValue: Utils.getI18nString('limit_metrics_to_queries'),
	      loadingText: '',
	      noResultsText: '',
	      noChoicesText: Utils.getI18nString('type_search_query'),
	      itemSelectText: '',
	      maxItemCount: -1,
	      searchResultLimit: 10,
	      renderChoiceLimit: 10,
	      searchFields: ['label', 'value'],
	      searchFloor: 3,
	      fuseOptions: {
	        threshold: 0.3
	      },
	      callbackOnCreateTemplates: function (template) {
	        return {
	          choice: (classNames, data) => {
	            let selectText = this.config.itemSelectText;

	            // Customize the select text based on the option's value.
	            if (data.value === data.label) {
	              selectText = Utils.getI18nString('add_as_partial_match');
	            } else {
	              selectText = Utils.getI18nString('add_as_exact_match');
	            }

	            // phpcs:disable
	            return template(`
								<div class="${classNames.item} ${classNames.itemChoice} ${data.disabled ? classNames.itemDisabled : classNames.itemSelectable}" data-select-text="${selectText}" data-choice ${data.disabled ? 'data-choice-disabled aria-disabled="true"' : 'data-choice-selectable'} data-id="${data.id}" data-value="${data.value}" ${data.groupId > 0 ? 'role="treeitem"' : 'role="option"'}>
									${data.label}
									<span>${selectText}</span>
								</div>
								`);
	            // phpcs:enable
	          }
	        };
	      }
	    });
	  }
	  cacheElements() {
	    this.$control = jQuery(this.choices.passedElement.element);
	    this.$spinner = jQuery('.searchwp-metrics__control-queries .choices:before');
	    this.$ignoredQueryButton = this.$controls.find('.searchwp-metrics__control-queries button');
	    this.$ignoredQueryCount = this.$controls.find('.searchwp-metrics__control-queries button span');
	  }
	  handleSearch(event) {
	    const searchTerm = event.detail.value;
	    this.fetchOptions(searchTerm);
	  }
	  fetchOptions(searchTerm) {
	    jQuery('.searchwp-metrics__control-queries').addClass('is-loading');
	    this.choices.setChoices([], 'value', 'label', true);
	    this.choices.setChoiceByValue('');
	    this.choices.clearChoices();
	    Utils.apiRequest({
	      action: 'searchwp_metrics_search_queries',
	      searchquery: searchTerm
	    }).then(response => {
	      if (response.success) {
	        // If the response data is an empty array, add a default option with the search term.
	        if (response.data.length === 0) {
	          response.data.push({
	            id: searchTerm,
	            query: searchTerm
	          });
	        }
	        const options = response.data.map(item => ({
	          value: item.id,
	          label: item.query
	        }));
	        this.choices.setChoices(options, 'value', 'label', true);
	      }
	      jQuery('.searchwp-metrics__control-queries').removeClass('is-loading');
	    });
	  }
	  initializeEvents() {
	    const self = this;
	    this.$control.on('search', function (event) {
	      const searchTerm = event.detail.value;
	      self.fetchOptions(searchTerm);
	    });
	    jQuery(this.$control).on('change', function () {
	      jQuery(document).trigger('searchwp-metrics__needs-update');
	    });
	    this.$ignoredQueryButton.on('click', this.ignoredQueriesModal.openModal.bind(this.ignoredQueriesModal));
	  }
	  getSelectedQueries() {
	    return this.choices.getValue(true);
	  }
	  updateIgnoredQueries(ignoredQueries) {
	    this.ignoredQueries = ignoredQueries;

	    // Update the ignored queries count.
	    this.$ignoredQueryCount.text(ignoredQueries.length);

	    // Update the ignored queries modal.
	    this.ignoredQueriesModal.updateContent(ignoredQueries);

	    // Toggle the Remove Ignored Queries menu item.
	    Utils.triggerToggleMenuItem('clear-ignored-queries', ignoredQueries.length > 0);
	  }
	}

	/**
	 * This class is responsible for setting up the Engines control.
	 *
	 * @since 1.4.5
	 */
	class EnginesControl {
	  constructor($controls) {
	    this.$controls = $controls;
	    this.choices = null;
	    this.$control = null;
	    this.$select = null;
	    this.initializeControl();
	    this.initializeEvents();
	  }

	  /**
	   * Initialize the Engines control.
	   *
	   * @since 1.4.5
	   */
	  initializeControl() {
	    // HTML structure for the EnginesDetails select.
	    // phpcs:disable
	    const controlHTML = `
			<div class="searchwp-metrics__control">
				<h4>${Utils.getI18nString('engines_to_display')}</h4>
				<div class="searchwp-metrics__control-engines searchwp-metrics__disable-on-loading">
                    <select class="multiselect" multiple></select>
                </div>
			</div>
		`;
	    // phpcs:enable

	    // Append the control HTML to the parent element.
	    if (this.$controls) {
	      this.$control = jQuery(controlHTML).appendTo(this.$controls);
	      this.$select = this.$control.find('select');
	      let choices = Utils.getEngines();

	      // Initialize choices.js.
	      this.choices = new Choices(this.$select[0], {
	        allowHTML: false,
	        removeItemButton: true,
	        searchEnabled: false,
	        duplicateItemsAllowed: false,
	        choices: choices,
	        noChoicesText: Utils.getI18nString('all_engines_selected'),
	        placeholder: true,
	        placeholderValue: Utils.getI18nString('choose_engine')
	      });
	    }
	  }

	  /**
	   * Initialize the events for the Engines control.
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    let self = this;
	    self.toggleChoices();
	    this.$control.on('change', function () {
	      self.toggleChoices();
	      jQuery(document).trigger('searchwp-metrics__needs-update');
	    });
	    this.$control.on('choice', function () {
	      self.choices.hideDropdown();
	    });
	  }

	  /**
	   * Toggle the choices based on the selected engines.
	   *
	   * @since 1.4.5
	   */
	  toggleChoices() {
	    let selectedEngines = this.choices.getValue();
	    let choicesItemsButton = this.$control.find('.choices__list--multiple .choices__item');
	    if (selectedEngines.length > 1) {
	      choicesItemsButton.removeClass('choices__item--disabled');
	    } else {
	      choicesItemsButton.addClass('choices__item--disabled');
	    }
	  }

	  /**
	   * Get the selected engines.
	   *
	   * @since 1.4.5
	   *
	   * @returns {*}
	   */
	  getSelectedEngines() {
	    return this.choices.getValue(true);
	  }
	}

	function _defineProperty(e, r, t) {
	  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
	    value: t,
	    enumerable: !0,
	    configurable: !0,
	    writable: !0
	  }) : e[r] = t, e;
	}
	function ownKeys(e, r) {
	  var t = Object.keys(e);
	  if (Object.getOwnPropertySymbols) {
	    var o = Object.getOwnPropertySymbols(e);
	    r && (o = o.filter(function (r) {
	      return Object.getOwnPropertyDescriptor(e, r).enumerable;
	    })), t.push.apply(t, o);
	  }
	  return t;
	}
	function _objectSpread2(e) {
	  for (var r = 1; r < arguments.length; r++) {
	    var t = null != arguments[r] ? arguments[r] : {};
	    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
	      _defineProperty(e, r, t[r]);
	    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
	      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
	    });
	  }
	  return e;
	}
	function _toPrimitive(t, r) {
	  if ("object" != typeof t || !t) return t;
	  var e = t[Symbol.toPrimitive];
	  if (void 0 !== e) {
	    var i = e.call(t, r || "default");
	    if ("object" != typeof i) return i;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return ("string" === r ? String : Number)(t);
	}
	function _toPropertyKey(t) {
	  var i = _toPrimitive(t, "string");
	  return "symbol" == typeof i ? i : i + "";
	}

	/*!
	 * @kurkle/color v0.3.2
	 * https://github.com/kurkle/color#readme
	 * (c) 2023 Jukka Kurkela
	 * Released under the MIT License
	 */
	function round(v) {
	  return v + 0.5 | 0;
	}
	const lim = (v, l, h) => Math.max(Math.min(v, h), l);
	function p2b(v) {
	  return lim(round(v * 2.55), 0, 255);
	}
	function n2b(v) {
	  return lim(round(v * 255), 0, 255);
	}
	function b2n(v) {
	  return lim(round(v / 2.55) / 100, 0, 1);
	}
	function n2p(v) {
	  return lim(round(v * 100), 0, 100);
	}

	const map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
	const hex = [...'0123456789ABCDEF'];
	const h1 = b => hex[b & 0xF];
	const h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];
	const eq = b => ((b & 0xF0) >> 4) === (b & 0xF);
	const isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
	function hexParse(str) {
	  var len = str.length;
	  var ret;
	  if (str[0] === '#') {
	    if (len === 4 || len === 5) {
	      ret = {
	        r: 255 & map$1[str[1]] * 17,
	        g: 255 & map$1[str[2]] * 17,
	        b: 255 & map$1[str[3]] * 17,
	        a: len === 5 ? map$1[str[4]] * 17 : 255
	      };
	    } else if (len === 7 || len === 9) {
	      ret = {
	        r: map$1[str[1]] << 4 | map$1[str[2]],
	        g: map$1[str[3]] << 4 | map$1[str[4]],
	        b: map$1[str[5]] << 4 | map$1[str[6]],
	        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255
	      };
	    }
	  }
	  return ret;
	}
	const alpha = (a, f) => a < 255 ? f(a) : '';
	function hexString(v) {
	  var f = isShort(v) ? h1 : h2;
	  return v
	    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)
	    : undefined;
	}

	const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
	function hsl2rgbn(h, s, l) {
	  const a = s * Math.min(l, 1 - l);
	  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
	  return [f(0), f(8), f(4)];
	}
	function hsv2rgbn(h, s, v) {
	  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
	  return [f(5), f(3), f(1)];
	}
	function hwb2rgbn(h, w, b) {
	  const rgb = hsl2rgbn(h, 1, 0.5);
	  let i;
	  if (w + b > 1) {
	    i = 1 / (w + b);
	    w *= i;
	    b *= i;
	  }
	  for (i = 0; i < 3; i++) {
	    rgb[i] *= 1 - w - b;
	    rgb[i] += w;
	  }
	  return rgb;
	}
	function hueValue(r, g, b, d, max) {
	  if (r === max) {
	    return ((g - b) / d) + (g < b ? 6 : 0);
	  }
	  if (g === max) {
	    return (b - r) / d + 2;
	  }
	  return (r - g) / d + 4;
	}
	function rgb2hsl(v) {
	  const range = 255;
	  const r = v.r / range;
	  const g = v.g / range;
	  const b = v.b / range;
	  const max = Math.max(r, g, b);
	  const min = Math.min(r, g, b);
	  const l = (max + min) / 2;
	  let h, s, d;
	  if (max !== min) {
	    d = max - min;
	    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	    h = hueValue(r, g, b, d, max);
	    h = h * 60 + 0.5;
	  }
	  return [h | 0, s || 0, l];
	}
	function calln(f, a, b, c) {
	  return (
	    Array.isArray(a)
	      ? f(a[0], a[1], a[2])
	      : f(a, b, c)
	  ).map(n2b);
	}
	function hsl2rgb(h, s, l) {
	  return calln(hsl2rgbn, h, s, l);
	}
	function hwb2rgb(h, w, b) {
	  return calln(hwb2rgbn, h, w, b);
	}
	function hsv2rgb(h, s, v) {
	  return calln(hsv2rgbn, h, s, v);
	}
	function hue(h) {
	  return (h % 360 + 360) % 360;
	}
	function hueParse(str) {
	  const m = HUE_RE.exec(str);
	  let a = 255;
	  let v;
	  if (!m) {
	    return;
	  }
	  if (m[5] !== v) {
	    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
	  }
	  const h = hue(+m[2]);
	  const p1 = +m[3] / 100;
	  const p2 = +m[4] / 100;
	  if (m[1] === 'hwb') {
	    v = hwb2rgb(h, p1, p2);
	  } else if (m[1] === 'hsv') {
	    v = hsv2rgb(h, p1, p2);
	  } else {
	    v = hsl2rgb(h, p1, p2);
	  }
	  return {
	    r: v[0],
	    g: v[1],
	    b: v[2],
	    a: a
	  };
	}
	function rotate(v, deg) {
	  var h = rgb2hsl(v);
	  h[0] = hue(h[0] + deg);
	  h = hsl2rgb(h);
	  v.r = h[0];
	  v.g = h[1];
	  v.b = h[2];
	}
	function hslString(v) {
	  if (!v) {
	    return;
	  }
	  const a = rgb2hsl(v);
	  const h = a[0];
	  const s = n2p(a[1]);
	  const l = n2p(a[2]);
	  return v.a < 255
	    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
	    : `hsl(${h}, ${s}%, ${l}%)`;
	}

	const map = {
	  x: 'dark',
	  Z: 'light',
	  Y: 're',
	  X: 'blu',
	  W: 'gr',
	  V: 'medium',
	  U: 'slate',
	  A: 'ee',
	  T: 'ol',
	  S: 'or',
	  B: 'ra',
	  C: 'lateg',
	  D: 'ights',
	  R: 'in',
	  Q: 'turquois',
	  E: 'hi',
	  P: 'ro',
	  O: 'al',
	  N: 'le',
	  M: 'de',
	  L: 'yello',
	  F: 'en',
	  K: 'ch',
	  G: 'arks',
	  H: 'ea',
	  I: 'ightg',
	  J: 'wh'
	};
	const names$1 = {
	  OiceXe: 'f0f8ff',
	  antiquewEte: 'faebd7',
	  aqua: 'ffff',
	  aquamarRe: '7fffd4',
	  azuY: 'f0ffff',
	  beige: 'f5f5dc',
	  bisque: 'ffe4c4',
	  black: '0',
	  blanKedOmond: 'ffebcd',
	  Xe: 'ff',
	  XeviTet: '8a2be2',
	  bPwn: 'a52a2a',
	  burlywood: 'deb887',
	  caMtXe: '5f9ea0',
	  KartYuse: '7fff00',
	  KocTate: 'd2691e',
	  cSO: 'ff7f50',
	  cSnflowerXe: '6495ed',
	  cSnsilk: 'fff8dc',
	  crimson: 'dc143c',
	  cyan: 'ffff',
	  xXe: '8b',
	  xcyan: '8b8b',
	  xgTMnPd: 'b8860b',
	  xWay: 'a9a9a9',
	  xgYF: '6400',
	  xgYy: 'a9a9a9',
	  xkhaki: 'bdb76b',
	  xmagFta: '8b008b',
	  xTivegYF: '556b2f',
	  xSange: 'ff8c00',
	  xScEd: '9932cc',
	  xYd: '8b0000',
	  xsOmon: 'e9967a',
	  xsHgYF: '8fbc8f',
	  xUXe: '483d8b',
	  xUWay: '2f4f4f',
	  xUgYy: '2f4f4f',
	  xQe: 'ced1',
	  xviTet: '9400d3',
	  dAppRk: 'ff1493',
	  dApskyXe: 'bfff',
	  dimWay: '696969',
	  dimgYy: '696969',
	  dodgerXe: '1e90ff',
	  fiYbrick: 'b22222',
	  flSOwEte: 'fffaf0',
	  foYstWAn: '228b22',
	  fuKsia: 'ff00ff',
	  gaRsbSo: 'dcdcdc',
	  ghostwEte: 'f8f8ff',
	  gTd: 'ffd700',
	  gTMnPd: 'daa520',
	  Way: '808080',
	  gYF: '8000',
	  gYFLw: 'adff2f',
	  gYy: '808080',
	  honeyMw: 'f0fff0',
	  hotpRk: 'ff69b4',
	  RdianYd: 'cd5c5c',
	  Rdigo: '4b0082',
	  ivSy: 'fffff0',
	  khaki: 'f0e68c',
	  lavFMr: 'e6e6fa',
	  lavFMrXsh: 'fff0f5',
	  lawngYF: '7cfc00',
	  NmoncEffon: 'fffacd',
	  ZXe: 'add8e6',
	  ZcSO: 'f08080',
	  Zcyan: 'e0ffff',
	  ZgTMnPdLw: 'fafad2',
	  ZWay: 'd3d3d3',
	  ZgYF: '90ee90',
	  ZgYy: 'd3d3d3',
	  ZpRk: 'ffb6c1',
	  ZsOmon: 'ffa07a',
	  ZsHgYF: '20b2aa',
	  ZskyXe: '87cefa',
	  ZUWay: '778899',
	  ZUgYy: '778899',
	  ZstAlXe: 'b0c4de',
	  ZLw: 'ffffe0',
	  lime: 'ff00',
	  limegYF: '32cd32',
	  lRF: 'faf0e6',
	  magFta: 'ff00ff',
	  maPon: '800000',
	  VaquamarRe: '66cdaa',
	  VXe: 'cd',
	  VScEd: 'ba55d3',
	  VpurpN: '9370db',
	  VsHgYF: '3cb371',
	  VUXe: '7b68ee',
	  VsprRggYF: 'fa9a',
	  VQe: '48d1cc',
	  VviTetYd: 'c71585',
	  midnightXe: '191970',
	  mRtcYam: 'f5fffa',
	  mistyPse: 'ffe4e1',
	  moccasR: 'ffe4b5',
	  navajowEte: 'ffdead',
	  navy: '80',
	  Tdlace: 'fdf5e6',
	  Tive: '808000',
	  TivedBb: '6b8e23',
	  Sange: 'ffa500',
	  SangeYd: 'ff4500',
	  ScEd: 'da70d6',
	  pOegTMnPd: 'eee8aa',
	  pOegYF: '98fb98',
	  pOeQe: 'afeeee',
	  pOeviTetYd: 'db7093',
	  papayawEp: 'ffefd5',
	  pHKpuff: 'ffdab9',
	  peru: 'cd853f',
	  pRk: 'ffc0cb',
	  plum: 'dda0dd',
	  powMrXe: 'b0e0e6',
	  purpN: '800080',
	  YbeccapurpN: '663399',
	  Yd: 'ff0000',
	  Psybrown: 'bc8f8f',
	  PyOXe: '4169e1',
	  saddNbPwn: '8b4513',
	  sOmon: 'fa8072',
	  sandybPwn: 'f4a460',
	  sHgYF: '2e8b57',
	  sHshell: 'fff5ee',
	  siFna: 'a0522d',
	  silver: 'c0c0c0',
	  skyXe: '87ceeb',
	  UXe: '6a5acd',
	  UWay: '708090',
	  UgYy: '708090',
	  snow: 'fffafa',
	  sprRggYF: 'ff7f',
	  stAlXe: '4682b4',
	  tan: 'd2b48c',
	  teO: '8080',
	  tEstN: 'd8bfd8',
	  tomato: 'ff6347',
	  Qe: '40e0d0',
	  viTet: 'ee82ee',
	  JHt: 'f5deb3',
	  wEte: 'ffffff',
	  wEtesmoke: 'f5f5f5',
	  Lw: 'ffff00',
	  LwgYF: '9acd32'
	};
	function unpack() {
	  const unpacked = {};
	  const keys = Object.keys(names$1);
	  const tkeys = Object.keys(map);
	  let i, j, k, ok, nk;
	  for (i = 0; i < keys.length; i++) {
	    ok = nk = keys[i];
	    for (j = 0; j < tkeys.length; j++) {
	      k = tkeys[j];
	      nk = nk.replace(k, map[k]);
	    }
	    k = parseInt(names$1[ok], 16);
	    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
	  }
	  return unpacked;
	}

	let names;
	function nameParse(str) {
	  if (!names) {
	    names = unpack();
	    names.transparent = [0, 0, 0, 0];
	  }
	  const a = names[str.toLowerCase()];
	  return a && {
	    r: a[0],
	    g: a[1],
	    b: a[2],
	    a: a.length === 4 ? a[3] : 255
	  };
	}

	const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
	function rgbParse(str) {
	  const m = RGB_RE.exec(str);
	  let a = 255;
	  let r, g, b;
	  if (!m) {
	    return;
	  }
	  if (m[7] !== r) {
	    const v = +m[7];
	    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
	  }
	  r = +m[1];
	  g = +m[3];
	  b = +m[5];
	  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
	  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
	  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
	  return {
	    r: r,
	    g: g,
	    b: b,
	    a: a
	  };
	}
	function rgbString(v) {
	  return v && (
	    v.a < 255
	      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
	      : `rgb(${v.r}, ${v.g}, ${v.b})`
	  );
	}

	const to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;
	const from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
	function interpolate$1(rgb1, rgb2, t) {
	  const r = from(b2n(rgb1.r));
	  const g = from(b2n(rgb1.g));
	  const b = from(b2n(rgb1.b));
	  return {
	    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
	    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
	    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
	    a: rgb1.a + t * (rgb2.a - rgb1.a)
	  };
	}

	function modHSL(v, i, ratio) {
	  if (v) {
	    let tmp = rgb2hsl(v);
	    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
	    tmp = hsl2rgb(tmp);
	    v.r = tmp[0];
	    v.g = tmp[1];
	    v.b = tmp[2];
	  }
	}
	function clone$1(v, proto) {
	  return v ? Object.assign(proto || {}, v) : v;
	}
	function fromObject(input) {
	  var v = {r: 0, g: 0, b: 0, a: 255};
	  if (Array.isArray(input)) {
	    if (input.length >= 3) {
	      v = {r: input[0], g: input[1], b: input[2], a: 255};
	      if (input.length > 3) {
	        v.a = n2b(input[3]);
	      }
	    }
	  } else {
	    v = clone$1(input, {r: 0, g: 0, b: 0, a: 1});
	    v.a = n2b(v.a);
	  }
	  return v;
	}
	function functionParse(str) {
	  if (str.charAt(0) === 'r') {
	    return rgbParse(str);
	  }
	  return hueParse(str);
	}
	class Color {
	  constructor(input) {
	    if (input instanceof Color) {
	      return input;
	    }
	    const type = typeof input;
	    let v;
	    if (type === 'object') {
	      v = fromObject(input);
	    } else if (type === 'string') {
	      v = hexParse(input) || nameParse(input) || functionParse(input);
	    }
	    this._rgb = v;
	    this._valid = !!v;
	  }
	  get valid() {
	    return this._valid;
	  }
	  get rgb() {
	    var v = clone$1(this._rgb);
	    if (v) {
	      v.a = b2n(v.a);
	    }
	    return v;
	  }
	  set rgb(obj) {
	    this._rgb = fromObject(obj);
	  }
	  rgbString() {
	    return this._valid ? rgbString(this._rgb) : undefined;
	  }
	  hexString() {
	    return this._valid ? hexString(this._rgb) : undefined;
	  }
	  hslString() {
	    return this._valid ? hslString(this._rgb) : undefined;
	  }
	  mix(color, weight) {
	    if (color) {
	      const c1 = this.rgb;
	      const c2 = color.rgb;
	      let w2;
	      const p = weight === w2 ? 0.5 : weight;
	      const w = 2 * p - 1;
	      const a = c1.a - c2.a;
	      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
	      w2 = 1 - w1;
	      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
	      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
	      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
	      c1.a = p * c1.a + (1 - p) * c2.a;
	      this.rgb = c1;
	    }
	    return this;
	  }
	  interpolate(color, t) {
	    if (color) {
	      this._rgb = interpolate$1(this._rgb, color._rgb, t);
	    }
	    return this;
	  }
	  clone() {
	    return new Color(this.rgb);
	  }
	  alpha(a) {
	    this._rgb.a = n2b(a);
	    return this;
	  }
	  clearer(ratio) {
	    const rgb = this._rgb;
	    rgb.a *= 1 - ratio;
	    return this;
	  }
	  greyscale() {
	    const rgb = this._rgb;
	    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
	    rgb.r = rgb.g = rgb.b = val;
	    return this;
	  }
	  opaquer(ratio) {
	    const rgb = this._rgb;
	    rgb.a *= 1 + ratio;
	    return this;
	  }
	  negate() {
	    const v = this._rgb;
	    v.r = 255 - v.r;
	    v.g = 255 - v.g;
	    v.b = 255 - v.b;
	    return this;
	  }
	  lighten(ratio) {
	    modHSL(this._rgb, 2, ratio);
	    return this;
	  }
	  darken(ratio) {
	    modHSL(this._rgb, 2, -ratio);
	    return this;
	  }
	  saturate(ratio) {
	    modHSL(this._rgb, 1, ratio);
	    return this;
	  }
	  desaturate(ratio) {
	    modHSL(this._rgb, 1, -ratio);
	    return this;
	  }
	  rotate(deg) {
	    rotate(this._rgb, deg);
	    return this;
	  }
	}

	/*!
	 * Chart.js v4.4.4
	 * https://www.chartjs.org
	 * (c) 2024 Chart.js Contributors
	 * Released under the MIT License
	 */

	/**
	 * @namespace Chart.helpers
	 */ /**
	 * An empty function that can be used, for example, for optional callback.
	 */ function noop() {
	/* noop */ }
	/**
	 * Returns a unique id, sequentially generated from a global variable.
	 */ const uid = (()=>{
	    let id = 0;
	    return ()=>id++;
	})();
	/**
	 * Returns true if `value` is neither null nor undefined, else returns false.
	 * @param value - The value to test.
	 * @since 2.7.0
	 */ function isNullOrUndef(value) {
	    return value === null || typeof value === 'undefined';
	}
	/**
	 * Returns true if `value` is an array (including typed arrays), else returns false.
	 * @param value - The value to test.
	 * @function
	 */ function isArray$1(value) {
	    if (Array.isArray && Array.isArray(value)) {
	        return true;
	    }
	    const type = Object.prototype.toString.call(value);
	    if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {
	        return true;
	    }
	    return false;
	}
	/**
	 * Returns true if `value` is an object (excluding null), else returns false.
	 * @param value - The value to test.
	 * @since 2.7.0
	 */ function isObject$1(value) {
	    return value !== null && Object.prototype.toString.call(value) === '[object Object]';
	}
	/**
	 * Returns true if `value` is a finite number, else returns false
	 * @param value  - The value to test.
	 */ function isNumberFinite(value) {
	    return (typeof value === 'number' || value instanceof Number) && isFinite(+value);
	}
	/**
	 * Returns `value` if finite, else returns `defaultValue`.
	 * @param value - The value to return if defined.
	 * @param defaultValue - The value to return if `value` is not finite.
	 */ function finiteOrDefault(value, defaultValue) {
	    return isNumberFinite(value) ? value : defaultValue;
	}
	/**
	 * Returns `value` if defined, else returns `defaultValue`.
	 * @param value - The value to return if defined.
	 * @param defaultValue - The value to return if `value` is undefined.
	 */ function valueOrDefault(value, defaultValue) {
	    return typeof value === 'undefined' ? defaultValue : value;
	}
	const toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;
	const toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;
	/**
	 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
	 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
	 * @param fn - The function to call.
	 * @param args - The arguments with which `fn` should be called.
	 * @param [thisArg] - The value of `this` provided for the call to `fn`.
	 */ function callback(fn, args, thisArg) {
	    if (fn && typeof fn.call === 'function') {
	        return fn.apply(thisArg, args);
	    }
	}
	function each(loopable, fn, thisArg, reverse) {
	    let i, len, keys;
	    if (isArray$1(loopable)) {
	        len = loopable.length;
	        if (reverse) {
	            for(i = len - 1; i >= 0; i--){
	                fn.call(thisArg, loopable[i], i);
	            }
	        } else {
	            for(i = 0; i < len; i++){
	                fn.call(thisArg, loopable[i], i);
	            }
	        }
	    } else if (isObject$1(loopable)) {
	        keys = Object.keys(loopable);
	        len = keys.length;
	        for(i = 0; i < len; i++){
	            fn.call(thisArg, loopable[keys[i]], keys[i]);
	        }
	    }
	}
	/**
	 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
	 * @param a0 - The array to compare
	 * @param a1 - The array to compare
	 * @private
	 */ function _elementsEqual(a0, a1) {
	    let i, ilen, v0, v1;
	    if (!a0 || !a1 || a0.length !== a1.length) {
	        return false;
	    }
	    for(i = 0, ilen = a0.length; i < ilen; ++i){
	        v0 = a0[i];
	        v1 = a1[i];
	        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
	            return false;
	        }
	    }
	    return true;
	}
	/**
	 * Returns a deep copy of `source` without keeping references on objects and arrays.
	 * @param source - The value to clone.
	 */ function clone(source) {
	    if (isArray$1(source)) {
	        return source.map(clone);
	    }
	    if (isObject$1(source)) {
	        const target = Object.create(null);
	        const keys = Object.keys(source);
	        const klen = keys.length;
	        let k = 0;
	        for(; k < klen; ++k){
	            target[keys[k]] = clone(source[keys[k]]);
	        }
	        return target;
	    }
	    return source;
	}
	function isValidKey(key) {
	    return [
	        '__proto__',
	        'prototype',
	        'constructor'
	    ].indexOf(key) === -1;
	}
	/**
	 * The default merger when Chart.helpers.merge is called without merger option.
	 * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
	 * @private
	 */ function _merger(key, target, source, options) {
	    if (!isValidKey(key)) {
	        return;
	    }
	    const tval = target[key];
	    const sval = source[key];
	    if (isObject$1(tval) && isObject$1(sval)) {
	        // eslint-disable-next-line @typescript-eslint/no-use-before-define
	        merge(tval, sval, options);
	    } else {
	        target[key] = clone(sval);
	    }
	}
	function merge(target, source, options) {
	    const sources = isArray$1(source) ? source : [
	        source
	    ];
	    const ilen = sources.length;
	    if (!isObject$1(target)) {
	        return target;
	    }
	    options = options || {};
	    const merger = options.merger || _merger;
	    let current;
	    for(let i = 0; i < ilen; ++i){
	        current = sources[i];
	        if (!isObject$1(current)) {
	            continue;
	        }
	        const keys = Object.keys(current);
	        for(let k = 0, klen = keys.length; k < klen; ++k){
	            merger(keys[k], target, current, options);
	        }
	    }
	    return target;
	}
	function mergeIf(target, source) {
	    // eslint-disable-next-line @typescript-eslint/no-use-before-define
	    return merge(target, source, {
	        merger: _mergerIf
	    });
	}
	/**
	 * Merges source[key] in target[key] only if target[key] is undefined.
	 * @private
	 */ function _mergerIf(key, target, source) {
	    if (!isValidKey(key)) {
	        return;
	    }
	    const tval = target[key];
	    const sval = source[key];
	    if (isObject$1(tval) && isObject$1(sval)) {
	        mergeIf(tval, sval);
	    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
	        target[key] = clone(sval);
	    }
	}
	// resolveObjectKey resolver cache
	const keyResolvers = {
	    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
	    '': (v)=>v,
	    // default resolvers
	    x: (o)=>o.x,
	    y: (o)=>o.y
	};
	/**
	 * @private
	 */ function _splitKey(key) {
	    const parts = key.split('.');
	    const keys = [];
	    let tmp = '';
	    for (const part of parts){
	        tmp += part;
	        if (tmp.endsWith('\\')) {
	            tmp = tmp.slice(0, -1) + '.';
	        } else {
	            keys.push(tmp);
	            tmp = '';
	        }
	    }
	    return keys;
	}
	function _getKeyResolver(key) {
	    const keys = _splitKey(key);
	    return (obj)=>{
	        for (const k of keys){
	            if (k === '') {
	                break;
	            }
	            obj = obj && obj[k];
	        }
	        return obj;
	    };
	}
	function resolveObjectKey(obj, key) {
	    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
	    return resolver(obj);
	}
	/**
	 * @private
	 */ function _capitalize(str) {
	    return str.charAt(0).toUpperCase() + str.slice(1);
	}
	const defined = (value)=>typeof value !== 'undefined';
	const isFunction$1 = (value)=>typeof value === 'function';
	// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384
	const setsEqual = (a, b)=>{
	    if (a.size !== b.size) {
	        return false;
	    }
	    for (const item of a){
	        if (!b.has(item)) {
	            return false;
	        }
	    }
	    return true;
	};
	/**
	 * @param e - The event
	 * @private
	 */ function _isClickEvent(e) {
	    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';
	}

	/**
	 * @alias Chart.helpers.math
	 * @namespace
	 */ const PI = Math.PI;
	const TAU = 2 * PI;
	const PITAU = TAU + PI;
	const INFINITY = Number.POSITIVE_INFINITY;
	const RAD_PER_DEG = PI / 180;
	const HALF_PI = PI / 2;
	const QUARTER_PI = PI / 4;
	const TWO_THIRDS_PI = PI * 2 / 3;
	const log10 = Math.log10;
	const sign = Math.sign;
	function almostEquals(x, y, epsilon) {
	    return Math.abs(x - y) < epsilon;
	}
	/**
	 * Implementation of the nice number algorithm used in determining where axis labels will go
	 */ function niceNum(range) {
	    const roundedRange = Math.round(range);
	    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
	    const niceRange = Math.pow(10, Math.floor(log10(range)));
	    const fraction = range / niceRange;
	    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
	    return niceFraction * niceRange;
	}
	/**
	 * Returns an array of factors sorted from 1 to sqrt(value)
	 * @private
	 */ function _factorize(value) {
	    const result = [];
	    const sqrt = Math.sqrt(value);
	    let i;
	    for(i = 1; i < sqrt; i++){
	        if (value % i === 0) {
	            result.push(i);
	            result.push(value / i);
	        }
	    }
	    if (sqrt === (sqrt | 0)) {
	        result.push(sqrt);
	    }
	    result.sort((a, b)=>a - b).pop();
	    return result;
	}
	function isNumber(n) {
	    return !isNaN(parseFloat(n)) && isFinite(n);
	}
	function almostWhole(x, epsilon) {
	    const rounded = Math.round(x);
	    return rounded - epsilon <= x && rounded + epsilon >= x;
	}
	/**
	 * @private
	 */ function _setMinAndMaxByKey(array, target, property) {
	    let i, ilen, value;
	    for(i = 0, ilen = array.length; i < ilen; i++){
	        value = array[i][property];
	        if (!isNaN(value)) {
	            target.min = Math.min(target.min, value);
	            target.max = Math.max(target.max, value);
	        }
	    }
	}
	function toRadians(degrees) {
	    return degrees * (PI / 180);
	}
	function toDegrees(radians) {
	    return radians * (180 / PI);
	}
	/**
	 * Returns the number of decimal places
	 * i.e. the number of digits after the decimal point, of the value of this Number.
	 * @param x - A number.
	 * @returns The number of decimal places.
	 * @private
	 */ function _decimalPlaces(x) {
	    if (!isNumberFinite(x)) {
	        return;
	    }
	    let e = 1;
	    let p = 0;
	    while(Math.round(x * e) / e !== x){
	        e *= 10;
	        p++;
	    }
	    return p;
	}
	// Gets the angle from vertical upright to the point about a centre.
	function getAngleFromPoint(centrePoint, anglePoint) {
	    const distanceFromXCenter = anglePoint.x - centrePoint.x;
	    const distanceFromYCenter = anglePoint.y - centrePoint.y;
	    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
	    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
	    if (angle < -0.5 * PI) {
	        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
	    }
	    return {
	        angle,
	        distance: radialDistanceFromCenter
	    };
	}
	function distanceBetweenPoints(pt1, pt2) {
	    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
	}
	/**
	 * Shortest distance between angles, in either direction.
	 * @private
	 */ function _angleDiff(a, b) {
	    return (a - b + PITAU) % TAU - PI;
	}
	/**
	 * Normalize angle to be between 0 and 2*PI
	 * @private
	 */ function _normalizeAngle(a) {
	    return (a % TAU + TAU) % TAU;
	}
	/**
	 * @private
	 */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
	    const a = _normalizeAngle(angle);
	    const s = _normalizeAngle(start);
	    const e = _normalizeAngle(end);
	    const angleToStart = _normalizeAngle(s - a);
	    const angleToEnd = _normalizeAngle(e - a);
	    const startToAngle = _normalizeAngle(a - s);
	    const endToAngle = _normalizeAngle(a - e);
	    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
	}
	/**
	 * Limit `value` between `min` and `max`
	 * @param value
	 * @param min
	 * @param max
	 * @private
	 */ function _limitValue(value, min, max) {
	    return Math.max(min, Math.min(max, value));
	}
	/**
	 * @param {number} value
	 * @private
	 */ function _int16Range(value) {
	    return _limitValue(value, -32768, 32767);
	}
	/**
	 * @param value
	 * @param start
	 * @param end
	 * @param [epsilon]
	 * @private
	 */ function _isBetween(value, start, end, epsilon = 1e-6) {
	    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
	}

	function _lookup(table, value, cmp) {
	    cmp = cmp || ((index)=>table[index] < value);
	    let hi = table.length - 1;
	    let lo = 0;
	    let mid;
	    while(hi - lo > 1){
	        mid = lo + hi >> 1;
	        if (cmp(mid)) {
	            lo = mid;
	        } else {
	            hi = mid;
	        }
	    }
	    return {
	        lo,
	        hi
	    };
	}
	/**
	 * Binary search
	 * @param table - the table search. must be sorted!
	 * @param key - property name for the value in each entry
	 * @param value - value to find
	 * @param last - lookup last index
	 * @private
	 */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{
	        const ti = table[index][key];
	        return ti < value || ti === value && table[index + 1][key] === value;
	    } : (index)=>table[index][key] < value);
	/**
	 * Reverse binary search
	 * @param table - the table search. must be sorted!
	 * @param key - property name for the value in each entry
	 * @param value - value to find
	 * @private
	 */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);
	/**
	 * Return subset of `values` between `min` and `max` inclusive.
	 * Values are assumed to be in sorted order.
	 * @param values - sorted array of values
	 * @param min - min value
	 * @param max - max value
	 */ function _filterBetween(values, min, max) {
	    let start = 0;
	    let end = values.length;
	    while(start < end && values[start] < min){
	        start++;
	    }
	    while(end > start && values[end - 1] > max){
	        end--;
	    }
	    return start > 0 || end < values.length ? values.slice(start, end) : values;
	}
	const arrayEvents = [
	    'push',
	    'pop',
	    'shift',
	    'splice',
	    'unshift'
	];
	function listenArrayEvents(array, listener) {
	    if (array._chartjs) {
	        array._chartjs.listeners.push(listener);
	        return;
	    }
	    Object.defineProperty(array, '_chartjs', {
	        configurable: true,
	        enumerable: false,
	        value: {
	            listeners: [
	                listener
	            ]
	        }
	    });
	    arrayEvents.forEach((key)=>{
	        const method = '_onData' + _capitalize(key);
	        const base = array[key];
	        Object.defineProperty(array, key, {
	            configurable: true,
	            enumerable: false,
	            value (...args) {
	                const res = base.apply(this, args);
	                array._chartjs.listeners.forEach((object)=>{
	                    if (typeof object[method] === 'function') {
	                        object[method](...args);
	                    }
	                });
	                return res;
	            }
	        });
	    });
	}
	function unlistenArrayEvents(array, listener) {
	    const stub = array._chartjs;
	    if (!stub) {
	        return;
	    }
	    const listeners = stub.listeners;
	    const index = listeners.indexOf(listener);
	    if (index !== -1) {
	        listeners.splice(index, 1);
	    }
	    if (listeners.length > 0) {
	        return;
	    }
	    arrayEvents.forEach((key)=>{
	        delete array[key];
	    });
	    delete array._chartjs;
	}
	/**
	 * @param items
	 */ function _arrayUnique(items) {
	    const set = new Set(items);
	    if (set.size === items.length) {
	        return items;
	    }
	    return Array.from(set);
	}
	/**
	* Request animation polyfill
	*/ const requestAnimFrame = function() {
	    if (typeof window === 'undefined') {
	        return function(callback) {
	            return callback();
	        };
	    }
	    return window.requestAnimationFrame;
	}();
	/**
	 * Throttles calling `fn` once per animation frame
	 * Latest arguments are used on the actual call
	 */ function throttled(fn, thisArg) {
	    let argsToUse = [];
	    let ticking = false;
	    return function(...args) {
	        // Save the args for use later
	        argsToUse = args;
	        if (!ticking) {
	            ticking = true;
	            requestAnimFrame.call(window, ()=>{
	                ticking = false;
	                fn.apply(thisArg, argsToUse);
	            });
	        }
	    };
	}
	/**
	 * Debounces calling `fn` for `delay` ms
	 */ function debounce(fn, delay) {
	    let timeout;
	    return function(...args) {
	        if (delay) {
	            clearTimeout(timeout);
	            timeout = setTimeout(fn, delay, args);
	        } else {
	            fn.apply(this, args);
	        }
	        return delay;
	    };
	}
	/**
	 * Converts 'start' to 'left', 'end' to 'right' and others to 'center'
	 * @private
	 */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
	/**
	 * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`
	 * @private
	 */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
	/**
	 * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`
	 * @private
	 */ const _textX = (align, left, right, rtl)=>{
	    const check = rtl ? 'left' : 'right';
	    return align === check ? right : align === 'center' ? (left + right) / 2 : left;
	};
	/**
	 * Return start and count of visible points.
	 * @private
	 */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
	    const pointCount = points.length;
	    let start = 0;
	    let count = pointCount;
	    if (meta._sorted) {
	        const { iScale , _parsed  } = meta;
	        const axis = iScale.axis;
	        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
	        if (minDefined) {
	            start = _limitValue(Math.min(// @ts-expect-error Need to type _parsed
	            _lookupByKey(_parsed, axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey
	            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
	        }
	        if (maxDefined) {
	            count = _limitValue(Math.max(// @ts-expect-error Need to type _parsed
	            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey
	            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
	        } else {
	            count = pointCount - start;
	        }
	    }
	    return {
	        start,
	        count
	    };
	}
	/**
	 * Checks if the scale ranges have changed.
	 * @param {object} meta - dataset meta.
	 * @returns {boolean}
	 * @private
	 */ function _scaleRangesChanged(meta) {
	    const { xScale , yScale , _scaleRanges  } = meta;
	    const newRanges = {
	        xmin: xScale.min,
	        xmax: xScale.max,
	        ymin: yScale.min,
	        ymax: yScale.max
	    };
	    if (!_scaleRanges) {
	        meta._scaleRanges = newRanges;
	        return true;
	    }
	    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
	    Object.assign(_scaleRanges, newRanges);
	    return changed;
	}

	const atEdge = (t)=>t === 0 || t === 1;
	const elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
	const elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
	/**
	 * Easing functions adapted from Robert Penner's easing equations.
	 * @namespace Chart.helpers.easing.effects
	 * @see http://www.robertpenner.com/easing/
	 */ const effects = {
	    linear: (t)=>t,
	    easeInQuad: (t)=>t * t,
	    easeOutQuad: (t)=>-t * (t - 2),
	    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
	    easeInCubic: (t)=>t * t * t,
	    easeOutCubic: (t)=>(t -= 1) * t * t + 1,
	    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
	    easeInQuart: (t)=>t * t * t * t,
	    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),
	    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
	    easeInQuint: (t)=>t * t * t * t * t,
	    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,
	    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
	    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,
	    easeOutSine: (t)=>Math.sin(t * HALF_PI),
	    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),
	    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
	    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
	    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
	    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
	    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),
	    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
	    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
	    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
	    easeInOutElastic (t) {
	        const s = 0.1125;
	        const p = 0.45;
	        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
	    },
	    easeInBack (t) {
	        const s = 1.70158;
	        return t * t * ((s + 1) * t - s);
	    },
	    easeOutBack (t) {
	        const s = 1.70158;
	        return (t -= 1) * t * ((s + 1) * t + s) + 1;
	    },
	    easeInOutBack (t) {
	        let s = 1.70158;
	        if ((t /= 0.5) < 1) {
	            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
	        }
	        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
	    },
	    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),
	    easeOutBounce (t) {
	        const m = 7.5625;
	        const d = 2.75;
	        if (t < 1 / d) {
	            return m * t * t;
	        }
	        if (t < 2 / d) {
	            return m * (t -= 1.5 / d) * t + 0.75;
	        }
	        if (t < 2.5 / d) {
	            return m * (t -= 2.25 / d) * t + 0.9375;
	        }
	        return m * (t -= 2.625 / d) * t + 0.984375;
	    },
	    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
	};

	function isPatternOrGradient(value) {
	    if (value && typeof value === 'object') {
	        const type = value.toString();
	        return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';
	    }
	    return false;
	}
	function color(value) {
	    return isPatternOrGradient(value) ? value : new Color(value);
	}
	function getHoverColor(value) {
	    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
	}

	const numbers = [
	    'x',
	    'y',
	    'borderWidth',
	    'radius',
	    'tension'
	];
	const colors = [
	    'color',
	    'borderColor',
	    'backgroundColor'
	];
	function applyAnimationsDefaults(defaults) {
	    defaults.set('animation', {
	        delay: undefined,
	        duration: 1000,
	        easing: 'easeOutQuart',
	        fn: undefined,
	        from: undefined,
	        loop: undefined,
	        to: undefined,
	        type: undefined
	    });
	    defaults.describe('animation', {
	        _fallback: false,
	        _indexable: false,
	        _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'
	    });
	    defaults.set('animations', {
	        colors: {
	            type: 'color',
	            properties: colors
	        },
	        numbers: {
	            type: 'number',
	            properties: numbers
	        }
	    });
	    defaults.describe('animations', {
	        _fallback: 'animation'
	    });
	    defaults.set('transitions', {
	        active: {
	            animation: {
	                duration: 400
	            }
	        },
	        resize: {
	            animation: {
	                duration: 0
	            }
	        },
	        show: {
	            animations: {
	                colors: {
	                    from: 'transparent'
	                },
	                visible: {
	                    type: 'boolean',
	                    duration: 0
	                }
	            }
	        },
	        hide: {
	            animations: {
	                colors: {
	                    to: 'transparent'
	                },
	                visible: {
	                    type: 'boolean',
	                    easing: 'linear',
	                    fn: (v)=>v | 0
	                }
	            }
	        }
	    });
	}

	function applyLayoutsDefaults(defaults) {
	    defaults.set('layout', {
	        autoPadding: true,
	        padding: {
	            top: 0,
	            right: 0,
	            bottom: 0,
	            left: 0
	        }
	    });
	}

	const intlCache = new Map();
	function getNumberFormat(locale, options) {
	    options = options || {};
	    const cacheKey = locale + JSON.stringify(options);
	    let formatter = intlCache.get(cacheKey);
	    if (!formatter) {
	        formatter = new Intl.NumberFormat(locale, options);
	        intlCache.set(cacheKey, formatter);
	    }
	    return formatter;
	}
	function formatNumber(num, locale, options) {
	    return getNumberFormat(locale, options).format(num);
	}

	const formatters = {
	 values (value) {
	        return isArray$1(value) ?  value : '' + value;
	    },
	 numeric (tickValue, index, ticks) {
	        if (tickValue === 0) {
	            return '0';
	        }
	        const locale = this.chart.options.locale;
	        let notation;
	        let delta = tickValue;
	        if (ticks.length > 1) {
	            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
	            if (maxTick < 1e-4 || maxTick > 1e+15) {
	                notation = 'scientific';
	            }
	            delta = calculateDelta(tickValue, ticks);
	        }
	        const logDelta = log10(Math.abs(delta));
	        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
	        const options = {
	            notation,
	            minimumFractionDigits: numDecimal,
	            maximumFractionDigits: numDecimal
	        };
	        Object.assign(options, this.options.ticks.format);
	        return formatNumber(tickValue, locale, options);
	    },
	 logarithmic (tickValue, index, ticks) {
	        if (tickValue === 0) {
	            return '0';
	        }
	        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
	        if ([
	            1,
	            2,
	            3,
	            5,
	            10,
	            15
	        ].includes(remain) || index > 0.8 * ticks.length) {
	            return formatters.numeric.call(this, tickValue, index, ticks);
	        }
	        return '';
	    }
	};
	function calculateDelta(tickValue, ticks) {
	    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
	    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
	        delta = tickValue - Math.floor(tickValue);
	    }
	    return delta;
	}
	 var Ticks = {
	    formatters
	};

	function applyScaleDefaults(defaults) {
	    defaults.set('scale', {
	        display: true,
	        offset: false,
	        reverse: false,
	        beginAtZero: false,
	 bounds: 'ticks',
	        clip: true,
	 grace: 0,
	        grid: {
	            display: true,
	            lineWidth: 1,
	            drawOnChartArea: true,
	            drawTicks: true,
	            tickLength: 8,
	            tickWidth: (_ctx, options)=>options.lineWidth,
	            tickColor: (_ctx, options)=>options.color,
	            offset: false
	        },
	        border: {
	            display: true,
	            dash: [],
	            dashOffset: 0.0,
	            width: 1
	        },
	        title: {
	            display: false,
	            text: '',
	            padding: {
	                top: 4,
	                bottom: 4
	            }
	        },
	        ticks: {
	            minRotation: 0,
	            maxRotation: 50,
	            mirror: false,
	            textStrokeWidth: 0,
	            textStrokeColor: '',
	            padding: 3,
	            display: true,
	            autoSkip: true,
	            autoSkipPadding: 3,
	            labelOffset: 0,
	            callback: Ticks.formatters.values,
	            minor: {},
	            major: {},
	            align: 'center',
	            crossAlign: 'near',
	            showLabelBackdrop: false,
	            backdropColor: 'rgba(255, 255, 255, 0.75)',
	            backdropPadding: 2
	        }
	    });
	    defaults.route('scale.ticks', 'color', '', 'color');
	    defaults.route('scale.grid', 'color', '', 'borderColor');
	    defaults.route('scale.border', 'color', '', 'borderColor');
	    defaults.route('scale.title', 'color', '', 'color');
	    defaults.describe('scale', {
	        _fallback: false,
	        _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
	        _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'
	    });
	    defaults.describe('scales', {
	        _fallback: 'scale'
	    });
	    defaults.describe('scale.ticks', {
	        _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',
	        _indexable: (name)=>name !== 'backdropPadding'
	    });
	}

	const overrides = Object.create(null);
	const descriptors = Object.create(null);
	 function getScope$1(node, key) {
	    if (!key) {
	        return node;
	    }
	    const keys = key.split('.');
	    for(let i = 0, n = keys.length; i < n; ++i){
	        const k = keys[i];
	        node = node[k] || (node[k] = Object.create(null));
	    }
	    return node;
	}
	function set(root, scope, values) {
	    if (typeof scope === 'string') {
	        return merge(getScope$1(root, scope), values);
	    }
	    return merge(getScope$1(root, ''), scope);
	}
	 class Defaults {
	    constructor(_descriptors, _appliers){
	        this.animation = undefined;
	        this.backgroundColor = 'rgba(0,0,0,0.1)';
	        this.borderColor = 'rgba(0,0,0,0.1)';
	        this.color = '#666';
	        this.datasets = {};
	        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();
	        this.elements = {};
	        this.events = [
	            'mousemove',
	            'mouseout',
	            'click',
	            'touchstart',
	            'touchmove'
	        ];
	        this.font = {
	            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
	            size: 12,
	            style: 'normal',
	            lineHeight: 1.2,
	            weight: null
	        };
	        this.hover = {};
	        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);
	        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);
	        this.hoverColor = (ctx, options)=>getHoverColor(options.color);
	        this.indexAxis = 'x';
	        this.interaction = {
	            mode: 'nearest',
	            intersect: true,
	            includeInvisible: false
	        };
	        this.maintainAspectRatio = true;
	        this.onHover = null;
	        this.onClick = null;
	        this.parsing = true;
	        this.plugins = {};
	        this.responsive = true;
	        this.scale = undefined;
	        this.scales = {};
	        this.showLine = true;
	        this.drawActiveElementsOnTop = true;
	        this.describe(_descriptors);
	        this.apply(_appliers);
	    }
	 set(scope, values) {
	        return set(this, scope, values);
	    }
	 get(scope) {
	        return getScope$1(this, scope);
	    }
	 describe(scope, values) {
	        return set(descriptors, scope, values);
	    }
	    override(scope, values) {
	        return set(overrides, scope, values);
	    }
	 route(scope, name, targetScope, targetName) {
	        const scopeObject = getScope$1(this, scope);
	        const targetScopeObject = getScope$1(this, targetScope);
	        const privateName = '_' + name;
	        Object.defineProperties(scopeObject, {
	            [privateName]: {
	                value: scopeObject[name],
	                writable: true
	            },
	            [name]: {
	                enumerable: true,
	                get () {
	                    const local = this[privateName];
	                    const target = targetScopeObject[targetName];
	                    if (isObject$1(local)) {
	                        return Object.assign({}, target, local);
	                    }
	                    return valueOrDefault(local, target);
	                },
	                set (value) {
	                    this[privateName] = value;
	                }
	            }
	        });
	    }
	    apply(appliers) {
	        appliers.forEach((apply)=>apply(this));
	    }
	}
	var defaults = /* #__PURE__ */ new Defaults({
	    _scriptable: (name)=>!name.startsWith('on'),
	    _indexable: (name)=>name !== 'events',
	    hover: {
	        _fallback: 'interaction'
	    },
	    interaction: {
	        _scriptable: false,
	        _indexable: false
	    }
	}, [
	    applyAnimationsDefaults,
	    applyLayoutsDefaults,
	    applyScaleDefaults
	]);

	/**
	 * Converts the given font object into a CSS font string.
	 * @param font - A font object.
	 * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
	 * @private
	 */ function toFontString(font) {
	    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
	        return null;
	    }
	    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
	}
	/**
	 * @private
	 */ function _measureText(ctx, data, gc, longest, string) {
	    let textWidth = data[string];
	    if (!textWidth) {
	        textWidth = data[string] = ctx.measureText(string).width;
	        gc.push(string);
	    }
	    if (textWidth > longest) {
	        longest = textWidth;
	    }
	    return longest;
	}
	/**
	 * @private
	 */ // eslint-disable-next-line complexity
	function _longestText(ctx, font, arrayOfThings, cache) {
	    cache = cache || {};
	    let data = cache.data = cache.data || {};
	    let gc = cache.garbageCollect = cache.garbageCollect || [];
	    if (cache.font !== font) {
	        data = cache.data = {};
	        gc = cache.garbageCollect = [];
	        cache.font = font;
	    }
	    ctx.save();
	    ctx.font = font;
	    let longest = 0;
	    const ilen = arrayOfThings.length;
	    let i, j, jlen, thing, nestedThing;
	    for(i = 0; i < ilen; i++){
	        thing = arrayOfThings[i];
	        // Undefined strings and arrays should not be measured
	        if (thing !== undefined && thing !== null && !isArray$1(thing)) {
	            longest = _measureText(ctx, data, gc, longest, thing);
	        } else if (isArray$1(thing)) {
	            // if it is an array lets measure each element
	            // to do maybe simplify this function a bit so we can do this more recursively?
	            for(j = 0, jlen = thing.length; j < jlen; j++){
	                nestedThing = thing[j];
	                // Undefined strings and arrays should not be measured
	                if (nestedThing !== undefined && nestedThing !== null && !isArray$1(nestedThing)) {
	                    longest = _measureText(ctx, data, gc, longest, nestedThing);
	                }
	            }
	        }
	    }
	    ctx.restore();
	    const gcLen = gc.length / 2;
	    if (gcLen > arrayOfThings.length) {
	        for(i = 0; i < gcLen; i++){
	            delete data[gc[i]];
	        }
	        gc.splice(0, gcLen);
	    }
	    return longest;
	}
	/**
	 * Returns the aligned pixel value to avoid anti-aliasing blur
	 * @param chart - The chart instance.
	 * @param pixel - A pixel value.
	 * @param width - The width of the element.
	 * @returns The aligned pixel value.
	 * @private
	 */ function _alignPixel(chart, pixel, width) {
	    const devicePixelRatio = chart.currentDevicePixelRatio;
	    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
	    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
	}
	/**
	 * Clears the entire canvas.
	 */ function clearCanvas(canvas, ctx) {
	    if (!ctx && !canvas) {
	        return;
	    }
	    ctx = ctx || canvas.getContext('2d');
	    ctx.save();
	    // canvas.width and canvas.height do not consider the canvas transform,
	    // while clearRect does
	    ctx.resetTransform();
	    ctx.clearRect(0, 0, canvas.width, canvas.height);
	    ctx.restore();
	}
	function drawPoint(ctx, options, x, y) {
	    // eslint-disable-next-line @typescript-eslint/no-use-before-define
	    drawPointLegend(ctx, options, x, y, null);
	}
	// eslint-disable-next-line complexity
	function drawPointLegend(ctx, options, x, y, w) {
	    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
	    const style = options.pointStyle;
	    const rotation = options.rotation;
	    const radius = options.radius;
	    let rad = (rotation || 0) * RAD_PER_DEG;
	    if (style && typeof style === 'object') {
	        type = style.toString();
	        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
	            ctx.save();
	            ctx.translate(x, y);
	            ctx.rotate(rad);
	            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
	            ctx.restore();
	            return;
	        }
	    }
	    if (isNaN(radius) || radius <= 0) {
	        return;
	    }
	    ctx.beginPath();
	    switch(style){
	        // Default includes circle
	        default:
	            if (w) {
	                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
	            } else {
	                ctx.arc(x, y, radius, 0, TAU);
	            }
	            ctx.closePath();
	            break;
	        case 'triangle':
	            width = w ? w / 2 : radius;
	            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
	            rad += TWO_THIRDS_PI;
	            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
	            rad += TWO_THIRDS_PI;
	            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
	            ctx.closePath();
	            break;
	        case 'rectRounded':
	            // NOTE: the rounded rect implementation changed to use `arc` instead of
	            // `quadraticCurveTo` since it generates better results when rect is
	            // almost a circle. 0.516 (instead of 0.5) produces results with visually
	            // closer proportion to the previous impl and it is inscribed in the
	            // circle with `radius`. For more details, see the following PRs:
	            // https://github.com/chartjs/Chart.js/issues/5597
	            // https://github.com/chartjs/Chart.js/issues/5858
	            cornerRadius = radius * 0.516;
	            size = radius - cornerRadius;
	            xOffset = Math.cos(rad + QUARTER_PI) * size;
	            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
	            yOffset = Math.sin(rad + QUARTER_PI) * size;
	            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
	            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
	            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
	            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
	            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
	            ctx.closePath();
	            break;
	        case 'rect':
	            if (!rotation) {
	                size = Math.SQRT1_2 * radius;
	                width = w ? w / 2 : size;
	                ctx.rect(x - width, y - size, 2 * width, 2 * size);
	                break;
	            }
	            rad += QUARTER_PI;
	        /* falls through */ case 'rectRot':
	            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
	            xOffset = Math.cos(rad) * radius;
	            yOffset = Math.sin(rad) * radius;
	            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
	            ctx.moveTo(x - xOffsetW, y - yOffset);
	            ctx.lineTo(x + yOffsetW, y - xOffset);
	            ctx.lineTo(x + xOffsetW, y + yOffset);
	            ctx.lineTo(x - yOffsetW, y + xOffset);
	            ctx.closePath();
	            break;
	        case 'crossRot':
	            rad += QUARTER_PI;
	        /* falls through */ case 'cross':
	            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
	            xOffset = Math.cos(rad) * radius;
	            yOffset = Math.sin(rad) * radius;
	            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
	            ctx.moveTo(x - xOffsetW, y - yOffset);
	            ctx.lineTo(x + xOffsetW, y + yOffset);
	            ctx.moveTo(x + yOffsetW, y - xOffset);
	            ctx.lineTo(x - yOffsetW, y + xOffset);
	            break;
	        case 'star':
	            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
	            xOffset = Math.cos(rad) * radius;
	            yOffset = Math.sin(rad) * radius;
	            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
	            ctx.moveTo(x - xOffsetW, y - yOffset);
	            ctx.lineTo(x + xOffsetW, y + yOffset);
	            ctx.moveTo(x + yOffsetW, y - xOffset);
	            ctx.lineTo(x - yOffsetW, y + xOffset);
	            rad += QUARTER_PI;
	            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
	            xOffset = Math.cos(rad) * radius;
	            yOffset = Math.sin(rad) * radius;
	            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
	            ctx.moveTo(x - xOffsetW, y - yOffset);
	            ctx.lineTo(x + xOffsetW, y + yOffset);
	            ctx.moveTo(x + yOffsetW, y - xOffset);
	            ctx.lineTo(x - yOffsetW, y + xOffset);
	            break;
	        case 'line':
	            xOffset = w ? w / 2 : Math.cos(rad) * radius;
	            yOffset = Math.sin(rad) * radius;
	            ctx.moveTo(x - xOffset, y - yOffset);
	            ctx.lineTo(x + xOffset, y + yOffset);
	            break;
	        case 'dash':
	            ctx.moveTo(x, y);
	            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
	            break;
	        case false:
	            ctx.closePath();
	            break;
	    }
	    ctx.fill();
	    if (options.borderWidth > 0) {
	        ctx.stroke();
	    }
	}
	/**
	 * Returns true if the point is inside the rectangle
	 * @param point - The point to test
	 * @param area - The rectangle
	 * @param margin - allowed margin
	 * @private
	 */ function _isPointInArea(point, area, margin) {
	    margin = margin || 0.5; // margin - default is to match rounded decimals
	    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
	}
	function clipArea(ctx, area) {
	    ctx.save();
	    ctx.beginPath();
	    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
	    ctx.clip();
	}
	function unclipArea(ctx) {
	    ctx.restore();
	}
	/**
	 * @private
	 */ function _steppedLineTo(ctx, previous, target, flip, mode) {
	    if (!previous) {
	        return ctx.lineTo(target.x, target.y);
	    }
	    if (mode === 'middle') {
	        const midpoint = (previous.x + target.x) / 2.0;
	        ctx.lineTo(midpoint, previous.y);
	        ctx.lineTo(midpoint, target.y);
	    } else if (mode === 'after' !== !!flip) {
	        ctx.lineTo(previous.x, target.y);
	    } else {
	        ctx.lineTo(target.x, previous.y);
	    }
	    ctx.lineTo(target.x, target.y);
	}
	/**
	 * @private
	 */ function _bezierCurveTo(ctx, previous, target, flip) {
	    if (!previous) {
	        return ctx.lineTo(target.x, target.y);
	    }
	    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
	}
	function setRenderOpts(ctx, opts) {
	    if (opts.translation) {
	        ctx.translate(opts.translation[0], opts.translation[1]);
	    }
	    if (!isNullOrUndef(opts.rotation)) {
	        ctx.rotate(opts.rotation);
	    }
	    if (opts.color) {
	        ctx.fillStyle = opts.color;
	    }
	    if (opts.textAlign) {
	        ctx.textAlign = opts.textAlign;
	    }
	    if (opts.textBaseline) {
	        ctx.textBaseline = opts.textBaseline;
	    }
	}
	function decorateText(ctx, x, y, line, opts) {
	    if (opts.strikethrough || opts.underline) {
	        /**
	     * Now that IE11 support has been dropped, we can use more
	     * of the TextMetrics object. The actual bounding boxes
	     * are unflagged in Chrome, Firefox, Edge, and Safari so they
	     * can be safely used.
	     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility
	     */ const metrics = ctx.measureText(line);
	        const left = x - metrics.actualBoundingBoxLeft;
	        const right = x + metrics.actualBoundingBoxRight;
	        const top = y - metrics.actualBoundingBoxAscent;
	        const bottom = y + metrics.actualBoundingBoxDescent;
	        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
	        ctx.strokeStyle = ctx.fillStyle;
	        ctx.beginPath();
	        ctx.lineWidth = opts.decorationWidth || 2;
	        ctx.moveTo(left, yDecoration);
	        ctx.lineTo(right, yDecoration);
	        ctx.stroke();
	    }
	}
	function drawBackdrop(ctx, opts) {
	    const oldColor = ctx.fillStyle;
	    ctx.fillStyle = opts.color;
	    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
	    ctx.fillStyle = oldColor;
	}
	/**
	 * Render text onto the canvas
	 */ function renderText(ctx, text, x, y, font, opts = {}) {
	    const lines = isArray$1(text) ? text : [
	        text
	    ];
	    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
	    let i, line;
	    ctx.save();
	    ctx.font = font.string;
	    setRenderOpts(ctx, opts);
	    for(i = 0; i < lines.length; ++i){
	        line = lines[i];
	        if (opts.backdrop) {
	            drawBackdrop(ctx, opts.backdrop);
	        }
	        if (stroke) {
	            if (opts.strokeColor) {
	                ctx.strokeStyle = opts.strokeColor;
	            }
	            if (!isNullOrUndef(opts.strokeWidth)) {
	                ctx.lineWidth = opts.strokeWidth;
	            }
	            ctx.strokeText(line, x, y, opts.maxWidth);
	        }
	        ctx.fillText(line, x, y, opts.maxWidth);
	        decorateText(ctx, x, y, line, opts);
	        y += Number(font.lineHeight);
	    }
	    ctx.restore();
	}
	/**
	 * Add a path of a rectangle with rounded corners to the current sub-path
	 * @param ctx - Context
	 * @param rect - Bounding rect
	 */ function addRoundedRectPath(ctx, rect) {
	    const { x , y , w , h , radius  } = rect;
	    // top left arc
	    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
	    // line from top left to bottom left
	    ctx.lineTo(x, y + h - radius.bottomLeft);
	    // bottom left arc
	    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
	    // line from bottom left to bottom right
	    ctx.lineTo(x + w - radius.bottomRight, y + h);
	    // bottom right arc
	    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
	    // line from bottom right to top right
	    ctx.lineTo(x + w, y + radius.topRight);
	    // top right arc
	    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
	    // line from top right to top left
	    ctx.lineTo(x + radius.topLeft, y);
	}

	const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
	const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
	/**
	 * @alias Chart.helpers.options
	 * @namespace
	 */ /**
	 * Converts the given line height `value` in pixels for a specific font `size`.
	 * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
	 * @param size - The font size (in pixels) used to resolve relative `value`.
	 * @returns The effective line height in pixels (size * 1.2 if value is invalid).
	 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
	 * @since 2.7.0
	 */ function toLineHeight(value, size) {
	    const matches = ('' + value).match(LINE_HEIGHT);
	    if (!matches || matches[1] === 'normal') {
	        return size * 1.2;
	    }
	    value = +matches[2];
	    switch(matches[3]){
	        case 'px':
	            return value;
	        case '%':
	            value /= 100;
	            break;
	    }
	    return size * value;
	}
	const numberOrZero = (v)=>+v || 0;
	function _readValueToProps(value, props) {
	    const ret = {};
	    const objProps = isObject$1(props);
	    const keys = objProps ? Object.keys(props) : props;
	    const read = isObject$1(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;
	    for (const prop of keys){
	        ret[prop] = numberOrZero(read(prop));
	    }
	    return ret;
	}
	/**
	 * Converts the given value into a TRBL object.
	 * @param value - If a number, set the value to all TRBL component,
	 *  else, if an object, use defined properties and sets undefined ones to 0.
	 *  x / y are shorthands for same value for left/right and top/bottom.
	 * @returns The padding values (top, right, bottom, left)
	 * @since 3.0.0
	 */ function toTRBL(value) {
	    return _readValueToProps(value, {
	        top: 'y',
	        right: 'x',
	        bottom: 'y',
	        left: 'x'
	    });
	}
	/**
	 * Converts the given value into a TRBL corners object (similar with css border-radius).
	 * @param value - If a number, set the value to all TRBL corner components,
	 *  else, if an object, use defined properties and sets undefined ones to 0.
	 * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)
	 * @since 3.0.0
	 */ function toTRBLCorners(value) {
	    return _readValueToProps(value, [
	        'topLeft',
	        'topRight',
	        'bottomLeft',
	        'bottomRight'
	    ]);
	}
	/**
	 * Converts the given value into a padding object with pre-computed width/height.
	 * @param value - If a number, set the value to all TRBL component,
	 *  else, if an object, use defined properties and sets undefined ones to 0.
	 *  x / y are shorthands for same value for left/right and top/bottom.
	 * @returns The padding values (top, right, bottom, left, width, height)
	 * @since 2.7.0
	 */ function toPadding(value) {
	    const obj = toTRBL(value);
	    obj.width = obj.left + obj.right;
	    obj.height = obj.top + obj.bottom;
	    return obj;
	}
	/**
	 * Parses font options and returns the font object.
	 * @param options - A object that contains font options to be parsed.
	 * @param fallback - A object that contains fallback font options.
	 * @return The font object.
	 * @private
	 */ function toFont(options, fallback) {
	    options = options || {};
	    fallback = fallback || defaults.font;
	    let size = valueOrDefault(options.size, fallback.size);
	    if (typeof size === 'string') {
	        size = parseInt(size, 10);
	    }
	    let style = valueOrDefault(options.style, fallback.style);
	    if (style && !('' + style).match(FONT_STYLE)) {
	        console.warn('Invalid font style specified: "' + style + '"');
	        style = undefined;
	    }
	    const font = {
	        family: valueOrDefault(options.family, fallback.family),
	        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
	        size,
	        style,
	        weight: valueOrDefault(options.weight, fallback.weight),
	        string: ''
	    };
	    font.string = toFontString(font);
	    return font;
	}
	/**
	 * Evaluates the given `inputs` sequentially and returns the first defined value.
	 * @param inputs - An array of values, falling back to the last value.
	 * @param context - If defined and the current value is a function, the value
	 * is called with `context` as first argument and the result becomes the new input.
	 * @param index - If defined and the current value is an array, the value
	 * at `index` become the new input.
	 * @param info - object to return information about resolution in
	 * @param info.cacheable - Will be set to `false` if option is not cacheable.
	 * @since 2.7.0
	 */ function resolve(inputs, context, index, info) {
	    let cacheable = true;
	    let i, ilen, value;
	    for(i = 0, ilen = inputs.length; i < ilen; ++i){
	        value = inputs[i];
	        if (value === undefined) {
	            continue;
	        }
	        if (context !== undefined && typeof value === 'function') {
	            value = value(context);
	            cacheable = false;
	        }
	        if (index !== undefined && isArray$1(value)) {
	            value = value[index % value.length];
	            cacheable = false;
	        }
	        if (value !== undefined) {
	            if (info && !cacheable) {
	                info.cacheable = false;
	            }
	            return value;
	        }
	    }
	}
	/**
	 * @param minmax
	 * @param grace
	 * @param beginAtZero
	 * @private
	 */ function _addGrace(minmax, grace, beginAtZero) {
	    const { min , max  } = minmax;
	    const change = toDimension(grace, (max - min) / 2);
	    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;
	    return {
	        min: keepZero(min, -Math.abs(change)),
	        max: keepZero(max, change)
	    };
	}
	function createContext(parentContext, context) {
	    return Object.assign(Object.create(parentContext), context);
	}

	/**
	 * Creates a Proxy for resolving raw values for options.
	 * @param scopes - The option scopes to look for values, in resolution order
	 * @param prefixes - The prefixes for values, in resolution order.
	 * @param rootScopes - The root option scopes
	 * @param fallback - Parent scopes fallback
	 * @param getTarget - callback for getting the target for changed values
	 * @returns Proxy
	 * @private
	 */ function _createResolver(scopes, prefixes = [
	    ''
	], rootScopes, fallback, getTarget = ()=>scopes[0]) {
	    const finalRootScopes = rootScopes || scopes;
	    if (typeof fallback === 'undefined') {
	        fallback = _resolve('_fallback', scopes);
	    }
	    const cache = {
	        [Symbol.toStringTag]: 'Object',
	        _cacheable: true,
	        _scopes: scopes,
	        _rootScopes: finalRootScopes,
	        _fallback: fallback,
	        _getTarget: getTarget,
	        override: (scope)=>_createResolver([
	                scope,
	                ...scopes
	            ], prefixes, finalRootScopes, fallback)
	    };
	    return new Proxy(cache, {
	        /**
	     * A trap for the delete operator.
	     */ deleteProperty (target, prop) {
	            delete target[prop]; // remove from cache
	            delete target._keys; // remove cached keys
	            delete scopes[0][prop]; // remove from top level scope
	            return true;
	        },
	        /**
	     * A trap for getting property values.
	     */ get (target, prop) {
	            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));
	        },
	        /**
	     * A trap for Object.getOwnPropertyDescriptor.
	     * Also used by Object.hasOwnProperty.
	     */ getOwnPropertyDescriptor (target, prop) {
	            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
	        },
	        /**
	     * A trap for Object.getPrototypeOf.
	     */ getPrototypeOf () {
	            return Reflect.getPrototypeOf(scopes[0]);
	        },
	        /**
	     * A trap for the in operator.
	     */ has (target, prop) {
	            return getKeysFromAllScopes(target).includes(prop);
	        },
	        /**
	     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
	     */ ownKeys (target) {
	            return getKeysFromAllScopes(target);
	        },
	        /**
	     * A trap for setting property values.
	     */ set (target, prop, value) {
	            const storage = target._storage || (target._storage = getTarget());
	            target[prop] = storage[prop] = value; // set to top level scope + cache
	            delete target._keys; // remove cached keys
	            return true;
	        }
	    });
	}
	/**
	 * Returns an Proxy for resolving option values with context.
	 * @param proxy - The Proxy returned by `_createResolver`
	 * @param context - Context object for scriptable/indexable options
	 * @param subProxy - The proxy provided for scriptable options
	 * @param descriptorDefaults - Defaults for descriptors
	 * @private
	 */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {
	    const cache = {
	        _cacheable: false,
	        _proxy: proxy,
	        _context: context,
	        _subProxy: subProxy,
	        _stack: new Set(),
	        _descriptors: _descriptors(proxy, descriptorDefaults),
	        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),
	        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
	    };
	    return new Proxy(cache, {
	        /**
	     * A trap for the delete operator.
	     */ deleteProperty (target, prop) {
	            delete target[prop]; // remove from cache
	            delete proxy[prop]; // remove from proxy
	            return true;
	        },
	        /**
	     * A trap for getting property values.
	     */ get (target, prop, receiver) {
	            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));
	        },
	        /**
	     * A trap for Object.getOwnPropertyDescriptor.
	     * Also used by Object.hasOwnProperty.
	     */ getOwnPropertyDescriptor (target, prop) {
	            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
	                enumerable: true,
	                configurable: true
	            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);
	        },
	        /**
	     * A trap for Object.getPrototypeOf.
	     */ getPrototypeOf () {
	            return Reflect.getPrototypeOf(proxy);
	        },
	        /**
	     * A trap for the in operator.
	     */ has (target, prop) {
	            return Reflect.has(proxy, prop);
	        },
	        /**
	     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
	     */ ownKeys () {
	            return Reflect.ownKeys(proxy);
	        },
	        /**
	     * A trap for setting property values.
	     */ set (target, prop, value) {
	            proxy[prop] = value; // set to proxy
	            delete target[prop]; // remove from cache
	            return true;
	        }
	    });
	}
	/**
	 * @private
	 */ function _descriptors(proxy, defaults = {
	    scriptable: true,
	    indexable: true
	}) {
	    const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;
	    return {
	        allKeys: _allKeys,
	        scriptable: _scriptable,
	        indexable: _indexable,
	        isScriptable: isFunction$1(_scriptable) ? _scriptable : ()=>_scriptable,
	        isIndexable: isFunction$1(_indexable) ? _indexable : ()=>_indexable
	    };
	}
	const readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;
	const needsSubResolver = (prop, value)=>isObject$1(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);
	function _cached(target, prop, resolve) {
	    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {
	        return target[prop];
	    }
	    const value = resolve();
	    // cache the resolved value
	    target[prop] = value;
	    return value;
	}
	function _resolveWithContext(target, prop, receiver) {
	    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;
	    let value = _proxy[prop]; // resolve from proxy
	    // resolve with context
	    if (isFunction$1(value) && descriptors.isScriptable(prop)) {
	        value = _resolveScriptable(prop, value, target, receiver);
	    }
	    if (isArray$1(value) && value.length) {
	        value = _resolveArray(prop, value, target, descriptors.isIndexable);
	    }
	    if (needsSubResolver(prop, value)) {
	        // if the resolved value is an object, create a sub resolver for it
	        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
	    }
	    return value;
	}
	function _resolveScriptable(prop, getValue, target, receiver) {
	    const { _proxy , _context , _subProxy , _stack  } = target;
	    if (_stack.has(prop)) {
	        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
	    }
	    _stack.add(prop);
	    let value = getValue(_context, _subProxy || receiver);
	    _stack.delete(prop);
	    if (needsSubResolver(prop, value)) {
	        // When scriptable option returns an object, create a resolver on that.
	        value = createSubResolver(_proxy._scopes, _proxy, prop, value);
	    }
	    return value;
	}
	function _resolveArray(prop, value, target, isIndexable) {
	    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;
	    if (typeof _context.index !== 'undefined' && isIndexable(prop)) {
	        return value[_context.index % value.length];
	    } else if (isObject$1(value[0])) {
	        // Array of objects, return array or resolvers
	        const arr = value;
	        const scopes = _proxy._scopes.filter((s)=>s !== arr);
	        value = [];
	        for (const item of arr){
	            const resolver = createSubResolver(scopes, _proxy, prop, item);
	            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
	        }
	    }
	    return value;
	}
	function resolveFallback(fallback, prop, value) {
	    return isFunction$1(fallback) ? fallback(prop, value) : fallback;
	}
	const getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;
	function addScopes(set, parentScopes, key, parentFallback, value) {
	    for (const parent of parentScopes){
	        const scope = getScope(key, parent);
	        if (scope) {
	            set.add(scope);
	            const fallback = resolveFallback(scope._fallback, key, value);
	            if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {
	                // When we reach the descriptor that defines a new _fallback, return that.
	                // The fallback will resume to that new scope.
	                return fallback;
	            }
	        } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {
	            // Fallback to `false` results to `false`, when falling back to different key.
	            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`
	            return null;
	        }
	    }
	    return false;
	}
	function createSubResolver(parentScopes, resolver, prop, value) {
	    const rootScopes = resolver._rootScopes;
	    const fallback = resolveFallback(resolver._fallback, prop, value);
	    const allScopes = [
	        ...parentScopes,
	        ...rootScopes
	    ];
	    const set = new Set();
	    set.add(value);
	    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
	    if (key === null) {
	        return false;
	    }
	    if (typeof fallback !== 'undefined' && fallback !== prop) {
	        key = addScopesFromKey(set, allScopes, fallback, key, value);
	        if (key === null) {
	            return false;
	        }
	    }
	    return _createResolver(Array.from(set), [
	        ''
	    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));
	}
	function addScopesFromKey(set, allScopes, key, fallback, item) {
	    while(key){
	        key = addScopes(set, allScopes, key, fallback, item);
	    }
	    return key;
	}
	function subGetTarget(resolver, prop, value) {
	    const parent = resolver._getTarget();
	    if (!(prop in parent)) {
	        parent[prop] = {};
	    }
	    const target = parent[prop];
	    if (isArray$1(target) && isObject$1(value)) {
	        // For array of objects, the object is used to store updated values
	        return value;
	    }
	    return target || {};
	}
	function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
	    let value;
	    for (const prefix of prefixes){
	        value = _resolve(readKey(prefix, prop), scopes);
	        if (typeof value !== 'undefined') {
	            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
	        }
	    }
	}
	function _resolve(key, scopes) {
	    for (const scope of scopes){
	        if (!scope) {
	            continue;
	        }
	        const value = scope[key];
	        if (typeof value !== 'undefined') {
	            return value;
	        }
	    }
	}
	function getKeysFromAllScopes(target) {
	    let keys = target._keys;
	    if (!keys) {
	        keys = target._keys = resolveKeysFromAllScopes(target._scopes);
	    }
	    return keys;
	}
	function resolveKeysFromAllScopes(scopes) {
	    const set = new Set();
	    for (const scope of scopes){
	        for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){
	            set.add(key);
	        }
	    }
	    return Array.from(set);
	}

	const EPSILON = Number.EPSILON || 1e-14;
	const getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];
	const getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';
	function splineCurve(firstPoint, middlePoint, afterPoint, t) {
	    // Props to Rob Spencer at scaled innovation for his post on splining between points
	    // http://scaledinnovation.com/analytics/splines/aboutSplines.html
	    // This function must also respect "skipped" points
	    const previous = firstPoint.skip ? middlePoint : firstPoint;
	    const current = middlePoint;
	    const next = afterPoint.skip ? middlePoint : afterPoint;
	    const d01 = distanceBetweenPoints(current, previous);
	    const d12 = distanceBetweenPoints(next, current);
	    let s01 = d01 / (d01 + d12);
	    let s12 = d12 / (d01 + d12);
	    // If all points are the same, s01 & s02 will be inf
	    s01 = isNaN(s01) ? 0 : s01;
	    s12 = isNaN(s12) ? 0 : s12;
	    const fa = t * s01; // scaling factor for triangle Ta
	    const fb = t * s12;
	    return {
	        previous: {
	            x: current.x - fa * (next.x - previous.x),
	            y: current.y - fa * (next.y - previous.y)
	        },
	        next: {
	            x: current.x + fb * (next.x - previous.x),
	            y: current.y + fb * (next.y - previous.y)
	        }
	    };
	}
	/**
	 * Adjust tangents to ensure monotonic properties
	 */ function monotoneAdjust(points, deltaK, mK) {
	    const pointsLen = points.length;
	    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
	    let pointAfter = getPoint(points, 0);
	    for(let i = 0; i < pointsLen - 1; ++i){
	        pointCurrent = pointAfter;
	        pointAfter = getPoint(points, i + 1);
	        if (!pointCurrent || !pointAfter) {
	            continue;
	        }
	        if (almostEquals(deltaK[i], 0, EPSILON)) {
	            mK[i] = mK[i + 1] = 0;
	            continue;
	        }
	        alphaK = mK[i] / deltaK[i];
	        betaK = mK[i + 1] / deltaK[i];
	        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
	        if (squaredMagnitude <= 9) {
	            continue;
	        }
	        tauK = 3 / Math.sqrt(squaredMagnitude);
	        mK[i] = alphaK * tauK * deltaK[i];
	        mK[i + 1] = betaK * tauK * deltaK[i];
	    }
	}
	function monotoneCompute(points, mK, indexAxis = 'x') {
	    const valueAxis = getValueAxis(indexAxis);
	    const pointsLen = points.length;
	    let delta, pointBefore, pointCurrent;
	    let pointAfter = getPoint(points, 0);
	    for(let i = 0; i < pointsLen; ++i){
	        pointBefore = pointCurrent;
	        pointCurrent = pointAfter;
	        pointAfter = getPoint(points, i + 1);
	        if (!pointCurrent) {
	            continue;
	        }
	        const iPixel = pointCurrent[indexAxis];
	        const vPixel = pointCurrent[valueAxis];
	        if (pointBefore) {
	            delta = (iPixel - pointBefore[indexAxis]) / 3;
	            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
	            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
	        }
	        if (pointAfter) {
	            delta = (pointAfter[indexAxis] - iPixel) / 3;
	            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
	            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
	        }
	    }
	}
	/**
	 * This function calculates Bzier control points in a similar way than |splineCurve|,
	 * but preserves monotonicity of the provided data and ensures no local extremums are added
	 * between the dataset discrete points due to the interpolation.
	 * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
	 */ function splineCurveMonotone(points, indexAxis = 'x') {
	    const valueAxis = getValueAxis(indexAxis);
	    const pointsLen = points.length;
	    const deltaK = Array(pointsLen).fill(0);
	    const mK = Array(pointsLen);
	    // Calculate slopes (deltaK) and initialize tangents (mK)
	    let i, pointBefore, pointCurrent;
	    let pointAfter = getPoint(points, 0);
	    for(i = 0; i < pointsLen; ++i){
	        pointBefore = pointCurrent;
	        pointCurrent = pointAfter;
	        pointAfter = getPoint(points, i + 1);
	        if (!pointCurrent) {
	            continue;
	        }
	        if (pointAfter) {
	            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
	            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
	            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
	        }
	        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
	    }
	    monotoneAdjust(points, deltaK, mK);
	    monotoneCompute(points, mK, indexAxis);
	}
	function capControlPoint(pt, min, max) {
	    return Math.max(Math.min(pt, max), min);
	}
	function capBezierPoints(points, area) {
	    let i, ilen, point, inArea, inAreaPrev;
	    let inAreaNext = _isPointInArea(points[0], area);
	    for(i = 0, ilen = points.length; i < ilen; ++i){
	        inAreaPrev = inArea;
	        inArea = inAreaNext;
	        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
	        if (!inArea) {
	            continue;
	        }
	        point = points[i];
	        if (inAreaPrev) {
	            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
	            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
	        }
	        if (inAreaNext) {
	            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
	            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
	        }
	    }
	}
	/**
	 * @private
	 */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
	    let i, ilen, point, controlPoints;
	    // Only consider points that are drawn in case the spanGaps option is used
	    if (options.spanGaps) {
	        points = points.filter((pt)=>!pt.skip);
	    }
	    if (options.cubicInterpolationMode === 'monotone') {
	        splineCurveMonotone(points, indexAxis);
	    } else {
	        let prev = loop ? points[points.length - 1] : points[0];
	        for(i = 0, ilen = points.length; i < ilen; ++i){
	            point = points[i];
	            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
	            point.cp1x = controlPoints.previous.x;
	            point.cp1y = controlPoints.previous.y;
	            point.cp2x = controlPoints.next.x;
	            point.cp2y = controlPoints.next.y;
	            prev = point;
	        }
	    }
	    if (options.capBezierPoints) {
	        capBezierPoints(points, area);
	    }
	}

	/**
	 * Note: typedefs are auto-exported, so use a made-up `dom` namespace where
	 * necessary to avoid duplicates with `export * from './helpers`; see
	 * https://github.com/microsoft/TypeScript/issues/46011
	 * @typedef { import('../core/core.controller.js').default } dom.Chart
	 * @typedef { import('../../types').ChartEvent } ChartEvent
	 */ /**
	 * @private
	 */ function _isDomSupported() {
	    return typeof window !== 'undefined' && typeof document !== 'undefined';
	}
	/**
	 * @private
	 */ function _getParentNode(domNode) {
	    let parent = domNode.parentNode;
	    if (parent && parent.toString() === '[object ShadowRoot]') {
	        parent = parent.host;
	    }
	    return parent;
	}
	/**
	 * convert max-width/max-height values that may be percentages into a number
	 * @private
	 */ function parseMaxStyle(styleValue, node, parentProperty) {
	    let valueInPixels;
	    if (typeof styleValue === 'string') {
	        valueInPixels = parseInt(styleValue, 10);
	        if (styleValue.indexOf('%') !== -1) {
	            // percentage * size in dimension
	            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
	        }
	    } else {
	        valueInPixels = styleValue;
	    }
	    return valueInPixels;
	}
	const getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);
	function getStyle(el, property) {
	    return getComputedStyle(el).getPropertyValue(property);
	}
	const positions = [
	    'top',
	    'right',
	    'bottom',
	    'left'
	];
	function getPositionedStyle(styles, style, suffix) {
	    const result = {};
	    suffix = suffix ? '-' + suffix : '';
	    for(let i = 0; i < 4; i++){
	        const pos = positions[i];
	        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
	    }
	    result.width = result.left + result.right;
	    result.height = result.top + result.bottom;
	    return result;
	}
	const useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);
	/**
	 * @param e
	 * @param canvas
	 * @returns Canvas position
	 */ function getCanvasPosition(e, canvas) {
	    const touches = e.touches;
	    const source = touches && touches.length ? touches[0] : e;
	    const { offsetX , offsetY  } = source;
	    let box = false;
	    let x, y;
	    if (useOffsetPos(offsetX, offsetY, e.target)) {
	        x = offsetX;
	        y = offsetY;
	    } else {
	        const rect = canvas.getBoundingClientRect();
	        x = source.clientX - rect.left;
	        y = source.clientY - rect.top;
	        box = true;
	    }
	    return {
	        x,
	        y,
	        box
	    };
	}
	/**
	 * Gets an event's x, y coordinates, relative to the chart area
	 * @param event
	 * @param chart
	 * @returns x and y coordinates of the event
	 */ function getRelativePosition(event, chart) {
	    if ('native' in event) {
	        return event;
	    }
	    const { canvas , currentDevicePixelRatio  } = chart;
	    const style = getComputedStyle(canvas);
	    const borderBox = style.boxSizing === 'border-box';
	    const paddings = getPositionedStyle(style, 'padding');
	    const borders = getPositionedStyle(style, 'border', 'width');
	    const { x , y , box  } = getCanvasPosition(event, canvas);
	    const xOffset = paddings.left + (box && borders.left);
	    const yOffset = paddings.top + (box && borders.top);
	    let { width , height  } = chart;
	    if (borderBox) {
	        width -= paddings.width + borders.width;
	        height -= paddings.height + borders.height;
	    }
	    return {
	        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
	        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
	    };
	}
	function getContainerSize(canvas, width, height) {
	    let maxWidth, maxHeight;
	    if (width === undefined || height === undefined) {
	        const container = canvas && _getParentNode(canvas);
	        if (!container) {
	            width = canvas.clientWidth;
	            height = canvas.clientHeight;
	        } else {
	            const rect = container.getBoundingClientRect(); // this is the border box of the container
	            const containerStyle = getComputedStyle(container);
	            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
	            const containerPadding = getPositionedStyle(containerStyle, 'padding');
	            width = rect.width - containerPadding.width - containerBorder.width;
	            height = rect.height - containerPadding.height - containerBorder.height;
	            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
	            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
	        }
	    }
	    return {
	        width,
	        height,
	        maxWidth: maxWidth || INFINITY,
	        maxHeight: maxHeight || INFINITY
	    };
	}
	const round1 = (v)=>Math.round(v * 10) / 10;
	// eslint-disable-next-line complexity
	function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
	    const style = getComputedStyle(canvas);
	    const margins = getPositionedStyle(style, 'margin');
	    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
	    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
	    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
	    let { width , height  } = containerSize;
	    if (style.boxSizing === 'content-box') {
	        const borders = getPositionedStyle(style, 'border', 'width');
	        const paddings = getPositionedStyle(style, 'padding');
	        width -= paddings.width + borders.width;
	        height -= paddings.height + borders.height;
	    }
	    width = Math.max(0, width - margins.width);
	    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
	    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
	    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
	    if (width && !height) {
	        // https://github.com/chartjs/Chart.js/issues/4659
	        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)
	        height = round1(width / 2);
	    }
	    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;
	    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
	        height = containerSize.height;
	        width = round1(Math.floor(height * aspectRatio));
	    }
	    return {
	        width,
	        height
	    };
	}
	/**
	 * @param chart
	 * @param forceRatio
	 * @param forceStyle
	 * @returns True if the canvas context size or transformation has changed.
	 */ function retinaScale(chart, forceRatio, forceStyle) {
	    const pixelRatio = forceRatio || 1;
	    const deviceHeight = Math.floor(chart.height * pixelRatio);
	    const deviceWidth = Math.floor(chart.width * pixelRatio);
	    chart.height = Math.floor(chart.height);
	    chart.width = Math.floor(chart.width);
	    const canvas = chart.canvas;
	    // If no style has been set on the canvas, the render size is used as display size,
	    // making the chart visually bigger, so let's enforce it to the "correct" values.
	    // See https://github.com/chartjs/Chart.js/issues/3575
	    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
	        canvas.style.height = `${chart.height}px`;
	        canvas.style.width = `${chart.width}px`;
	    }
	    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
	        chart.currentDevicePixelRatio = pixelRatio;
	        canvas.height = deviceHeight;
	        canvas.width = deviceWidth;
	        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
	        return true;
	    }
	    return false;
	}
	/**
	 * Detects support for options object argument in addEventListener.
	 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
	 * @private
	 */ const supportsEventListenerOptions = function() {
	    let passiveSupported = false;
	    try {
	        const options = {
	            get passive () {
	                passiveSupported = true;
	                return false;
	            }
	        };
	        if (_isDomSupported()) {
	            window.addEventListener('test', null, options);
	            window.removeEventListener('test', null, options);
	        }
	    } catch (e) {
	    // continue regardless of error
	    }
	    return passiveSupported;
	}();
	/**
	 * The "used" size is the final value of a dimension property after all calculations have
	 * been performed. This method uses the computed style of `element` but returns undefined
	 * if the computed style is not expressed in pixels. That can happen in some cases where
	 * `element` has a size relative to its parent and this last one is not yet displayed,
	 * for example because of `display: none` on a parent node.
	 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
	 * @returns Size in pixels or undefined if unknown.
	 */ function readUsedSize(element, property) {
	    const value = getStyle(element, property);
	    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
	    return matches ? +matches[1] : undefined;
	}

	/**
	 * @private
	 */ function _pointInLine(p1, p2, t, mode) {
	    return {
	        x: p1.x + t * (p2.x - p1.x),
	        y: p1.y + t * (p2.y - p1.y)
	    };
	}
	/**
	 * @private
	 */ function _steppedInterpolation(p1, p2, t, mode) {
	    return {
	        x: p1.x + t * (p2.x - p1.x),
	        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
	    };
	}
	/**
	 * @private
	 */ function _bezierInterpolation(p1, p2, t, mode) {
	    const cp1 = {
	        x: p1.cp2x,
	        y: p1.cp2y
	    };
	    const cp2 = {
	        x: p2.cp1x,
	        y: p2.cp1y
	    };
	    const a = _pointInLine(p1, cp1, t);
	    const b = _pointInLine(cp1, cp2, t);
	    const c = _pointInLine(cp2, p2, t);
	    const d = _pointInLine(a, b, t);
	    const e = _pointInLine(b, c, t);
	    return _pointInLine(d, e, t);
	}

	const getRightToLeftAdapter = function(rectX, width) {
	    return {
	        x (x) {
	            return rectX + rectX + width - x;
	        },
	        setWidth (w) {
	            width = w;
	        },
	        textAlign (align) {
	            if (align === 'center') {
	                return align;
	            }
	            return align === 'right' ? 'left' : 'right';
	        },
	        xPlus (x, value) {
	            return x - value;
	        },
	        leftForLtr (x, itemWidth) {
	            return x - itemWidth;
	        }
	    };
	};
	const getLeftToRightAdapter = function() {
	    return {
	        x (x) {
	            return x;
	        },
	        setWidth (w) {},
	        textAlign (align) {
	            return align;
	        },
	        xPlus (x, value) {
	            return x + value;
	        },
	        leftForLtr (x, _itemWidth) {
	            return x;
	        }
	    };
	};
	function getRtlAdapter(rtl, rectX, width) {
	    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
	}
	function overrideTextDirection(ctx, direction) {
	    let style, original;
	    if (direction === 'ltr' || direction === 'rtl') {
	        style = ctx.canvas.style;
	        original = [
	            style.getPropertyValue('direction'),
	            style.getPropertyPriority('direction')
	        ];
	        style.setProperty('direction', direction, 'important');
	        ctx.prevTextDirection = original;
	    }
	}
	function restoreTextDirection(ctx, original) {
	    if (original !== undefined) {
	        delete ctx.prevTextDirection;
	        ctx.canvas.style.setProperty('direction', original[0], original[1]);
	    }
	}

	function propertyFn(property) {
	    if (property === 'angle') {
	        return {
	            between: _angleBetween,
	            compare: _angleDiff,
	            normalize: _normalizeAngle
	        };
	    }
	    return {
	        between: _isBetween,
	        compare: (a, b)=>a - b,
	        normalize: (x)=>x
	    };
	}
	function normalizeSegment({ start , end , count , loop , style  }) {
	    return {
	        start: start % count,
	        end: end % count,
	        loop: loop && (end - start + 1) % count === 0,
	        style
	    };
	}
	function getSegment(segment, points, bounds) {
	    const { property , start: startBound , end: endBound  } = bounds;
	    const { between , normalize  } = propertyFn(property);
	    const count = points.length;
	    let { start , end , loop  } = segment;
	    let i, ilen;
	    if (loop) {
	        start += count;
	        end += count;
	        for(i = 0, ilen = count; i < ilen; ++i){
	            if (!between(normalize(points[start % count][property]), startBound, endBound)) {
	                break;
	            }
	            start--;
	            end--;
	        }
	        start %= count;
	        end %= count;
	    }
	    if (end < start) {
	        end += count;
	    }
	    return {
	        start,
	        end,
	        loop,
	        style: segment.style
	    };
	}
	 function _boundSegment(segment, points, bounds) {
	    if (!bounds) {
	        return [
	            segment
	        ];
	    }
	    const { property , start: startBound , end: endBound  } = bounds;
	    const count = points.length;
	    const { compare , between , normalize  } = propertyFn(property);
	    const { start , end , loop , style  } = getSegment(segment, points, bounds);
	    const result = [];
	    let inside = false;
	    let subStart = null;
	    let value, point, prevValue;
	    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
	    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);
	    const shouldStart = ()=>inside || startIsBefore();
	    const shouldStop = ()=>!inside || endIsBefore();
	    for(let i = start, prev = start; i <= end; ++i){
	        point = points[i % count];
	        if (point.skip) {
	            continue;
	        }
	        value = normalize(point[property]);
	        if (value === prevValue) {
	            continue;
	        }
	        inside = between(value, startBound, endBound);
	        if (subStart === null && shouldStart()) {
	            subStart = compare(value, startBound) === 0 ? i : prev;
	        }
	        if (subStart !== null && shouldStop()) {
	            result.push(normalizeSegment({
	                start: subStart,
	                end: i,
	                loop,
	                count,
	                style
	            }));
	            subStart = null;
	        }
	        prev = i;
	        prevValue = value;
	    }
	    if (subStart !== null) {
	        result.push(normalizeSegment({
	            start: subStart,
	            end,
	            loop,
	            count,
	            style
	        }));
	    }
	    return result;
	}
	 function _boundSegments(line, bounds) {
	    const result = [];
	    const segments = line.segments;
	    for(let i = 0; i < segments.length; i++){
	        const sub = _boundSegment(segments[i], line.points, bounds);
	        if (sub.length) {
	            result.push(...sub);
	        }
	    }
	    return result;
	}
	 function findStartAndEnd(points, count, loop, spanGaps) {
	    let start = 0;
	    let end = count - 1;
	    if (loop && !spanGaps) {
	        while(start < count && !points[start].skip){
	            start++;
	        }
	    }
	    while(start < count && points[start].skip){
	        start++;
	    }
	    start %= count;
	    if (loop) {
	        end += start;
	    }
	    while(end > start && points[end % count].skip){
	        end--;
	    }
	    end %= count;
	    return {
	        start,
	        end
	    };
	}
	 function solidSegments(points, start, max, loop) {
	    const count = points.length;
	    const result = [];
	    let last = start;
	    let prev = points[start];
	    let end;
	    for(end = start + 1; end <= max; ++end){
	        const cur = points[end % count];
	        if (cur.skip || cur.stop) {
	            if (!prev.skip) {
	                loop = false;
	                result.push({
	                    start: start % count,
	                    end: (end - 1) % count,
	                    loop
	                });
	                start = last = cur.stop ? end : null;
	            }
	        } else {
	            last = end;
	            if (prev.skip) {
	                start = end;
	            }
	        }
	        prev = cur;
	    }
	    if (last !== null) {
	        result.push({
	            start: start % count,
	            end: last % count,
	            loop
	        });
	    }
	    return result;
	}
	 function _computeSegments(line, segmentOptions) {
	    const points = line.points;
	    const spanGaps = line.options.spanGaps;
	    const count = points.length;
	    if (!count) {
	        return [];
	    }
	    const loop = !!line._loop;
	    const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);
	    if (spanGaps === true) {
	        return splitByStyles(line, [
	            {
	                start,
	                end,
	                loop
	            }
	        ], points, segmentOptions);
	    }
	    const max = end < start ? end + count : end;
	    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
	    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
	}
	 function splitByStyles(line, segments, points, segmentOptions) {
	    if (!segmentOptions || !segmentOptions.setContext || !points) {
	        return segments;
	    }
	    return doSplitByStyles(line, segments, points, segmentOptions);
	}
	 function doSplitByStyles(line, segments, points, segmentOptions) {
	    const chartContext = line._chart.getContext();
	    const baseStyle = readStyle(line.options);
	    const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;
	    const count = points.length;
	    const result = [];
	    let prevStyle = baseStyle;
	    let start = segments[0].start;
	    let i = start;
	    function addStyle(s, e, l, st) {
	        const dir = spanGaps ? -1 : 1;
	        if (s === e) {
	            return;
	        }
	        s += count;
	        while(points[s % count].skip){
	            s -= dir;
	        }
	        while(points[e % count].skip){
	            e += dir;
	        }
	        if (s % count !== e % count) {
	            result.push({
	                start: s % count,
	                end: e % count,
	                loop: l,
	                style: st
	            });
	            prevStyle = st;
	            start = e % count;
	        }
	    }
	    for (const segment of segments){
	        start = spanGaps ? start : segment.start;
	        let prev = points[start % count];
	        let style;
	        for(i = start + 1; i <= segment.end; i++){
	            const pt = points[i % count];
	            style = readStyle(segmentOptions.setContext(createContext(chartContext, {
	                type: 'segment',
	                p0: prev,
	                p1: pt,
	                p0DataIndex: (i - 1) % count,
	                p1DataIndex: i % count,
	                datasetIndex
	            })));
	            if (styleChanged(style, prevStyle)) {
	                addStyle(start, i - 1, segment.loop, prevStyle);
	            }
	            prev = pt;
	            prevStyle = style;
	        }
	        if (start < i - 1) {
	            addStyle(start, i - 1, segment.loop, prevStyle);
	        }
	    }
	    return result;
	}
	function readStyle(options) {
	    return {
	        backgroundColor: options.backgroundColor,
	        borderCapStyle: options.borderCapStyle,
	        borderDash: options.borderDash,
	        borderDashOffset: options.borderDashOffset,
	        borderJoinStyle: options.borderJoinStyle,
	        borderWidth: options.borderWidth,
	        borderColor: options.borderColor
	    };
	}
	function styleChanged(style, prevStyle) {
	    if (!prevStyle) {
	        return false;
	    }
	    const cache = [];
	    const replacer = function(key, value) {
	        if (!isPatternOrGradient(value)) {
	            return value;
	        }
	        if (!cache.includes(value)) {
	            cache.push(value);
	        }
	        return cache.indexOf(value);
	    };
	    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
	}

	/*!
	 * Chart.js v4.4.4
	 * https://www.chartjs.org
	 * (c) 2024 Chart.js Contributors
	 * Released under the MIT License
	 */

	class Animator {
	    constructor(){
	        this._request = null;
	        this._charts = new Map();
	        this._running = false;
	        this._lastDate = undefined;
	    }
	 _notify(chart, anims, date, type) {
	        const callbacks = anims.listeners[type];
	        const numSteps = anims.duration;
	        callbacks.forEach((fn)=>fn({
	                chart,
	                initial: anims.initial,
	                numSteps,
	                currentStep: Math.min(date - anims.start, numSteps)
	            }));
	    }
	 _refresh() {
	        if (this._request) {
	            return;
	        }
	        this._running = true;
	        this._request = requestAnimFrame.call(window, ()=>{
	            this._update();
	            this._request = null;
	            if (this._running) {
	                this._refresh();
	            }
	        });
	    }
	 _update(date = Date.now()) {
	        let remaining = 0;
	        this._charts.forEach((anims, chart)=>{
	            if (!anims.running || !anims.items.length) {
	                return;
	            }
	            const items = anims.items;
	            let i = items.length - 1;
	            let draw = false;
	            let item;
	            for(; i >= 0; --i){
	                item = items[i];
	                if (item._active) {
	                    if (item._total > anims.duration) {
	                        anims.duration = item._total;
	                    }
	                    item.tick(date);
	                    draw = true;
	                } else {
	                    items[i] = items[items.length - 1];
	                    items.pop();
	                }
	            }
	            if (draw) {
	                chart.draw();
	                this._notify(chart, anims, date, 'progress');
	            }
	            if (!items.length) {
	                anims.running = false;
	                this._notify(chart, anims, date, 'complete');
	                anims.initial = false;
	            }
	            remaining += items.length;
	        });
	        this._lastDate = date;
	        if (remaining === 0) {
	            this._running = false;
	        }
	    }
	 _getAnims(chart) {
	        const charts = this._charts;
	        let anims = charts.get(chart);
	        if (!anims) {
	            anims = {
	                running: false,
	                initial: true,
	                items: [],
	                listeners: {
	                    complete: [],
	                    progress: []
	                }
	            };
	            charts.set(chart, anims);
	        }
	        return anims;
	    }
	 listen(chart, event, cb) {
	        this._getAnims(chart).listeners[event].push(cb);
	    }
	 add(chart, items) {
	        if (!items || !items.length) {
	            return;
	        }
	        this._getAnims(chart).items.push(...items);
	    }
	 has(chart) {
	        return this._getAnims(chart).items.length > 0;
	    }
	 start(chart) {
	        const anims = this._charts.get(chart);
	        if (!anims) {
	            return;
	        }
	        anims.running = true;
	        anims.start = Date.now();
	        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);
	        this._refresh();
	    }
	    running(chart) {
	        if (!this._running) {
	            return false;
	        }
	        const anims = this._charts.get(chart);
	        if (!anims || !anims.running || !anims.items.length) {
	            return false;
	        }
	        return true;
	    }
	 stop(chart) {
	        const anims = this._charts.get(chart);
	        if (!anims || !anims.items.length) {
	            return;
	        }
	        const items = anims.items;
	        let i = items.length - 1;
	        for(; i >= 0; --i){
	            items[i].cancel();
	        }
	        anims.items = [];
	        this._notify(chart, anims, Date.now(), 'complete');
	    }
	 remove(chart) {
	        return this._charts.delete(chart);
	    }
	}
	var animator = /* #__PURE__ */ new Animator();

	const transparent = 'transparent';
	const interpolators = {
	    boolean (from, to, factor) {
	        return factor > 0.5 ? to : from;
	    },
	 color (from, to, factor) {
	        const c0 = color(from || transparent);
	        const c1 = c0.valid && color(to || transparent);
	        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
	    },
	    number (from, to, factor) {
	        return from + (to - from) * factor;
	    }
	};
	class Animation {
	    constructor(cfg, target, prop, to){
	        const currentValue = target[prop];
	        to = resolve([
	            cfg.to,
	            to,
	            currentValue,
	            cfg.from
	        ]);
	        const from = resolve([
	            cfg.from,
	            currentValue,
	            to
	        ]);
	        this._active = true;
	        this._fn = cfg.fn || interpolators[cfg.type || typeof from];
	        this._easing = effects[cfg.easing] || effects.linear;
	        this._start = Math.floor(Date.now() + (cfg.delay || 0));
	        this._duration = this._total = Math.floor(cfg.duration);
	        this._loop = !!cfg.loop;
	        this._target = target;
	        this._prop = prop;
	        this._from = from;
	        this._to = to;
	        this._promises = undefined;
	    }
	    active() {
	        return this._active;
	    }
	    update(cfg, to, date) {
	        if (this._active) {
	            this._notify(false);
	            const currentValue = this._target[this._prop];
	            const elapsed = date - this._start;
	            const remain = this._duration - elapsed;
	            this._start = date;
	            this._duration = Math.floor(Math.max(remain, cfg.duration));
	            this._total += elapsed;
	            this._loop = !!cfg.loop;
	            this._to = resolve([
	                cfg.to,
	                to,
	                currentValue,
	                cfg.from
	            ]);
	            this._from = resolve([
	                cfg.from,
	                currentValue,
	                to
	            ]);
	        }
	    }
	    cancel() {
	        if (this._active) {
	            this.tick(Date.now());
	            this._active = false;
	            this._notify(false);
	        }
	    }
	    tick(date) {
	        const elapsed = date - this._start;
	        const duration = this._duration;
	        const prop = this._prop;
	        const from = this._from;
	        const loop = this._loop;
	        const to = this._to;
	        let factor;
	        this._active = from !== to && (loop || elapsed < duration);
	        if (!this._active) {
	            this._target[prop] = to;
	            this._notify(true);
	            return;
	        }
	        if (elapsed < 0) {
	            this._target[prop] = from;
	            return;
	        }
	        factor = elapsed / duration % 2;
	        factor = loop && factor > 1 ? 2 - factor : factor;
	        factor = this._easing(Math.min(1, Math.max(0, factor)));
	        this._target[prop] = this._fn(from, to, factor);
	    }
	    wait() {
	        const promises = this._promises || (this._promises = []);
	        return new Promise((res, rej)=>{
	            promises.push({
	                res,
	                rej
	            });
	        });
	    }
	    _notify(resolved) {
	        const method = resolved ? 'res' : 'rej';
	        const promises = this._promises || [];
	        for(let i = 0; i < promises.length; i++){
	            promises[i][method]();
	        }
	    }
	}

	class Animations {
	    constructor(chart, config){
	        this._chart = chart;
	        this._properties = new Map();
	        this.configure(config);
	    }
	    configure(config) {
	        if (!isObject$1(config)) {
	            return;
	        }
	        const animationOptions = Object.keys(defaults.animation);
	        const animatedProps = this._properties;
	        Object.getOwnPropertyNames(config).forEach((key)=>{
	            const cfg = config[key];
	            if (!isObject$1(cfg)) {
	                return;
	            }
	            const resolved = {};
	            for (const option of animationOptions){
	                resolved[option] = cfg[option];
	            }
	            (isArray$1(cfg.properties) && cfg.properties || [
	                key
	            ]).forEach((prop)=>{
	                if (prop === key || !animatedProps.has(prop)) {
	                    animatedProps.set(prop, resolved);
	                }
	            });
	        });
	    }
	 _animateOptions(target, values) {
	        const newOptions = values.options;
	        const options = resolveTargetOptions(target, newOptions);
	        if (!options) {
	            return [];
	        }
	        const animations = this._createAnimations(options, newOptions);
	        if (newOptions.$shared) {
	            awaitAll(target.options.$animations, newOptions).then(()=>{
	                target.options = newOptions;
	            }, ()=>{
	            });
	        }
	        return animations;
	    }
	 _createAnimations(target, values) {
	        const animatedProps = this._properties;
	        const animations = [];
	        const running = target.$animations || (target.$animations = {});
	        const props = Object.keys(values);
	        const date = Date.now();
	        let i;
	        for(i = props.length - 1; i >= 0; --i){
	            const prop = props[i];
	            if (prop.charAt(0) === '$') {
	                continue;
	            }
	            if (prop === 'options') {
	                animations.push(...this._animateOptions(target, values));
	                continue;
	            }
	            const value = values[prop];
	            let animation = running[prop];
	            const cfg = animatedProps.get(prop);
	            if (animation) {
	                if (cfg && animation.active()) {
	                    animation.update(cfg, value, date);
	                    continue;
	                } else {
	                    animation.cancel();
	                }
	            }
	            if (!cfg || !cfg.duration) {
	                target[prop] = value;
	                continue;
	            }
	            running[prop] = animation = new Animation(cfg, target, prop, value);
	            animations.push(animation);
	        }
	        return animations;
	    }
	 update(target, values) {
	        if (this._properties.size === 0) {
	            Object.assign(target, values);
	            return;
	        }
	        const animations = this._createAnimations(target, values);
	        if (animations.length) {
	            animator.add(this._chart, animations);
	            return true;
	        }
	    }
	}
	function awaitAll(animations, properties) {
	    const running = [];
	    const keys = Object.keys(properties);
	    for(let i = 0; i < keys.length; i++){
	        const anim = animations[keys[i]];
	        if (anim && anim.active()) {
	            running.push(anim.wait());
	        }
	    }
	    return Promise.all(running);
	}
	function resolveTargetOptions(target, newOptions) {
	    if (!newOptions) {
	        return;
	    }
	    let options = target.options;
	    if (!options) {
	        target.options = newOptions;
	        return;
	    }
	    if (options.$shared) {
	        target.options = options = Object.assign({}, options, {
	            $shared: false,
	            $animations: {}
	        });
	    }
	    return options;
	}

	function scaleClip(scale, allowedOverflow) {
	    const opts = scale && scale.options || {};
	    const reverse = opts.reverse;
	    const min = opts.min === undefined ? allowedOverflow : 0;
	    const max = opts.max === undefined ? allowedOverflow : 0;
	    return {
	        start: reverse ? max : min,
	        end: reverse ? min : max
	    };
	}
	function defaultClip(xScale, yScale, allowedOverflow) {
	    if (allowedOverflow === false) {
	        return false;
	    }
	    const x = scaleClip(xScale, allowedOverflow);
	    const y = scaleClip(yScale, allowedOverflow);
	    return {
	        top: y.end,
	        right: x.end,
	        bottom: y.start,
	        left: x.start
	    };
	}
	function toClip(value) {
	    let t, r, b, l;
	    if (isObject$1(value)) {
	        t = value.top;
	        r = value.right;
	        b = value.bottom;
	        l = value.left;
	    } else {
	        t = r = b = l = value;
	    }
	    return {
	        top: t,
	        right: r,
	        bottom: b,
	        left: l,
	        disabled: value === false
	    };
	}
	function getSortedDatasetIndices(chart, filterVisible) {
	    const keys = [];
	    const metasets = chart._getSortedDatasetMetas(filterVisible);
	    let i, ilen;
	    for(i = 0, ilen = metasets.length; i < ilen; ++i){
	        keys.push(metasets[i].index);
	    }
	    return keys;
	}
	function applyStack(stack, value, dsIndex, options = {}) {
	    const keys = stack.keys;
	    const singleMode = options.mode === 'single';
	    let i, ilen, datasetIndex, otherValue;
	    if (value === null) {
	        return;
	    }
	    for(i = 0, ilen = keys.length; i < ilen; ++i){
	        datasetIndex = +keys[i];
	        if (datasetIndex === dsIndex) {
	            if (options.all) {
	                continue;
	            }
	            break;
	        }
	        otherValue = stack.values[datasetIndex];
	        if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
	            value += otherValue;
	        }
	    }
	    return value;
	}
	function convertObjectDataToArray(data, meta) {
	    const { iScale , vScale  } = meta;
	    const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';
	    const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';
	    const keys = Object.keys(data);
	    const adata = new Array(keys.length);
	    let i, ilen, key;
	    for(i = 0, ilen = keys.length; i < ilen; ++i){
	        key = keys[i];
	        adata[i] = {
	            [iAxisKey]: key,
	            [vAxisKey]: data[key]
	        };
	    }
	    return adata;
	}
	function isStacked(scale, meta) {
	    const stacked = scale && scale.options.stacked;
	    return stacked || stacked === undefined && meta.stack !== undefined;
	}
	function getStackKey(indexScale, valueScale, meta) {
	    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
	}
	function getUserBounds(scale) {
	    const { min , max , minDefined , maxDefined  } = scale.getUserBounds();
	    return {
	        min: minDefined ? min : Number.NEGATIVE_INFINITY,
	        max: maxDefined ? max : Number.POSITIVE_INFINITY
	    };
	}
	function getOrCreateStack(stacks, stackKey, indexValue) {
	    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
	    return subStack[indexValue] || (subStack[indexValue] = {});
	}
	function getLastIndexInStack(stack, vScale, positive, type) {
	    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){
	        const value = stack[meta.index];
	        if (positive && value > 0 || !positive && value < 0) {
	            return meta.index;
	        }
	    }
	    return null;
	}
	function updateStacks(controller, parsed) {
	    const { chart , _cachedMeta: meta  } = controller;
	    const stacks = chart._stacks || (chart._stacks = {});
	    const { iScale , vScale , index: datasetIndex  } = meta;
	    const iAxis = iScale.axis;
	    const vAxis = vScale.axis;
	    const key = getStackKey(iScale, vScale, meta);
	    const ilen = parsed.length;
	    let stack;
	    for(let i = 0; i < ilen; ++i){
	        const item = parsed[i];
	        const { [iAxis]: index , [vAxis]: value  } = item;
	        const itemStacks = item._stacks || (item._stacks = {});
	        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
	        stack[datasetIndex] = value;
	        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
	        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
	        const visualValues = stack._visualValues || (stack._visualValues = {});
	        visualValues[datasetIndex] = value;
	    }
	}
	function getFirstScaleId(chart, axis) {
	    const scales = chart.scales;
	    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();
	}
	function createDatasetContext(parent, index) {
	    return createContext(parent, {
	        active: false,
	        dataset: undefined,
	        datasetIndex: index,
	        index,
	        mode: 'default',
	        type: 'dataset'
	    });
	}
	function createDataContext(parent, index, element) {
	    return createContext(parent, {
	        active: false,
	        dataIndex: index,
	        parsed: undefined,
	        raw: undefined,
	        element,
	        index,
	        mode: 'default',
	        type: 'data'
	    });
	}
	function clearStacks(meta, items) {
	    const datasetIndex = meta.controller.index;
	    const axis = meta.vScale && meta.vScale.axis;
	    if (!axis) {
	        return;
	    }
	    items = items || meta._parsed;
	    for (const parsed of items){
	        const stacks = parsed._stacks;
	        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
	            return;
	        }
	        delete stacks[axis][datasetIndex];
	        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {
	            delete stacks[axis]._visualValues[datasetIndex];
	        }
	    }
	}
	const isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';
	const cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);
	const createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {
	        keys: getSortedDatasetIndices(chart, true),
	        values: null
	    };
	class DatasetController {
	 static defaults = {};
	 static datasetElementType = null;
	 static dataElementType = null;
	 constructor(chart, datasetIndex){
	        this.chart = chart;
	        this._ctx = chart.ctx;
	        this.index = datasetIndex;
	        this._cachedDataOpts = {};
	        this._cachedMeta = this.getMeta();
	        this._type = this._cachedMeta.type;
	        this.options = undefined;
	         this._parsing = false;
	        this._data = undefined;
	        this._objectData = undefined;
	        this._sharedOptions = undefined;
	        this._drawStart = undefined;
	        this._drawCount = undefined;
	        this.enableOptionSharing = false;
	        this.supportsDecimation = false;
	        this.$context = undefined;
	        this._syncList = [];
	        this.datasetElementType = new.target.datasetElementType;
	        this.dataElementType = new.target.dataElementType;
	        this.initialize();
	    }
	    initialize() {
	        const meta = this._cachedMeta;
	        this.configure();
	        this.linkScales();
	        meta._stacked = isStacked(meta.vScale, meta);
	        this.addElements();
	        if (this.options.fill && !this.chart.isPluginEnabled('filler')) {
	            console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
	        }
	    }
	    updateIndex(datasetIndex) {
	        if (this.index !== datasetIndex) {
	            clearStacks(this._cachedMeta);
	        }
	        this.index = datasetIndex;
	    }
	    linkScales() {
	        const chart = this.chart;
	        const meta = this._cachedMeta;
	        const dataset = this.getDataset();
	        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;
	        const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));
	        const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));
	        const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));
	        const indexAxis = meta.indexAxis;
	        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
	        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
	        meta.xScale = this.getScaleForId(xid);
	        meta.yScale = this.getScaleForId(yid);
	        meta.rScale = this.getScaleForId(rid);
	        meta.iScale = this.getScaleForId(iid);
	        meta.vScale = this.getScaleForId(vid);
	    }
	    getDataset() {
	        return this.chart.data.datasets[this.index];
	    }
	    getMeta() {
	        return this.chart.getDatasetMeta(this.index);
	    }
	 getScaleForId(scaleID) {
	        return this.chart.scales[scaleID];
	    }
	 _getOtherScale(scale) {
	        const meta = this._cachedMeta;
	        return scale === meta.iScale ? meta.vScale : meta.iScale;
	    }
	    reset() {
	        this._update('reset');
	    }
	 _destroy() {
	        const meta = this._cachedMeta;
	        if (this._data) {
	            unlistenArrayEvents(this._data, this);
	        }
	        if (meta._stacked) {
	            clearStacks(meta);
	        }
	    }
	 _dataCheck() {
	        const dataset = this.getDataset();
	        const data = dataset.data || (dataset.data = []);
	        const _data = this._data;
	        if (isObject$1(data)) {
	            const meta = this._cachedMeta;
	            this._data = convertObjectDataToArray(data, meta);
	        } else if (_data !== data) {
	            if (_data) {
	                unlistenArrayEvents(_data, this);
	                const meta = this._cachedMeta;
	                clearStacks(meta);
	                meta._parsed = [];
	            }
	            if (data && Object.isExtensible(data)) {
	                listenArrayEvents(data, this);
	            }
	            this._syncList = [];
	            this._data = data;
	        }
	    }
	    addElements() {
	        const meta = this._cachedMeta;
	        this._dataCheck();
	        if (this.datasetElementType) {
	            meta.dataset = new this.datasetElementType();
	        }
	    }
	    buildOrUpdateElements(resetNewElements) {
	        const meta = this._cachedMeta;
	        const dataset = this.getDataset();
	        let stackChanged = false;
	        this._dataCheck();
	        const oldStacked = meta._stacked;
	        meta._stacked = isStacked(meta.vScale, meta);
	        if (meta.stack !== dataset.stack) {
	            stackChanged = true;
	            clearStacks(meta);
	            meta.stack = dataset.stack;
	        }
	        this._resyncElements(resetNewElements);
	        if (stackChanged || oldStacked !== meta._stacked) {
	            updateStacks(this, meta._parsed);
	        }
	    }
	 configure() {
	        const config = this.chart.config;
	        const scopeKeys = config.datasetScopeKeys(this._type);
	        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
	        this.options = config.createResolver(scopes, this.getContext());
	        this._parsing = this.options.parsing;
	        this._cachedDataOpts = {};
	    }
	 parse(start, count) {
	        const { _cachedMeta: meta , _data: data  } = this;
	        const { iScale , _stacked  } = meta;
	        const iAxis = iScale.axis;
	        let sorted = start === 0 && count === data.length ? true : meta._sorted;
	        let prev = start > 0 && meta._parsed[start - 1];
	        let i, cur, parsed;
	        if (this._parsing === false) {
	            meta._parsed = data;
	            meta._sorted = true;
	            parsed = data;
	        } else {
	            if (isArray$1(data[start])) {
	                parsed = this.parseArrayData(meta, data, start, count);
	            } else if (isObject$1(data[start])) {
	                parsed = this.parseObjectData(meta, data, start, count);
	            } else {
	                parsed = this.parsePrimitiveData(meta, data, start, count);
	            }
	            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
	            for(i = 0; i < count; ++i){
	                meta._parsed[i + start] = cur = parsed[i];
	                if (sorted) {
	                    if (isNotInOrderComparedToPrev()) {
	                        sorted = false;
	                    }
	                    prev = cur;
	                }
	            }
	            meta._sorted = sorted;
	        }
	        if (_stacked) {
	            updateStacks(this, parsed);
	        }
	    }
	 parsePrimitiveData(meta, data, start, count) {
	        const { iScale , vScale  } = meta;
	        const iAxis = iScale.axis;
	        const vAxis = vScale.axis;
	        const labels = iScale.getLabels();
	        const singleScale = iScale === vScale;
	        const parsed = new Array(count);
	        let i, ilen, index;
	        for(i = 0, ilen = count; i < ilen; ++i){
	            index = i + start;
	            parsed[i] = {
	                [iAxis]: singleScale || iScale.parse(labels[index], index),
	                [vAxis]: vScale.parse(data[index], index)
	            };
	        }
	        return parsed;
	    }
	 parseArrayData(meta, data, start, count) {
	        const { xScale , yScale  } = meta;
	        const parsed = new Array(count);
	        let i, ilen, index, item;
	        for(i = 0, ilen = count; i < ilen; ++i){
	            index = i + start;
	            item = data[index];
	            parsed[i] = {
	                x: xScale.parse(item[0], index),
	                y: yScale.parse(item[1], index)
	            };
	        }
	        return parsed;
	    }
	 parseObjectData(meta, data, start, count) {
	        const { xScale , yScale  } = meta;
	        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
	        const parsed = new Array(count);
	        let i, ilen, index, item;
	        for(i = 0, ilen = count; i < ilen; ++i){
	            index = i + start;
	            item = data[index];
	            parsed[i] = {
	                x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
	                y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
	            };
	        }
	        return parsed;
	    }
	 getParsed(index) {
	        return this._cachedMeta._parsed[index];
	    }
	 getDataElement(index) {
	        return this._cachedMeta.data[index];
	    }
	 applyStack(scale, parsed, mode) {
	        const chart = this.chart;
	        const meta = this._cachedMeta;
	        const value = parsed[scale.axis];
	        const stack = {
	            keys: getSortedDatasetIndices(chart, true),
	            values: parsed._stacks[scale.axis]._visualValues
	        };
	        return applyStack(stack, value, meta.index, {
	            mode
	        });
	    }
	 updateRangeFromParsed(range, scale, parsed, stack) {
	        const parsedValue = parsed[scale.axis];
	        let value = parsedValue === null ? NaN : parsedValue;
	        const values = stack && parsed._stacks[scale.axis];
	        if (stack && values) {
	            stack.values = values;
	            value = applyStack(stack, parsedValue, this._cachedMeta.index);
	        }
	        range.min = Math.min(range.min, value);
	        range.max = Math.max(range.max, value);
	    }
	 getMinMax(scale, canStack) {
	        const meta = this._cachedMeta;
	        const _parsed = meta._parsed;
	        const sorted = meta._sorted && scale === meta.iScale;
	        const ilen = _parsed.length;
	        const otherScale = this._getOtherScale(scale);
	        const stack = createStack(canStack, meta, this.chart);
	        const range = {
	            min: Number.POSITIVE_INFINITY,
	            max: Number.NEGATIVE_INFINITY
	        };
	        const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);
	        let i, parsed;
	        function _skip() {
	            parsed = _parsed[i];
	            const otherValue = parsed[otherScale.axis];
	            return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
	        }
	        for(i = 0; i < ilen; ++i){
	            if (_skip()) {
	                continue;
	            }
	            this.updateRangeFromParsed(range, scale, parsed, stack);
	            if (sorted) {
	                break;
	            }
	        }
	        if (sorted) {
	            for(i = ilen - 1; i >= 0; --i){
	                if (_skip()) {
	                    continue;
	                }
	                this.updateRangeFromParsed(range, scale, parsed, stack);
	                break;
	            }
	        }
	        return range;
	    }
	    getAllParsedValues(scale) {
	        const parsed = this._cachedMeta._parsed;
	        const values = [];
	        let i, ilen, value;
	        for(i = 0, ilen = parsed.length; i < ilen; ++i){
	            value = parsed[i][scale.axis];
	            if (isNumberFinite(value)) {
	                values.push(value);
	            }
	        }
	        return values;
	    }
	 getMaxOverflow() {
	        return false;
	    }
	 getLabelAndValue(index) {
	        const meta = this._cachedMeta;
	        const iScale = meta.iScale;
	        const vScale = meta.vScale;
	        const parsed = this.getParsed(index);
	        return {
	            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
	            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
	        };
	    }
	 _update(mode) {
	        const meta = this._cachedMeta;
	        this.update(mode || 'default');
	        meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
	    }
	 update(mode) {}
	    draw() {
	        const ctx = this._ctx;
	        const chart = this.chart;
	        const meta = this._cachedMeta;
	        const elements = meta.data || [];
	        const area = chart.chartArea;
	        const active = [];
	        const start = this._drawStart || 0;
	        const count = this._drawCount || elements.length - start;
	        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
	        let i;
	        if (meta.dataset) {
	            meta.dataset.draw(ctx, area, start, count);
	        }
	        for(i = start; i < start + count; ++i){
	            const element = elements[i];
	            if (element.hidden) {
	                continue;
	            }
	            if (element.active && drawActiveElementsOnTop) {
	                active.push(element);
	            } else {
	                element.draw(ctx, area);
	            }
	        }
	        for(i = 0; i < active.length; ++i){
	            active[i].draw(ctx, area);
	        }
	    }
	 getStyle(index, active) {
	        const mode = active ? 'active' : 'default';
	        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
	    }
	 getContext(index, active, mode) {
	        const dataset = this.getDataset();
	        let context;
	        if (index >= 0 && index < this._cachedMeta.data.length) {
	            const element = this._cachedMeta.data[index];
	            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
	            context.parsed = this.getParsed(index);
	            context.raw = dataset.data[index];
	            context.index = context.dataIndex = index;
	        } else {
	            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
	            context.dataset = dataset;
	            context.index = context.datasetIndex = this.index;
	        }
	        context.active = !!active;
	        context.mode = mode;
	        return context;
	    }
	 resolveDatasetElementOptions(mode) {
	        return this._resolveElementOptions(this.datasetElementType.id, mode);
	    }
	 resolveDataElementOptions(index, mode) {
	        return this._resolveElementOptions(this.dataElementType.id, mode, index);
	    }
	 _resolveElementOptions(elementType, mode = 'default', index) {
	        const active = mode === 'active';
	        const cache = this._cachedDataOpts;
	        const cacheKey = elementType + '-' + mode;
	        const cached = cache[cacheKey];
	        const sharing = this.enableOptionSharing && defined(index);
	        if (cached) {
	            return cloneIfNotShared(cached, sharing);
	        }
	        const config = this.chart.config;
	        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
	        const prefixes = active ? [
	            `${elementType}Hover`,
	            'hover',
	            elementType,
	            ''
	        ] : [
	            elementType,
	            ''
	        ];
	        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
	        const names = Object.keys(defaults.elements[elementType]);
	        const context = ()=>this.getContext(index, active, mode);
	        const values = config.resolveNamedOptions(scopes, names, context, prefixes);
	        if (values.$shared) {
	            values.$shared = sharing;
	            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
	        }
	        return values;
	    }
	 _resolveAnimations(index, transition, active) {
	        const chart = this.chart;
	        const cache = this._cachedDataOpts;
	        const cacheKey = `animation-${transition}`;
	        const cached = cache[cacheKey];
	        if (cached) {
	            return cached;
	        }
	        let options;
	        if (chart.options.animation !== false) {
	            const config = this.chart.config;
	            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
	            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
	            options = config.createResolver(scopes, this.getContext(index, active, transition));
	        }
	        const animations = new Animations(chart, options && options.animations);
	        if (options && options._cacheable) {
	            cache[cacheKey] = Object.freeze(animations);
	        }
	        return animations;
	    }
	 getSharedOptions(options) {
	        if (!options.$shared) {
	            return;
	        }
	        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
	    }
	 includeOptions(mode, sharedOptions) {
	        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
	    }
	 _getSharedOptions(start, mode) {
	        const firstOpts = this.resolveDataElementOptions(start, mode);
	        const previouslySharedOptions = this._sharedOptions;
	        const sharedOptions = this.getSharedOptions(firstOpts);
	        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
	        this.updateSharedOptions(sharedOptions, mode, firstOpts);
	        return {
	            sharedOptions,
	            includeOptions
	        };
	    }
	 updateElement(element, index, properties, mode) {
	        if (isDirectUpdateMode(mode)) {
	            Object.assign(element, properties);
	        } else {
	            this._resolveAnimations(index, mode).update(element, properties);
	        }
	    }
	 updateSharedOptions(sharedOptions, mode, newOptions) {
	        if (sharedOptions && !isDirectUpdateMode(mode)) {
	            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
	        }
	    }
	 _setStyle(element, index, mode, active) {
	        element.active = active;
	        const options = this.getStyle(index, active);
	        this._resolveAnimations(index, mode, active).update(element, {
	            options: !active && this.getSharedOptions(options) || options
	        });
	    }
	    removeHoverStyle(element, datasetIndex, index) {
	        this._setStyle(element, index, 'active', false);
	    }
	    setHoverStyle(element, datasetIndex, index) {
	        this._setStyle(element, index, 'active', true);
	    }
	 _removeDatasetHoverStyle() {
	        const element = this._cachedMeta.dataset;
	        if (element) {
	            this._setStyle(element, undefined, 'active', false);
	        }
	    }
	 _setDatasetHoverStyle() {
	        const element = this._cachedMeta.dataset;
	        if (element) {
	            this._setStyle(element, undefined, 'active', true);
	        }
	    }
	 _resyncElements(resetNewElements) {
	        const data = this._data;
	        const elements = this._cachedMeta.data;
	        for (const [method, arg1, arg2] of this._syncList){
	            this[method](arg1, arg2);
	        }
	        this._syncList = [];
	        const numMeta = elements.length;
	        const numData = data.length;
	        const count = Math.min(numData, numMeta);
	        if (count) {
	            this.parse(0, count);
	        }
	        if (numData > numMeta) {
	            this._insertElements(numMeta, numData - numMeta, resetNewElements);
	        } else if (numData < numMeta) {
	            this._removeElements(numData, numMeta - numData);
	        }
	    }
	 _insertElements(start, count, resetNewElements = true) {
	        const meta = this._cachedMeta;
	        const data = meta.data;
	        const end = start + count;
	        let i;
	        const move = (arr)=>{
	            arr.length += count;
	            for(i = arr.length - 1; i >= end; i--){
	                arr[i] = arr[i - count];
	            }
	        };
	        move(data);
	        for(i = start; i < end; ++i){
	            data[i] = new this.dataElementType();
	        }
	        if (this._parsing) {
	            move(meta._parsed);
	        }
	        this.parse(start, count);
	        if (resetNewElements) {
	            this.updateElements(data, start, count, 'reset');
	        }
	    }
	    updateElements(element, start, count, mode) {}
	 _removeElements(start, count) {
	        const meta = this._cachedMeta;
	        if (this._parsing) {
	            const removed = meta._parsed.splice(start, count);
	            if (meta._stacked) {
	                clearStacks(meta, removed);
	            }
	        }
	        meta.data.splice(start, count);
	    }
	 _sync(args) {
	        if (this._parsing) {
	            this._syncList.push(args);
	        } else {
	            const [method, arg1, arg2] = args;
	            this[method](arg1, arg2);
	        }
	        this.chart._dataChanges.push([
	            this.index,
	            ...args
	        ]);
	    }
	    _onDataPush() {
	        const count = arguments.length;
	        this._sync([
	            '_insertElements',
	            this.getDataset().data.length - count,
	            count
	        ]);
	    }
	    _onDataPop() {
	        this._sync([
	            '_removeElements',
	            this._cachedMeta.data.length - 1,
	            1
	        ]);
	    }
	    _onDataShift() {
	        this._sync([
	            '_removeElements',
	            0,
	            1
	        ]);
	    }
	    _onDataSplice(start, count) {
	        if (count) {
	            this._sync([
	                '_removeElements',
	                start,
	                count
	            ]);
	        }
	        const newCount = arguments.length - 2;
	        if (newCount) {
	            this._sync([
	                '_insertElements',
	                start,
	                newCount
	            ]);
	        }
	    }
	    _onDataUnshift() {
	        this._sync([
	            '_insertElements',
	            0,
	            arguments.length
	        ]);
	    }
	}

	function getAllScaleValues(scale, type) {
	    if (!scale._cache.$bar) {
	        const visibleMetas = scale.getMatchingVisibleMetas(type);
	        let values = [];
	        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){
	            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
	        }
	        scale._cache.$bar = _arrayUnique(values.sort((a, b)=>a - b));
	    }
	    return scale._cache.$bar;
	}
	 function computeMinSampleSize(meta) {
	    const scale = meta.iScale;
	    const values = getAllScaleValues(scale, meta.type);
	    let min = scale._length;
	    let i, ilen, curr, prev;
	    const updateMinAndPrev = ()=>{
	        if (curr === 32767 || curr === -32768) {
	            return;
	        }
	        if (defined(prev)) {
	            min = Math.min(min, Math.abs(curr - prev) || min);
	        }
	        prev = curr;
	    };
	    for(i = 0, ilen = values.length; i < ilen; ++i){
	        curr = scale.getPixelForValue(values[i]);
	        updateMinAndPrev();
	    }
	    prev = undefined;
	    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){
	        curr = scale.getPixelForTick(i);
	        updateMinAndPrev();
	    }
	    return min;
	}
	 function computeFitCategoryTraits(index, ruler, options, stackCount) {
	    const thickness = options.barThickness;
	    let size, ratio;
	    if (isNullOrUndef(thickness)) {
	        size = ruler.min * options.categoryPercentage;
	        ratio = options.barPercentage;
	    } else {
	        size = thickness * stackCount;
	        ratio = 1;
	    }
	    return {
	        chunk: size / stackCount,
	        ratio,
	        start: ruler.pixels[index] - size / 2
	    };
	}
	 function computeFlexCategoryTraits(index, ruler, options, stackCount) {
	    const pixels = ruler.pixels;
	    const curr = pixels[index];
	    let prev = index > 0 ? pixels[index - 1] : null;
	    let next = index < pixels.length - 1 ? pixels[index + 1] : null;
	    const percent = options.categoryPercentage;
	    if (prev === null) {
	        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
	    }
	    if (next === null) {
	        next = curr + curr - prev;
	    }
	    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
	    const size = Math.abs(next - prev) / 2 * percent;
	    return {
	        chunk: size / stackCount,
	        ratio: options.barPercentage,
	        start
	    };
	}
	function parseFloatBar(entry, item, vScale, i) {
	    const startValue = vScale.parse(entry[0], i);
	    const endValue = vScale.parse(entry[1], i);
	    const min = Math.min(startValue, endValue);
	    const max = Math.max(startValue, endValue);
	    let barStart = min;
	    let barEnd = max;
	    if (Math.abs(min) > Math.abs(max)) {
	        barStart = max;
	        barEnd = min;
	    }
	    item[vScale.axis] = barEnd;
	    item._custom = {
	        barStart,
	        barEnd,
	        start: startValue,
	        end: endValue,
	        min,
	        max
	    };
	}
	function parseValue(entry, item, vScale, i) {
	    if (isArray$1(entry)) {
	        parseFloatBar(entry, item, vScale, i);
	    } else {
	        item[vScale.axis] = vScale.parse(entry, i);
	    }
	    return item;
	}
	function parseArrayOrPrimitive(meta, data, start, count) {
	    const iScale = meta.iScale;
	    const vScale = meta.vScale;
	    const labels = iScale.getLabels();
	    const singleScale = iScale === vScale;
	    const parsed = [];
	    let i, ilen, item, entry;
	    for(i = start, ilen = start + count; i < ilen; ++i){
	        entry = data[i];
	        item = {};
	        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
	        parsed.push(parseValue(entry, item, vScale, i));
	    }
	    return parsed;
	}
	function isFloatBar(custom) {
	    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
	}
	function barSign(size, vScale, actualBase) {
	    if (size !== 0) {
	        return sign(size);
	    }
	    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
	}
	function borderProps(properties) {
	    let reverse, start, end, top, bottom;
	    if (properties.horizontal) {
	        reverse = properties.base > properties.x;
	        start = 'left';
	        end = 'right';
	    } else {
	        reverse = properties.base < properties.y;
	        start = 'bottom';
	        end = 'top';
	    }
	    if (reverse) {
	        top = 'end';
	        bottom = 'start';
	    } else {
	        top = 'start';
	        bottom = 'end';
	    }
	    return {
	        start,
	        end,
	        reverse,
	        top,
	        bottom
	    };
	}
	function setBorderSkipped(properties, options, stack, index) {
	    let edge = options.borderSkipped;
	    const res = {};
	    if (!edge) {
	        properties.borderSkipped = res;
	        return;
	    }
	    if (edge === true) {
	        properties.borderSkipped = {
	            top: true,
	            right: true,
	            bottom: true,
	            left: true
	        };
	        return;
	    }
	    const { start , end , reverse , top , bottom  } = borderProps(properties);
	    if (edge === 'middle' && stack) {
	        properties.enableBorderRadius = true;
	        if ((stack._top || 0) === index) {
	            edge = top;
	        } else if ((stack._bottom || 0) === index) {
	            edge = bottom;
	        } else {
	            res[parseEdge(bottom, start, end, reverse)] = true;
	            edge = top;
	        }
	    }
	    res[parseEdge(edge, start, end, reverse)] = true;
	    properties.borderSkipped = res;
	}
	function parseEdge(edge, a, b, reverse) {
	    if (reverse) {
	        edge = swap(edge, a, b);
	        edge = startEnd(edge, b, a);
	    } else {
	        edge = startEnd(edge, a, b);
	    }
	    return edge;
	}
	function swap(orig, v1, v2) {
	    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
	}
	function startEnd(v, start, end) {
	    return v === 'start' ? start : v === 'end' ? end : v;
	}
	function setInflateAmount(properties, { inflateAmount  }, ratio) {
	    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;
	}
	class BarController extends DatasetController {
	    static id = 'bar';
	 static defaults = {
	        datasetElementType: false,
	        dataElementType: 'bar',
	        categoryPercentage: 0.8,
	        barPercentage: 0.9,
	        grouped: true,
	        animations: {
	            numbers: {
	                type: 'number',
	                properties: [
	                    'x',
	                    'y',
	                    'base',
	                    'width',
	                    'height'
	                ]
	            }
	        }
	    };
	 static overrides = {
	        scales: {
	            _index_: {
	                type: 'category',
	                offset: true,
	                grid: {
	                    offset: true
	                }
	            },
	            _value_: {
	                type: 'linear',
	                beginAtZero: true
	            }
	        }
	    };
	 parsePrimitiveData(meta, data, start, count) {
	        return parseArrayOrPrimitive(meta, data, start, count);
	    }
	 parseArrayData(meta, data, start, count) {
	        return parseArrayOrPrimitive(meta, data, start, count);
	    }
	 parseObjectData(meta, data, start, count) {
	        const { iScale , vScale  } = meta;
	        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
	        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
	        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
	        const parsed = [];
	        let i, ilen, item, obj;
	        for(i = start, ilen = start + count; i < ilen; ++i){
	            obj = data[i];
	            item = {};
	            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
	            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
	        }
	        return parsed;
	    }
	 updateRangeFromParsed(range, scale, parsed, stack) {
	        super.updateRangeFromParsed(range, scale, parsed, stack);
	        const custom = parsed._custom;
	        if (custom && scale === this._cachedMeta.vScale) {
	            range.min = Math.min(range.min, custom.min);
	            range.max = Math.max(range.max, custom.max);
	        }
	    }
	 getMaxOverflow() {
	        return 0;
	    }
	 getLabelAndValue(index) {
	        const meta = this._cachedMeta;
	        const { iScale , vScale  } = meta;
	        const parsed = this.getParsed(index);
	        const custom = parsed._custom;
	        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);
	        return {
	            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
	            value
	        };
	    }
	    initialize() {
	        this.enableOptionSharing = true;
	        super.initialize();
	        const meta = this._cachedMeta;
	        meta.stack = this.getDataset().stack;
	    }
	    update(mode) {
	        const meta = this._cachedMeta;
	        this.updateElements(meta.data, 0, meta.data.length, mode);
	    }
	    updateElements(bars, start, count, mode) {
	        const reset = mode === 'reset';
	        const { index , _cachedMeta: { vScale  }  } = this;
	        const base = vScale.getBasePixel();
	        const horizontal = vScale.isHorizontal();
	        const ruler = this._getRuler();
	        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
	        for(let i = start; i < start + count; i++){
	            const parsed = this.getParsed(i);
	            const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
	                base,
	                head: base
	            } : this._calculateBarValuePixels(i);
	            const ipixels = this._calculateBarIndexPixels(i, ruler);
	            const stack = (parsed._stacks || {})[vScale.axis];
	            const properties = {
	                horizontal,
	                base: vpixels.base,
	                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
	                x: horizontal ? vpixels.head : ipixels.center,
	                y: horizontal ? ipixels.center : vpixels.head,
	                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
	                width: horizontal ? Math.abs(vpixels.size) : ipixels.size
	            };
	            if (includeOptions) {
	                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
	            }
	            const options = properties.options || bars[i].options;
	            setBorderSkipped(properties, options, stack, index);
	            setInflateAmount(properties, options, ruler.ratio);
	            this.updateElement(bars[i], i, properties, mode);
	        }
	    }
	 _getStacks(last, dataIndex) {
	        const { iScale  } = this._cachedMeta;
	        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);
	        const stacked = iScale.options.stacked;
	        const stacks = [];
	        const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
	        const iScaleValue = currentParsed && currentParsed[iScale.axis];
	        const skipNull = (meta)=>{
	            const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);
	            const val = parsed && parsed[meta.vScale.axis];
	            if (isNullOrUndef(val) || isNaN(val)) {
	                return true;
	            }
	        };
	        for (const meta of metasets){
	            if (dataIndex !== undefined && skipNull(meta)) {
	                continue;
	            }
	            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {
	                stacks.push(meta.stack);
	            }
	            if (meta.index === last) {
	                break;
	            }
	        }
	        if (!stacks.length) {
	            stacks.push(undefined);
	        }
	        return stacks;
	    }
	 _getStackCount(index) {
	        return this._getStacks(undefined, index).length;
	    }
	 _getStackIndex(datasetIndex, name, dataIndex) {
	        const stacks = this._getStacks(datasetIndex, dataIndex);
	        const index = name !== undefined ? stacks.indexOf(name) : -1;
	        return index === -1 ? stacks.length - 1 : index;
	    }
	 _getRuler() {
	        const opts = this.options;
	        const meta = this._cachedMeta;
	        const iScale = meta.iScale;
	        const pixels = [];
	        let i, ilen;
	        for(i = 0, ilen = meta.data.length; i < ilen; ++i){
	            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
	        }
	        const barThickness = opts.barThickness;
	        const min = barThickness || computeMinSampleSize(meta);
	        return {
	            min,
	            pixels,
	            start: iScale._startPixel,
	            end: iScale._endPixel,
	            stackCount: this._getStackCount(),
	            scale: iScale,
	            grouped: opts.grouped,
	            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
	        };
	    }
	 _calculateBarValuePixels(index) {
	        const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;
	        const actualBase = baseValue || 0;
	        const parsed = this.getParsed(index);
	        const custom = parsed._custom;
	        const floating = isFloatBar(custom);
	        let value = parsed[vScale.axis];
	        let start = 0;
	        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
	        let head, size;
	        if (length !== value) {
	            start = length - value;
	            length = value;
	        }
	        if (floating) {
	            value = custom.barStart;
	            length = custom.barEnd - custom.barStart;
	            if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
	                start = 0;
	            }
	            start += value;
	        }
	        const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
	        let base = vScale.getPixelForValue(startValue);
	        if (this.chart.getDataVisibility(index)) {
	            head = vScale.getPixelForValue(start + length);
	        } else {
	            head = base;
	        }
	        size = head - base;
	        if (Math.abs(size) < minBarLength) {
	            size = barSign(size, vScale, actualBase) * minBarLength;
	            if (value === actualBase) {
	                base -= size / 2;
	            }
	            const startPixel = vScale.getPixelForDecimal(0);
	            const endPixel = vScale.getPixelForDecimal(1);
	            const min = Math.min(startPixel, endPixel);
	            const max = Math.max(startPixel, endPixel);
	            base = Math.max(Math.min(base, max), min);
	            head = base + size;
	            if (_stacked && !floating) {
	                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
	            }
	        }
	        if (base === vScale.getPixelForValue(actualBase)) {
	            const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
	            base += halfGrid;
	            size -= halfGrid;
	        }
	        return {
	            size,
	            base,
	            head,
	            center: head + size / 2
	        };
	    }
	 _calculateBarIndexPixels(index, ruler) {
	        const scale = ruler.scale;
	        const options = this.options;
	        const skipNull = options.skipNull;
	        const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
	        let center, size;
	        if (ruler.grouped) {
	            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
	            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
	            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
	            center = range.start + range.chunk * stackIndex + range.chunk / 2;
	            size = Math.min(maxBarThickness, range.chunk * range.ratio);
	        } else {
	            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
	            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
	        }
	        return {
	            base: center - size / 2,
	            head: center + size / 2,
	            center,
	            size
	        };
	    }
	    draw() {
	        const meta = this._cachedMeta;
	        const vScale = meta.vScale;
	        const rects = meta.data;
	        const ilen = rects.length;
	        let i = 0;
	        for(; i < ilen; ++i){
	            if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
	                rects[i].draw(this._ctx);
	            }
	        }
	    }
	}

	function getRatioAndOffset(rotation, circumference, cutout) {
	    let ratioX = 1;
	    let ratioY = 1;
	    let offsetX = 0;
	    let offsetY = 0;
	    if (circumference < TAU) {
	        const startAngle = rotation;
	        const endAngle = startAngle + circumference;
	        const startX = Math.cos(startAngle);
	        const startY = Math.sin(startAngle);
	        const endX = Math.cos(endAngle);
	        const endY = Math.sin(endAngle);
	        const calcMax = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
	        const calcMin = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
	        const maxX = calcMax(0, startX, endX);
	        const maxY = calcMax(HALF_PI, startY, endY);
	        const minX = calcMin(PI, startX, endX);
	        const minY = calcMin(PI + HALF_PI, startY, endY);
	        ratioX = (maxX - minX) / 2;
	        ratioY = (maxY - minY) / 2;
	        offsetX = -(maxX + minX) / 2;
	        offsetY = -(maxY + minY) / 2;
	    }
	    return {
	        ratioX,
	        ratioY,
	        offsetX,
	        offsetY
	    };
	}
	class DoughnutController extends DatasetController {
	    static id = 'doughnut';
	 static defaults = {
	        datasetElementType: false,
	        dataElementType: 'arc',
	        animation: {
	            animateRotate: true,
	            animateScale: false
	        },
	        animations: {
	            numbers: {
	                type: 'number',
	                properties: [
	                    'circumference',
	                    'endAngle',
	                    'innerRadius',
	                    'outerRadius',
	                    'startAngle',
	                    'x',
	                    'y',
	                    'offset',
	                    'borderWidth',
	                    'spacing'
	                ]
	            }
	        },
	        cutout: '50%',
	        rotation: 0,
	        circumference: 360,
	        radius: '100%',
	        spacing: 0,
	        indexAxis: 'r'
	    };
	    static descriptors = {
	        _scriptable: (name)=>name !== 'spacing',
	        _indexable: (name)=>name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash')
	    };
	 static overrides = {
	        aspectRatio: 1,
	        plugins: {
	            legend: {
	                labels: {
	                    generateLabels (chart) {
	                        const data = chart.data;
	                        if (data.labels.length && data.datasets.length) {
	                            const { labels: { pointStyle , color  }  } = chart.legend.options;
	                            return data.labels.map((label, i)=>{
	                                const meta = chart.getDatasetMeta(0);
	                                const style = meta.controller.getStyle(i);
	                                return {
	                                    text: label,
	                                    fillStyle: style.backgroundColor,
	                                    strokeStyle: style.borderColor,
	                                    fontColor: color,
	                                    lineWidth: style.borderWidth,
	                                    pointStyle: pointStyle,
	                                    hidden: !chart.getDataVisibility(i),
	                                    index: i
	                                };
	                            });
	                        }
	                        return [];
	                    }
	                },
	                onClick (e, legendItem, legend) {
	                    legend.chart.toggleDataVisibility(legendItem.index);
	                    legend.chart.update();
	                }
	            }
	        }
	    };
	    constructor(chart, datasetIndex){
	        super(chart, datasetIndex);
	        this.enableOptionSharing = true;
	        this.innerRadius = undefined;
	        this.outerRadius = undefined;
	        this.offsetX = undefined;
	        this.offsetY = undefined;
	    }
	    linkScales() {}
	 parse(start, count) {
	        const data = this.getDataset().data;
	        const meta = this._cachedMeta;
	        if (this._parsing === false) {
	            meta._parsed = data;
	        } else {
	            let getter = (i)=>+data[i];
	            if (isObject$1(data[start])) {
	                const { key ='value'  } = this._parsing;
	                getter = (i)=>+resolveObjectKey(data[i], key);
	            }
	            let i, ilen;
	            for(i = start, ilen = start + count; i < ilen; ++i){
	                meta._parsed[i] = getter(i);
	            }
	        }
	    }
	 _getRotation() {
	        return toRadians(this.options.rotation - 90);
	    }
	 _getCircumference() {
	        return toRadians(this.options.circumference);
	    }
	 _getRotationExtents() {
	        let min = TAU;
	        let max = -TAU;
	        for(let i = 0; i < this.chart.data.datasets.length; ++i){
	            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
	                const controller = this.chart.getDatasetMeta(i).controller;
	                const rotation = controller._getRotation();
	                const circumference = controller._getCircumference();
	                min = Math.min(min, rotation);
	                max = Math.max(max, rotation + circumference);
	            }
	        }
	        return {
	            rotation: min,
	            circumference: max - min
	        };
	    }
	 update(mode) {
	        const chart = this.chart;
	        const { chartArea  } = chart;
	        const meta = this._cachedMeta;
	        const arcs = meta.data;
	        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
	        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
	        const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
	        const chartWeight = this._getRingWeight(this.index);
	        const { circumference , rotation  } = this._getRotationExtents();
	        const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);
	        const maxWidth = (chartArea.width - spacing) / ratioX;
	        const maxHeight = (chartArea.height - spacing) / ratioY;
	        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
	        const outerRadius = toDimension(this.options.radius, maxRadius);
	        const innerRadius = Math.max(outerRadius * cutout, 0);
	        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
	        this.offsetX = offsetX * outerRadius;
	        this.offsetY = offsetY * outerRadius;
	        meta.total = this.calculateTotal();
	        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
	        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
	        this.updateElements(arcs, 0, arcs.length, mode);
	    }
	 _circumference(i, reset) {
	        const opts = this.options;
	        const meta = this._cachedMeta;
	        const circumference = this._getCircumference();
	        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
	            return 0;
	        }
	        return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
	    }
	    updateElements(arcs, start, count, mode) {
	        const reset = mode === 'reset';
	        const chart = this.chart;
	        const chartArea = chart.chartArea;
	        const opts = chart.options;
	        const animationOpts = opts.animation;
	        const centerX = (chartArea.left + chartArea.right) / 2;
	        const centerY = (chartArea.top + chartArea.bottom) / 2;
	        const animateScale = reset && animationOpts.animateScale;
	        const innerRadius = animateScale ? 0 : this.innerRadius;
	        const outerRadius = animateScale ? 0 : this.outerRadius;
	        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
	        let startAngle = this._getRotation();
	        let i;
	        for(i = 0; i < start; ++i){
	            startAngle += this._circumference(i, reset);
	        }
	        for(i = start; i < start + count; ++i){
	            const circumference = this._circumference(i, reset);
	            const arc = arcs[i];
	            const properties = {
	                x: centerX + this.offsetX,
	                y: centerY + this.offsetY,
	                startAngle,
	                endAngle: startAngle + circumference,
	                circumference,
	                outerRadius,
	                innerRadius
	            };
	            if (includeOptions) {
	                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
	            }
	            startAngle += circumference;
	            this.updateElement(arc, i, properties, mode);
	        }
	    }
	    calculateTotal() {
	        const meta = this._cachedMeta;
	        const metaData = meta.data;
	        let total = 0;
	        let i;
	        for(i = 0; i < metaData.length; i++){
	            const value = meta._parsed[i];
	            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
	                total += Math.abs(value);
	            }
	        }
	        return total;
	    }
	    calculateCircumference(value) {
	        const total = this._cachedMeta.total;
	        if (total > 0 && !isNaN(value)) {
	            return TAU * (Math.abs(value) / total);
	        }
	        return 0;
	    }
	    getLabelAndValue(index) {
	        const meta = this._cachedMeta;
	        const chart = this.chart;
	        const labels = chart.data.labels || [];
	        const value = formatNumber(meta._parsed[index], chart.options.locale);
	        return {
	            label: labels[index] || '',
	            value
	        };
	    }
	    getMaxBorderWidth(arcs) {
	        let max = 0;
	        const chart = this.chart;
	        let i, ilen, meta, controller, options;
	        if (!arcs) {
	            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){
	                if (chart.isDatasetVisible(i)) {
	                    meta = chart.getDatasetMeta(i);
	                    arcs = meta.data;
	                    controller = meta.controller;
	                    break;
	                }
	            }
	        }
	        if (!arcs) {
	            return 0;
	        }
	        for(i = 0, ilen = arcs.length; i < ilen; ++i){
	            options = controller.resolveDataElementOptions(i);
	            if (options.borderAlign !== 'inner') {
	                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
	            }
	        }
	        return max;
	    }
	    getMaxOffset(arcs) {
	        let max = 0;
	        for(let i = 0, ilen = arcs.length; i < ilen; ++i){
	            const options = this.resolveDataElementOptions(i);
	            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
	        }
	        return max;
	    }
	 _getRingWeightOffset(datasetIndex) {
	        let ringWeightOffset = 0;
	        for(let i = 0; i < datasetIndex; ++i){
	            if (this.chart.isDatasetVisible(i)) {
	                ringWeightOffset += this._getRingWeight(i);
	            }
	        }
	        return ringWeightOffset;
	    }
	 _getRingWeight(datasetIndex) {
	        return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
	    }
	 _getVisibleDatasetWeightTotal() {
	        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
	    }
	}

	class LineController extends DatasetController {
	    static id = 'line';
	 static defaults = {
	        datasetElementType: 'line',
	        dataElementType: 'point',
	        showLine: true,
	        spanGaps: false
	    };
	 static overrides = {
	        scales: {
	            _index_: {
	                type: 'category'
	            },
	            _value_: {
	                type: 'linear'
	            }
	        }
	    };
	    initialize() {
	        this.enableOptionSharing = true;
	        this.supportsDecimation = true;
	        super.initialize();
	    }
	    update(mode) {
	        const meta = this._cachedMeta;
	        const { dataset: line , data: points = [] , _dataset  } = meta;
	        const animationsDisabled = this.chart._animationsDisabled;
	        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
	        this._drawStart = start;
	        this._drawCount = count;
	        if (_scaleRangesChanged(meta)) {
	            start = 0;
	            count = points.length;
	        }
	        line._chart = this.chart;
	        line._datasetIndex = this.index;
	        line._decimated = !!_dataset._decimated;
	        line.points = points;
	        const options = this.resolveDatasetElementOptions(mode);
	        if (!this.options.showLine) {
	            options.borderWidth = 0;
	        }
	        options.segment = this.options.segment;
	        this.updateElement(line, undefined, {
	            animated: !animationsDisabled,
	            options
	        }, mode);
	        this.updateElements(points, start, count, mode);
	    }
	    updateElements(points, start, count, mode) {
	        const reset = mode === 'reset';
	        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;
	        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
	        const iAxis = iScale.axis;
	        const vAxis = vScale.axis;
	        const { spanGaps , segment  } = this.options;
	        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
	        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
	        const end = start + count;
	        const pointsCount = points.length;
	        let prevParsed = start > 0 && this.getParsed(start - 1);
	        for(let i = 0; i < pointsCount; ++i){
	            const point = points[i];
	            const properties = directUpdate ? point : {};
	            if (i < start || i >= end) {
	                properties.skip = true;
	                continue;
	            }
	            const parsed = this.getParsed(i);
	            const nullData = isNullOrUndef(parsed[vAxis]);
	            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
	            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
	            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
	            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
	            if (segment) {
	                properties.parsed = parsed;
	                properties.raw = _dataset.data[i];
	            }
	            if (includeOptions) {
	                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
	            }
	            if (!directUpdate) {
	                this.updateElement(point, i, properties, mode);
	            }
	            prevParsed = parsed;
	        }
	    }
	 getMaxOverflow() {
	        const meta = this._cachedMeta;
	        const dataset = meta.dataset;
	        const border = dataset.options && dataset.options.borderWidth || 0;
	        const data = meta.data || [];
	        if (!data.length) {
	            return border;
	        }
	        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
	        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
	        return Math.max(border, firstPoint, lastPoint) / 2;
	    }
	    draw() {
	        const meta = this._cachedMeta;
	        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
	        super.draw();
	    }
	}

	/**
	 * @namespace Chart._adapters
	 * @since 2.8.0
	 * @private
	 */ function abstract() {
	    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
	}
	/**
	 * Date adapter (current used by the time scale)
	 * @namespace Chart._adapters._date
	 * @memberof Chart._adapters
	 * @private
	 */ class DateAdapterBase {
	    /**
	   * Override default date adapter methods.
	   * Accepts type parameter to define options type.
	   * @example
	   * Chart._adapters._date.override<{myAdapterOption: string}>({
	   *   init() {
	   *     console.log(this.options.myAdapterOption);
	   *   }
	   * })
	   */ static override(members) {
	        Object.assign(DateAdapterBase.prototype, members);
	    }
	    options;
	    constructor(options){
	        this.options = options || {};
	    }
	    // eslint-disable-next-line @typescript-eslint/no-empty-function
	    init() {}
	    formats() {
	        return abstract();
	    }
	    parse() {
	        return abstract();
	    }
	    format() {
	        return abstract();
	    }
	    add() {
	        return abstract();
	    }
	    diff() {
	        return abstract();
	    }
	    startOf() {
	        return abstract();
	    }
	    endOf() {
	        return abstract();
	    }
	}
	var adapters = {
	    _date: DateAdapterBase
	};

	function binarySearch(metaset, axis, value, intersect) {
	    const { controller , data , _sorted  } = metaset;
	    const iScale = controller._cachedMeta.iScale;
	    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {
	        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
	        if (!intersect) {
	            return lookupMethod(data, axis, value);
	        } else if (controller._sharedOptions) {
	            const el = data[0];
	            const range = typeof el.getRange === 'function' && el.getRange(axis);
	            if (range) {
	                const start = lookupMethod(data, axis, value - range);
	                const end = lookupMethod(data, axis, value + range);
	                return {
	                    lo: start.lo,
	                    hi: end.hi
	                };
	            }
	        }
	    }
	    return {
	        lo: 0,
	        hi: data.length - 1
	    };
	}
	 function evaluateInteractionItems(chart, axis, position, handler, intersect) {
	    const metasets = chart.getSortedVisibleDatasetMetas();
	    const value = position[axis];
	    for(let i = 0, ilen = metasets.length; i < ilen; ++i){
	        const { index , data  } = metasets[i];
	        const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);
	        for(let j = lo; j <= hi; ++j){
	            const element = data[j];
	            if (!element.skip) {
	                handler(element, index, j);
	            }
	        }
	    }
	}
	 function getDistanceMetricForAxis(axis) {
	    const useX = axis.indexOf('x') !== -1;
	    const useY = axis.indexOf('y') !== -1;
	    return function(pt1, pt2) {
	        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
	        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
	        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
	    };
	}
	 function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
	    const items = [];
	    if (!includeInvisible && !chart.isPointInArea(position)) {
	        return items;
	    }
	    const evaluationFunc = function(element, datasetIndex, index) {
	        if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
	            return;
	        }
	        if (element.inRange(position.x, position.y, useFinalPosition)) {
	            items.push({
	                element,
	                datasetIndex,
	                index
	            });
	        }
	    };
	    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
	    return items;
	}
	 function getNearestRadialItems(chart, position, axis, useFinalPosition) {
	    let items = [];
	    function evaluationFunc(element, datasetIndex, index) {
	        const { startAngle , endAngle  } = element.getProps([
	            'startAngle',
	            'endAngle'
	        ], useFinalPosition);
	        const { angle  } = getAngleFromPoint(element, {
	            x: position.x,
	            y: position.y
	        });
	        if (_angleBetween(angle, startAngle, endAngle)) {
	            items.push({
	                element,
	                datasetIndex,
	                index
	            });
	        }
	    }
	    evaluateInteractionItems(chart, axis, position, evaluationFunc);
	    return items;
	}
	 function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
	    let items = [];
	    const distanceMetric = getDistanceMetricForAxis(axis);
	    let minDistance = Number.POSITIVE_INFINITY;
	    function evaluationFunc(element, datasetIndex, index) {
	        const inRange = element.inRange(position.x, position.y, useFinalPosition);
	        if (intersect && !inRange) {
	            return;
	        }
	        const center = element.getCenterPoint(useFinalPosition);
	        const pointInArea = !!includeInvisible || chart.isPointInArea(center);
	        if (!pointInArea && !inRange) {
	            return;
	        }
	        const distance = distanceMetric(position, center);
	        if (distance < minDistance) {
	            items = [
	                {
	                    element,
	                    datasetIndex,
	                    index
	                }
	            ];
	            minDistance = distance;
	        } else if (distance === minDistance) {
	            items.push({
	                element,
	                datasetIndex,
	                index
	            });
	        }
	    }
	    evaluateInteractionItems(chart, axis, position, evaluationFunc);
	    return items;
	}
	 function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
	    if (!includeInvisible && !chart.isPointInArea(position)) {
	        return [];
	    }
	    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
	}
	 function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
	    const items = [];
	    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
	    let intersectsItem = false;
	    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{
	        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
	            items.push({
	                element,
	                datasetIndex,
	                index
	            });
	            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
	        }
	    });
	    if (intersect && !intersectsItem) {
	        return [];
	    }
	    return items;
	}
	 var Interaction = {
	    evaluateInteractionItems,
	    modes: {
	 index (chart, e, options, useFinalPosition) {
	            const position = getRelativePosition(e, chart);
	            const axis = options.axis || 'x';
	            const includeInvisible = options.includeInvisible || false;
	            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
	            const elements = [];
	            if (!items.length) {
	                return [];
	            }
	            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{
	                const index = items[0].index;
	                const element = meta.data[index];
	                if (element && !element.skip) {
	                    elements.push({
	                        element,
	                        datasetIndex: meta.index,
	                        index
	                    });
	                }
	            });
	            return elements;
	        },
	 dataset (chart, e, options, useFinalPosition) {
	            const position = getRelativePosition(e, chart);
	            const axis = options.axis || 'xy';
	            const includeInvisible = options.includeInvisible || false;
	            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
	            if (items.length > 0) {
	                const datasetIndex = items[0].datasetIndex;
	                const data = chart.getDatasetMeta(datasetIndex).data;
	                items = [];
	                for(let i = 0; i < data.length; ++i){
	                    items.push({
	                        element: data[i],
	                        datasetIndex,
	                        index: i
	                    });
	                }
	            }
	            return items;
	        },
	 point (chart, e, options, useFinalPosition) {
	            const position = getRelativePosition(e, chart);
	            const axis = options.axis || 'xy';
	            const includeInvisible = options.includeInvisible || false;
	            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
	        },
	 nearest (chart, e, options, useFinalPosition) {
	            const position = getRelativePosition(e, chart);
	            const axis = options.axis || 'xy';
	            const includeInvisible = options.includeInvisible || false;
	            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
	        },
	 x (chart, e, options, useFinalPosition) {
	            const position = getRelativePosition(e, chart);
	            return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);
	        },
	 y (chart, e, options, useFinalPosition) {
	            const position = getRelativePosition(e, chart);
	            return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);
	        }
	    }
	};

	const STATIC_POSITIONS = [
	    'left',
	    'top',
	    'right',
	    'bottom'
	];
	function filterByPosition(array, position) {
	    return array.filter((v)=>v.pos === position);
	}
	function filterDynamicPositionByAxis(array, axis) {
	    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
	}
	function sortByWeight(array, reverse) {
	    return array.sort((a, b)=>{
	        const v0 = reverse ? b : a;
	        const v1 = reverse ? a : b;
	        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
	    });
	}
	function wrapBoxes(boxes) {
	    const layoutBoxes = [];
	    let i, ilen, box, pos, stack, stackWeight;
	    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){
	        box = boxes[i];
	        ({ position: pos , options: { stack , stackWeight =1  }  } = box);
	        layoutBoxes.push({
	            index: i,
	            box,
	            pos,
	            horizontal: box.isHorizontal(),
	            weight: box.weight,
	            stack: stack && pos + stack,
	            stackWeight
	        });
	    }
	    return layoutBoxes;
	}
	function buildStacks(layouts) {
	    const stacks = {};
	    for (const wrap of layouts){
	        const { stack , pos , stackWeight  } = wrap;
	        if (!stack || !STATIC_POSITIONS.includes(pos)) {
	            continue;
	        }
	        const _stack = stacks[stack] || (stacks[stack] = {
	            count: 0,
	            placed: 0,
	            weight: 0,
	            size: 0
	        });
	        _stack.count++;
	        _stack.weight += stackWeight;
	    }
	    return stacks;
	}
	 function setLayoutDims(layouts, params) {
	    const stacks = buildStacks(layouts);
	    const { vBoxMaxWidth , hBoxMaxHeight  } = params;
	    let i, ilen, layout;
	    for(i = 0, ilen = layouts.length; i < ilen; ++i){
	        layout = layouts[i];
	        const { fullSize  } = layout.box;
	        const stack = stacks[layout.stack];
	        const factor = stack && layout.stackWeight / stack.weight;
	        if (layout.horizontal) {
	            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
	            layout.height = hBoxMaxHeight;
	        } else {
	            layout.width = vBoxMaxWidth;
	            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
	        }
	    }
	    return stacks;
	}
	function buildLayoutBoxes(boxes) {
	    const layoutBoxes = wrapBoxes(boxes);
	    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);
	    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
	    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
	    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
	    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
	    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
	    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
	    return {
	        fullSize,
	        leftAndTop: left.concat(top),
	        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
	        chartArea: filterByPosition(layoutBoxes, 'chartArea'),
	        vertical: left.concat(right).concat(centerVertical),
	        horizontal: top.concat(bottom).concat(centerHorizontal)
	    };
	}
	function getCombinedMax(maxPadding, chartArea, a, b) {
	    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
	}
	function updateMaxPadding(maxPadding, boxPadding) {
	    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
	    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
	    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
	    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
	}
	function updateDims(chartArea, params, layout, stacks) {
	    const { pos , box  } = layout;
	    const maxPadding = chartArea.maxPadding;
	    if (!isObject$1(pos)) {
	        if (layout.size) {
	            chartArea[pos] -= layout.size;
	        }
	        const stack = stacks[layout.stack] || {
	            size: 0,
	            count: 1
	        };
	        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
	        layout.size = stack.size / stack.count;
	        chartArea[pos] += layout.size;
	    }
	    if (box.getPadding) {
	        updateMaxPadding(maxPadding, box.getPadding());
	    }
	    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
	    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
	    const widthChanged = newWidth !== chartArea.w;
	    const heightChanged = newHeight !== chartArea.h;
	    chartArea.w = newWidth;
	    chartArea.h = newHeight;
	    return layout.horizontal ? {
	        same: widthChanged,
	        other: heightChanged
	    } : {
	        same: heightChanged,
	        other: widthChanged
	    };
	}
	function handleMaxPadding(chartArea) {
	    const maxPadding = chartArea.maxPadding;
	    function updatePos(pos) {
	        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
	        chartArea[pos] += change;
	        return change;
	    }
	    chartArea.y += updatePos('top');
	    chartArea.x += updatePos('left');
	    updatePos('right');
	    updatePos('bottom');
	}
	function getMargins(horizontal, chartArea) {
	    const maxPadding = chartArea.maxPadding;
	    function marginForPositions(positions) {
	        const margin = {
	            left: 0,
	            top: 0,
	            right: 0,
	            bottom: 0
	        };
	        positions.forEach((pos)=>{
	            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
	        });
	        return margin;
	    }
	    return horizontal ? marginForPositions([
	        'left',
	        'right'
	    ]) : marginForPositions([
	        'top',
	        'bottom'
	    ]);
	}
	function fitBoxes(boxes, chartArea, params, stacks) {
	    const refitBoxes = [];
	    let i, ilen, layout, box, refit, changed;
	    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){
	        layout = boxes[i];
	        box = layout.box;
	        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
	        const { same , other  } = updateDims(chartArea, params, layout, stacks);
	        refit |= same && refitBoxes.length;
	        changed = changed || other;
	        if (!box.fullSize) {
	            refitBoxes.push(layout);
	        }
	    }
	    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
	}
	function setBoxDims(box, left, top, width, height) {
	    box.top = top;
	    box.left = left;
	    box.right = left + width;
	    box.bottom = top + height;
	    box.width = width;
	    box.height = height;
	}
	function placeBoxes(boxes, chartArea, params, stacks) {
	    const userPadding = params.padding;
	    let { x , y  } = chartArea;
	    for (const layout of boxes){
	        const box = layout.box;
	        const stack = stacks[layout.stack] || {
	            count: 1,
	            placed: 0,
	            weight: 1
	        };
	        const weight = layout.stackWeight / stack.weight || 1;
	        if (layout.horizontal) {
	            const width = chartArea.w * weight;
	            const height = stack.size || box.height;
	            if (defined(stack.start)) {
	                y = stack.start;
	            }
	            if (box.fullSize) {
	                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
	            } else {
	                setBoxDims(box, chartArea.left + stack.placed, y, width, height);
	            }
	            stack.start = y;
	            stack.placed += width;
	            y = box.bottom;
	        } else {
	            const height = chartArea.h * weight;
	            const width = stack.size || box.width;
	            if (defined(stack.start)) {
	                x = stack.start;
	            }
	            if (box.fullSize) {
	                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
	            } else {
	                setBoxDims(box, x, chartArea.top + stack.placed, width, height);
	            }
	            stack.start = x;
	            stack.placed += height;
	            x = box.right;
	        }
	    }
	    chartArea.x = x;
	    chartArea.y = y;
	}
	var layouts = {
	 addBox (chart, item) {
	        if (!chart.boxes) {
	            chart.boxes = [];
	        }
	        item.fullSize = item.fullSize || false;
	        item.position = item.position || 'top';
	        item.weight = item.weight || 0;
	        item._layers = item._layers || function() {
	            return [
	                {
	                    z: 0,
	                    draw (chartArea) {
	                        item.draw(chartArea);
	                    }
	                }
	            ];
	        };
	        chart.boxes.push(item);
	    },
	 removeBox (chart, layoutItem) {
	        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
	        if (index !== -1) {
	            chart.boxes.splice(index, 1);
	        }
	    },
	 configure (chart, item, options) {
	        item.fullSize = options.fullSize;
	        item.position = options.position;
	        item.weight = options.weight;
	    },
	 update (chart, width, height, minPadding) {
	        if (!chart) {
	            return;
	        }
	        const padding = toPadding(chart.options.layout.padding);
	        const availableWidth = Math.max(width - padding.width, 0);
	        const availableHeight = Math.max(height - padding.height, 0);
	        const boxes = buildLayoutBoxes(chart.boxes);
	        const verticalBoxes = boxes.vertical;
	        const horizontalBoxes = boxes.horizontal;
	        each(chart.boxes, (box)=>{
	            if (typeof box.beforeLayout === 'function') {
	                box.beforeLayout();
	            }
	        });
	        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
	        const params = Object.freeze({
	            outerWidth: width,
	            outerHeight: height,
	            padding,
	            availableWidth,
	            availableHeight,
	            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
	            hBoxMaxHeight: availableHeight / 2
	        });
	        const maxPadding = Object.assign({}, padding);
	        updateMaxPadding(maxPadding, toPadding(minPadding));
	        const chartArea = Object.assign({
	            maxPadding,
	            w: availableWidth,
	            h: availableHeight,
	            x: padding.left,
	            y: padding.top
	        }, padding);
	        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
	        fitBoxes(boxes.fullSize, chartArea, params, stacks);
	        fitBoxes(verticalBoxes, chartArea, params, stacks);
	        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
	            fitBoxes(verticalBoxes, chartArea, params, stacks);
	        }
	        handleMaxPadding(chartArea);
	        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
	        chartArea.x += chartArea.w;
	        chartArea.y += chartArea.h;
	        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
	        chart.chartArea = {
	            left: chartArea.left,
	            top: chartArea.top,
	            right: chartArea.left + chartArea.w,
	            bottom: chartArea.top + chartArea.h,
	            height: chartArea.h,
	            width: chartArea.w
	        };
	        each(boxes.chartArea, (layout)=>{
	            const box = layout.box;
	            Object.assign(box, chart.chartArea);
	            box.update(chartArea.w, chartArea.h, {
	                left: 0,
	                top: 0,
	                right: 0,
	                bottom: 0
	            });
	        });
	    }
	};

	class BasePlatform {
	 acquireContext(canvas, aspectRatio) {}
	 releaseContext(context) {
	        return false;
	    }
	 addEventListener(chart, type, listener) {}
	 removeEventListener(chart, type, listener) {}
	 getDevicePixelRatio() {
	        return 1;
	    }
	 getMaximumSize(element, width, height, aspectRatio) {
	        width = Math.max(0, width || element.width);
	        height = height || element.height;
	        return {
	            width,
	            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
	        };
	    }
	 isAttached(canvas) {
	        return true;
	    }
	 updateConfig(config) {
	    }
	}

	class BasicPlatform extends BasePlatform {
	    acquireContext(item) {
	        return item && item.getContext && item.getContext('2d') || null;
	    }
	    updateConfig(config) {
	        config.options.animation = false;
	    }
	}

	const EXPANDO_KEY = '$chartjs';
	 const EVENT_TYPES = {
	    touchstart: 'mousedown',
	    touchmove: 'mousemove',
	    touchend: 'mouseup',
	    pointerenter: 'mouseenter',
	    pointerdown: 'mousedown',
	    pointermove: 'mousemove',
	    pointerup: 'mouseup',
	    pointerleave: 'mouseout',
	    pointerout: 'mouseout'
	};
	const isNullOrEmpty = (value)=>value === null || value === '';
	 function initCanvas(canvas, aspectRatio) {
	    const style = canvas.style;
	    const renderHeight = canvas.getAttribute('height');
	    const renderWidth = canvas.getAttribute('width');
	    canvas[EXPANDO_KEY] = {
	        initial: {
	            height: renderHeight,
	            width: renderWidth,
	            style: {
	                display: style.display,
	                height: style.height,
	                width: style.width
	            }
	        }
	    };
	    style.display = style.display || 'block';
	    style.boxSizing = style.boxSizing || 'border-box';
	    if (isNullOrEmpty(renderWidth)) {
	        const displayWidth = readUsedSize(canvas, 'width');
	        if (displayWidth !== undefined) {
	            canvas.width = displayWidth;
	        }
	    }
	    if (isNullOrEmpty(renderHeight)) {
	        if (canvas.style.height === '') {
	            canvas.height = canvas.width / (aspectRatio || 2);
	        } else {
	            const displayHeight = readUsedSize(canvas, 'height');
	            if (displayHeight !== undefined) {
	                canvas.height = displayHeight;
	            }
	        }
	    }
	    return canvas;
	}
	const eventListenerOptions = supportsEventListenerOptions ? {
	    passive: true
	} : false;
	function addListener(node, type, listener) {
	    if (node) {
	        node.addEventListener(type, listener, eventListenerOptions);
	    }
	}
	function removeListener(chart, type, listener) {
	    if (chart && chart.canvas) {
	        chart.canvas.removeEventListener(type, listener, eventListenerOptions);
	    }
	}
	function fromNativeEvent(event, chart) {
	    const type = EVENT_TYPES[event.type] || event.type;
	    const { x , y  } = getRelativePosition(event, chart);
	    return {
	        type,
	        chart,
	        native: event,
	        x: x !== undefined ? x : null,
	        y: y !== undefined ? y : null
	    };
	}
	function nodeListContains(nodeList, canvas) {
	    for (const node of nodeList){
	        if (node === canvas || node.contains(canvas)) {
	            return true;
	        }
	    }
	}
	function createAttachObserver(chart, type, listener) {
	    const canvas = chart.canvas;
	    const observer = new MutationObserver((entries)=>{
	        let trigger = false;
	        for (const entry of entries){
	            trigger = trigger || nodeListContains(entry.addedNodes, canvas);
	            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
	        }
	        if (trigger) {
	            listener();
	        }
	    });
	    observer.observe(document, {
	        childList: true,
	        subtree: true
	    });
	    return observer;
	}
	function createDetachObserver(chart, type, listener) {
	    const canvas = chart.canvas;
	    const observer = new MutationObserver((entries)=>{
	        let trigger = false;
	        for (const entry of entries){
	            trigger = trigger || nodeListContains(entry.removedNodes, canvas);
	            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
	        }
	        if (trigger) {
	            listener();
	        }
	    });
	    observer.observe(document, {
	        childList: true,
	        subtree: true
	    });
	    return observer;
	}
	const drpListeningCharts = new Map();
	let oldDevicePixelRatio = 0;
	function onWindowResize() {
	    const dpr = window.devicePixelRatio;
	    if (dpr === oldDevicePixelRatio) {
	        return;
	    }
	    oldDevicePixelRatio = dpr;
	    drpListeningCharts.forEach((resize, chart)=>{
	        if (chart.currentDevicePixelRatio !== dpr) {
	            resize();
	        }
	    });
	}
	function listenDevicePixelRatioChanges(chart, resize) {
	    if (!drpListeningCharts.size) {
	        window.addEventListener('resize', onWindowResize);
	    }
	    drpListeningCharts.set(chart, resize);
	}
	function unlistenDevicePixelRatioChanges(chart) {
	    drpListeningCharts.delete(chart);
	    if (!drpListeningCharts.size) {
	        window.removeEventListener('resize', onWindowResize);
	    }
	}
	function createResizeObserver(chart, type, listener) {
	    const canvas = chart.canvas;
	    const container = canvas && _getParentNode(canvas);
	    if (!container) {
	        return;
	    }
	    const resize = throttled((width, height)=>{
	        const w = container.clientWidth;
	        listener(width, height);
	        if (w < container.clientWidth) {
	            listener();
	        }
	    }, window);
	    const observer = new ResizeObserver((entries)=>{
	        const entry = entries[0];
	        const width = entry.contentRect.width;
	        const height = entry.contentRect.height;
	        if (width === 0 && height === 0) {
	            return;
	        }
	        resize(width, height);
	    });
	    observer.observe(container);
	    listenDevicePixelRatioChanges(chart, resize);
	    return observer;
	}
	function releaseObserver(chart, type, observer) {
	    if (observer) {
	        observer.disconnect();
	    }
	    if (type === 'resize') {
	        unlistenDevicePixelRatioChanges(chart);
	    }
	}
	function createProxyAndListen(chart, type, listener) {
	    const canvas = chart.canvas;
	    const proxy = throttled((event)=>{
	        if (chart.ctx !== null) {
	            listener(fromNativeEvent(event, chart));
	        }
	    }, chart);
	    addListener(canvas, type, proxy);
	    return proxy;
	}
	 class DomPlatform extends BasePlatform {
	 acquireContext(canvas, aspectRatio) {
	        const context = canvas && canvas.getContext && canvas.getContext('2d');
	        if (context && context.canvas === canvas) {
	            initCanvas(canvas, aspectRatio);
	            return context;
	        }
	        return null;
	    }
	 releaseContext(context) {
	        const canvas = context.canvas;
	        if (!canvas[EXPANDO_KEY]) {
	            return false;
	        }
	        const initial = canvas[EXPANDO_KEY].initial;
	        [
	            'height',
	            'width'
	        ].forEach((prop)=>{
	            const value = initial[prop];
	            if (isNullOrUndef(value)) {
	                canvas.removeAttribute(prop);
	            } else {
	                canvas.setAttribute(prop, value);
	            }
	        });
	        const style = initial.style || {};
	        Object.keys(style).forEach((key)=>{
	            canvas.style[key] = style[key];
	        });
	        canvas.width = canvas.width;
	        delete canvas[EXPANDO_KEY];
	        return true;
	    }
	 addEventListener(chart, type, listener) {
	        this.removeEventListener(chart, type);
	        const proxies = chart.$proxies || (chart.$proxies = {});
	        const handlers = {
	            attach: createAttachObserver,
	            detach: createDetachObserver,
	            resize: createResizeObserver
	        };
	        const handler = handlers[type] || createProxyAndListen;
	        proxies[type] = handler(chart, type, listener);
	    }
	 removeEventListener(chart, type) {
	        const proxies = chart.$proxies || (chart.$proxies = {});
	        const proxy = proxies[type];
	        if (!proxy) {
	            return;
	        }
	        const handlers = {
	            attach: releaseObserver,
	            detach: releaseObserver,
	            resize: releaseObserver
	        };
	        const handler = handlers[type] || removeListener;
	        handler(chart, type, proxy);
	        proxies[type] = undefined;
	    }
	    getDevicePixelRatio() {
	        return window.devicePixelRatio;
	    }
	 getMaximumSize(canvas, width, height, aspectRatio) {
	        return getMaximumSize(canvas, width, height, aspectRatio);
	    }
	 isAttached(canvas) {
	        const container = canvas && _getParentNode(canvas);
	        return !!(container && container.isConnected);
	    }
	}

	function _detectPlatform(canvas) {
	    if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {
	        return BasicPlatform;
	    }
	    return DomPlatform;
	}

	class Element {
	    static defaults = {};
	    static defaultRoutes = undefined;
	    x;
	    y;
	    active = false;
	    options;
	    $animations;
	    tooltipPosition(useFinalPosition) {
	        const { x , y  } = this.getProps([
	            'x',
	            'y'
	        ], useFinalPosition);
	        return {
	            x,
	            y
	        };
	    }
	    hasValue() {
	        return isNumber(this.x) && isNumber(this.y);
	    }
	    getProps(props, final) {
	        const anims = this.$animations;
	        if (!final || !anims) {
	            // let's not create an object, if not needed
	            return this;
	        }
	        const ret = {};
	        props.forEach((prop)=>{
	            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
	        });
	        return ret;
	    }
	}

	function autoSkip(scale, ticks) {
	    const tickOpts = scale.options.ticks;
	    const determinedMaxTicks = determineMaxTicks(scale);
	    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
	    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
	    const numMajorIndices = majorIndices.length;
	    const first = majorIndices[0];
	    const last = majorIndices[numMajorIndices - 1];
	    const newTicks = [];
	    if (numMajorIndices > ticksLimit) {
	        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
	        return newTicks;
	    }
	    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
	    if (numMajorIndices > 0) {
	        let i, ilen;
	        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
	        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
	        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){
	            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
	        }
	        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
	        return newTicks;
	    }
	    skip(ticks, newTicks, spacing);
	    return newTicks;
	}
	function determineMaxTicks(scale) {
	    const offset = scale.options.offset;
	    const tickLength = scale._tickSize();
	    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
	    const maxChart = scale._maxLength / tickLength;
	    return Math.floor(Math.min(maxScale, maxChart));
	}
	 function calculateSpacing(majorIndices, ticks, ticksLimit) {
	    const evenMajorSpacing = getEvenSpacing(majorIndices);
	    const spacing = ticks.length / ticksLimit;
	    if (!evenMajorSpacing) {
	        return Math.max(spacing, 1);
	    }
	    const factors = _factorize(evenMajorSpacing);
	    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){
	        const factor = factors[i];
	        if (factor > spacing) {
	            return factor;
	        }
	    }
	    return Math.max(spacing, 1);
	}
	 function getMajorIndices(ticks) {
	    const result = [];
	    let i, ilen;
	    for(i = 0, ilen = ticks.length; i < ilen; i++){
	        if (ticks[i].major) {
	            result.push(i);
	        }
	    }
	    return result;
	}
	 function skipMajors(ticks, newTicks, majorIndices, spacing) {
	    let count = 0;
	    let next = majorIndices[0];
	    let i;
	    spacing = Math.ceil(spacing);
	    for(i = 0; i < ticks.length; i++){
	        if (i === next) {
	            newTicks.push(ticks[i]);
	            count++;
	            next = majorIndices[count * spacing];
	        }
	    }
	}
	 function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
	    const start = valueOrDefault(majorStart, 0);
	    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
	    let count = 0;
	    let length, i, next;
	    spacing = Math.ceil(spacing);
	    if (majorEnd) {
	        length = majorEnd - majorStart;
	        spacing = length / Math.floor(length / spacing);
	    }
	    next = start;
	    while(next < 0){
	        count++;
	        next = Math.round(start + count * spacing);
	    }
	    for(i = Math.max(start, 0); i < end; i++){
	        if (i === next) {
	            newTicks.push(ticks[i]);
	            count++;
	            next = Math.round(start + count * spacing);
	        }
	    }
	}
	 function getEvenSpacing(arr) {
	    const len = arr.length;
	    let i, diff;
	    if (len < 2) {
	        return false;
	    }
	    for(diff = arr[0], i = 1; i < len; ++i){
	        if (arr[i] - arr[i - 1] !== diff) {
	            return false;
	        }
	    }
	    return diff;
	}

	const reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;
	const offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;
	const getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);
	 function sample(arr, numItems) {
	    const result = [];
	    const increment = arr.length / numItems;
	    const len = arr.length;
	    let i = 0;
	    for(; i < len; i += increment){
	        result.push(arr[Math.floor(i)]);
	    }
	    return result;
	}
	 function getPixelForGridLine(scale, index, offsetGridLines) {
	    const length = scale.ticks.length;
	    const validIndex = Math.min(index, length - 1);
	    const start = scale._startPixel;
	    const end = scale._endPixel;
	    const epsilon = 1e-6;
	    let lineValue = scale.getPixelForTick(validIndex);
	    let offset;
	    if (offsetGridLines) {
	        if (length === 1) {
	            offset = Math.max(lineValue - start, end - lineValue);
	        } else if (index === 0) {
	            offset = (scale.getPixelForTick(1) - lineValue) / 2;
	        } else {
	            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
	        }
	        lineValue += validIndex < index ? offset : -offset;
	        if (lineValue < start - epsilon || lineValue > end + epsilon) {
	            return;
	        }
	    }
	    return lineValue;
	}
	 function garbageCollect(caches, length) {
	    each(caches, (cache)=>{
	        const gc = cache.gc;
	        const gcLen = gc.length / 2;
	        let i;
	        if (gcLen > length) {
	            for(i = 0; i < gcLen; ++i){
	                delete cache.data[gc[i]];
	            }
	            gc.splice(0, gcLen);
	        }
	    });
	}
	 function getTickMarkLength(options) {
	    return options.drawTicks ? options.tickLength : 0;
	}
	 function getTitleHeight(options, fallback) {
	    if (!options.display) {
	        return 0;
	    }
	    const font = toFont(options.font, fallback);
	    const padding = toPadding(options.padding);
	    const lines = isArray$1(options.text) ? options.text.length : 1;
	    return lines * font.lineHeight + padding.height;
	}
	function createScaleContext(parent, scale) {
	    return createContext(parent, {
	        scale,
	        type: 'scale'
	    });
	}
	function createTickContext(parent, index, tick) {
	    return createContext(parent, {
	        tick,
	        index,
	        type: 'tick'
	    });
	}
	function titleAlign(align, position, reverse) {
	     let ret = _toLeftRightCenter(align);
	    if (reverse && position !== 'right' || !reverse && position === 'right') {
	        ret = reverseAlign(ret);
	    }
	    return ret;
	}
	function titleArgs(scale, offset, position, align) {
	    const { top , left , bottom , right , chart  } = scale;
	    const { chartArea , scales  } = chart;
	    let rotation = 0;
	    let maxWidth, titleX, titleY;
	    const height = bottom - top;
	    const width = right - left;
	    if (scale.isHorizontal()) {
	        titleX = _alignStartEnd(align, left, right);
	        if (isObject$1(position)) {
	            const positionAxisID = Object.keys(position)[0];
	            const value = position[positionAxisID];
	            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
	        } else if (position === 'center') {
	            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
	        } else {
	            titleY = offsetFromEdge(scale, position, offset);
	        }
	        maxWidth = right - left;
	    } else {
	        if (isObject$1(position)) {
	            const positionAxisID = Object.keys(position)[0];
	            const value = position[positionAxisID];
	            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
	        } else if (position === 'center') {
	            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
	        } else {
	            titleX = offsetFromEdge(scale, position, offset);
	        }
	        titleY = _alignStartEnd(align, bottom, top);
	        rotation = position === 'left' ? -HALF_PI : HALF_PI;
	    }
	    return {
	        titleX,
	        titleY,
	        maxWidth,
	        rotation
	    };
	}
	class Scale extends Element {
	    constructor(cfg){
	        super();
	         this.id = cfg.id;
	         this.type = cfg.type;
	         this.options = undefined;
	         this.ctx = cfg.ctx;
	         this.chart = cfg.chart;
	         this.top = undefined;
	         this.bottom = undefined;
	         this.left = undefined;
	         this.right = undefined;
	         this.width = undefined;
	         this.height = undefined;
	        this._margins = {
	            left: 0,
	            right: 0,
	            top: 0,
	            bottom: 0
	        };
	         this.maxWidth = undefined;
	         this.maxHeight = undefined;
	         this.paddingTop = undefined;
	         this.paddingBottom = undefined;
	         this.paddingLeft = undefined;
	         this.paddingRight = undefined;
	         this.axis = undefined;
	         this.labelRotation = undefined;
	        this.min = undefined;
	        this.max = undefined;
	        this._range = undefined;
	         this.ticks = [];
	         this._gridLineItems = null;
	         this._labelItems = null;
	         this._labelSizes = null;
	        this._length = 0;
	        this._maxLength = 0;
	        this._longestTextCache = {};
	         this._startPixel = undefined;
	         this._endPixel = undefined;
	        this._reversePixels = false;
	        this._userMax = undefined;
	        this._userMin = undefined;
	        this._suggestedMax = undefined;
	        this._suggestedMin = undefined;
	        this._ticksLength = 0;
	        this._borderValue = 0;
	        this._cache = {};
	        this._dataLimitsCached = false;
	        this.$context = undefined;
	    }
	 init(options) {
	        this.options = options.setContext(this.getContext());
	        this.axis = options.axis;
	        this._userMin = this.parse(options.min);
	        this._userMax = this.parse(options.max);
	        this._suggestedMin = this.parse(options.suggestedMin);
	        this._suggestedMax = this.parse(options.suggestedMax);
	    }
	 parse(raw, index) {
	        return raw;
	    }
	 getUserBounds() {
	        let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;
	        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
	        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
	        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
	        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
	        return {
	            min: finiteOrDefault(_userMin, _suggestedMin),
	            max: finiteOrDefault(_userMax, _suggestedMax),
	            minDefined: isNumberFinite(_userMin),
	            maxDefined: isNumberFinite(_userMax)
	        };
	    }
	 getMinMax(canStack) {
	        let { min , max , minDefined , maxDefined  } = this.getUserBounds();
	        let range;
	        if (minDefined && maxDefined) {
	            return {
	                min,
	                max
	            };
	        }
	        const metas = this.getMatchingVisibleMetas();
	        for(let i = 0, ilen = metas.length; i < ilen; ++i){
	            range = metas[i].controller.getMinMax(this, canStack);
	            if (!minDefined) {
	                min = Math.min(min, range.min);
	            }
	            if (!maxDefined) {
	                max = Math.max(max, range.max);
	            }
	        }
	        min = maxDefined && min > max ? max : min;
	        max = minDefined && min > max ? min : max;
	        return {
	            min: finiteOrDefault(min, finiteOrDefault(max, min)),
	            max: finiteOrDefault(max, finiteOrDefault(min, max))
	        };
	    }
	 getPadding() {
	        return {
	            left: this.paddingLeft || 0,
	            top: this.paddingTop || 0,
	            right: this.paddingRight || 0,
	            bottom: this.paddingBottom || 0
	        };
	    }
	 getTicks() {
	        return this.ticks;
	    }
	 getLabels() {
	        const data = this.chart.data;
	        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
	    }
	 getLabelItems(chartArea = this.chart.chartArea) {
	        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
	        return items;
	    }
	    beforeLayout() {
	        this._cache = {};
	        this._dataLimitsCached = false;
	    }
	    beforeUpdate() {
	        callback(this.options.beforeUpdate, [
	            this
	        ]);
	    }
	 update(maxWidth, maxHeight, margins) {
	        const { beginAtZero , grace , ticks: tickOpts  } = this.options;
	        const sampleSize = tickOpts.sampleSize;
	        this.beforeUpdate();
	        this.maxWidth = maxWidth;
	        this.maxHeight = maxHeight;
	        this._margins = margins = Object.assign({
	            left: 0,
	            right: 0,
	            top: 0,
	            bottom: 0
	        }, margins);
	        this.ticks = null;
	        this._labelSizes = null;
	        this._gridLineItems = null;
	        this._labelItems = null;
	        this.beforeSetDimensions();
	        this.setDimensions();
	        this.afterSetDimensions();
	        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
	        if (!this._dataLimitsCached) {
	            this.beforeDataLimits();
	            this.determineDataLimits();
	            this.afterDataLimits();
	            this._range = _addGrace(this, grace, beginAtZero);
	            this._dataLimitsCached = true;
	        }
	        this.beforeBuildTicks();
	        this.ticks = this.buildTicks() || [];
	        this.afterBuildTicks();
	        const samplingEnabled = sampleSize < this.ticks.length;
	        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
	        this.configure();
	        this.beforeCalculateLabelRotation();
	        this.calculateLabelRotation();
	        this.afterCalculateLabelRotation();
	        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
	            this.ticks = autoSkip(this, this.ticks);
	            this._labelSizes = null;
	            this.afterAutoSkip();
	        }
	        if (samplingEnabled) {
	            this._convertTicksToLabels(this.ticks);
	        }
	        this.beforeFit();
	        this.fit();
	        this.afterFit();
	        this.afterUpdate();
	    }
	 configure() {
	        let reversePixels = this.options.reverse;
	        let startPixel, endPixel;
	        if (this.isHorizontal()) {
	            startPixel = this.left;
	            endPixel = this.right;
	        } else {
	            startPixel = this.top;
	            endPixel = this.bottom;
	            reversePixels = !reversePixels;
	        }
	        this._startPixel = startPixel;
	        this._endPixel = endPixel;
	        this._reversePixels = reversePixels;
	        this._length = endPixel - startPixel;
	        this._alignToPixels = this.options.alignToPixels;
	    }
	    afterUpdate() {
	        callback(this.options.afterUpdate, [
	            this
	        ]);
	    }
	    beforeSetDimensions() {
	        callback(this.options.beforeSetDimensions, [
	            this
	        ]);
	    }
	    setDimensions() {
	        if (this.isHorizontal()) {
	            this.width = this.maxWidth;
	            this.left = 0;
	            this.right = this.width;
	        } else {
	            this.height = this.maxHeight;
	            this.top = 0;
	            this.bottom = this.height;
	        }
	        this.paddingLeft = 0;
	        this.paddingTop = 0;
	        this.paddingRight = 0;
	        this.paddingBottom = 0;
	    }
	    afterSetDimensions() {
	        callback(this.options.afterSetDimensions, [
	            this
	        ]);
	    }
	    _callHooks(name) {
	        this.chart.notifyPlugins(name, this.getContext());
	        callback(this.options[name], [
	            this
	        ]);
	    }
	    beforeDataLimits() {
	        this._callHooks('beforeDataLimits');
	    }
	    determineDataLimits() {}
	    afterDataLimits() {
	        this._callHooks('afterDataLimits');
	    }
	    beforeBuildTicks() {
	        this._callHooks('beforeBuildTicks');
	    }
	 buildTicks() {
	        return [];
	    }
	    afterBuildTicks() {
	        this._callHooks('afterBuildTicks');
	    }
	    beforeTickToLabelConversion() {
	        callback(this.options.beforeTickToLabelConversion, [
	            this
	        ]);
	    }
	 generateTickLabels(ticks) {
	        const tickOpts = this.options.ticks;
	        let i, ilen, tick;
	        for(i = 0, ilen = ticks.length; i < ilen; i++){
	            tick = ticks[i];
	            tick.label = callback(tickOpts.callback, [
	                tick.value,
	                i,
	                ticks
	            ], this);
	        }
	    }
	    afterTickToLabelConversion() {
	        callback(this.options.afterTickToLabelConversion, [
	            this
	        ]);
	    }
	    beforeCalculateLabelRotation() {
	        callback(this.options.beforeCalculateLabelRotation, [
	            this
	        ]);
	    }
	    calculateLabelRotation() {
	        const options = this.options;
	        const tickOpts = options.ticks;
	        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
	        const minRotation = tickOpts.minRotation || 0;
	        const maxRotation = tickOpts.maxRotation;
	        let labelRotation = minRotation;
	        let tickWidth, maxHeight, maxLabelDiagonal;
	        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
	            this.labelRotation = minRotation;
	            return;
	        }
	        const labelSizes = this._getLabelSizes();
	        const maxLabelWidth = labelSizes.widest.width;
	        const maxLabelHeight = labelSizes.highest.height;
	        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
	        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
	        if (maxLabelWidth + 6 > tickWidth) {
	            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
	            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
	            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
	            labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
	            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
	        }
	        this.labelRotation = labelRotation;
	    }
	    afterCalculateLabelRotation() {
	        callback(this.options.afterCalculateLabelRotation, [
	            this
	        ]);
	    }
	    afterAutoSkip() {}
	    beforeFit() {
	        callback(this.options.beforeFit, [
	            this
	        ]);
	    }
	    fit() {
	        const minSize = {
	            width: 0,
	            height: 0
	        };
	        const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;
	        const display = this._isVisible();
	        const isHorizontal = this.isHorizontal();
	        if (display) {
	            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
	            if (isHorizontal) {
	                minSize.width = this.maxWidth;
	                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
	            } else {
	                minSize.height = this.maxHeight;
	                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
	            }
	            if (tickOpts.display && this.ticks.length) {
	                const { first , last , widest , highest  } = this._getLabelSizes();
	                const tickPadding = tickOpts.padding * 2;
	                const angleRadians = toRadians(this.labelRotation);
	                const cos = Math.cos(angleRadians);
	                const sin = Math.sin(angleRadians);
	                if (isHorizontal) {
	                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
	                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
	                } else {
	                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
	                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
	                }
	                this._calculatePadding(first, last, sin, cos);
	            }
	        }
	        this._handleMargins();
	        if (isHorizontal) {
	            this.width = this._length = chart.width - this._margins.left - this._margins.right;
	            this.height = minSize.height;
	        } else {
	            this.width = minSize.width;
	            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
	        }
	    }
	    _calculatePadding(first, last, sin, cos) {
	        const { ticks: { align , padding  } , position  } = this.options;
	        const isRotated = this.labelRotation !== 0;
	        const labelsBelowTicks = position !== 'top' && this.axis === 'x';
	        if (this.isHorizontal()) {
	            const offsetLeft = this.getPixelForTick(0) - this.left;
	            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
	            let paddingLeft = 0;
	            let paddingRight = 0;
	            if (isRotated) {
	                if (labelsBelowTicks) {
	                    paddingLeft = cos * first.width;
	                    paddingRight = sin * last.height;
	                } else {
	                    paddingLeft = sin * first.height;
	                    paddingRight = cos * last.width;
	                }
	            } else if (align === 'start') {
	                paddingRight = last.width;
	            } else if (align === 'end') {
	                paddingLeft = first.width;
	            } else if (align !== 'inner') {
	                paddingLeft = first.width / 2;
	                paddingRight = last.width / 2;
	            }
	            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
	            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
	        } else {
	            let paddingTop = last.height / 2;
	            let paddingBottom = first.height / 2;
	            if (align === 'start') {
	                paddingTop = 0;
	                paddingBottom = first.height;
	            } else if (align === 'end') {
	                paddingTop = last.height;
	                paddingBottom = 0;
	            }
	            this.paddingTop = paddingTop + padding;
	            this.paddingBottom = paddingBottom + padding;
	        }
	    }
	 _handleMargins() {
	        if (this._margins) {
	            this._margins.left = Math.max(this.paddingLeft, this._margins.left);
	            this._margins.top = Math.max(this.paddingTop, this._margins.top);
	            this._margins.right = Math.max(this.paddingRight, this._margins.right);
	            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
	        }
	    }
	    afterFit() {
	        callback(this.options.afterFit, [
	            this
	        ]);
	    }
	 isHorizontal() {
	        const { axis , position  } = this.options;
	        return position === 'top' || position === 'bottom' || axis === 'x';
	    }
	 isFullSize() {
	        return this.options.fullSize;
	    }
	 _convertTicksToLabels(ticks) {
	        this.beforeTickToLabelConversion();
	        this.generateTickLabels(ticks);
	        let i, ilen;
	        for(i = 0, ilen = ticks.length; i < ilen; i++){
	            if (isNullOrUndef(ticks[i].label)) {
	                ticks.splice(i, 1);
	                ilen--;
	                i--;
	            }
	        }
	        this.afterTickToLabelConversion();
	    }
	 _getLabelSizes() {
	        let labelSizes = this._labelSizes;
	        if (!labelSizes) {
	            const sampleSize = this.options.ticks.sampleSize;
	            let ticks = this.ticks;
	            if (sampleSize < ticks.length) {
	                ticks = sample(ticks, sampleSize);
	            }
	            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
	        }
	        return labelSizes;
	    }
	 _computeLabelSizes(ticks, length, maxTicksLimit) {
	        const { ctx , _longestTextCache: caches  } = this;
	        const widths = [];
	        const heights = [];
	        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
	        let widestLabelSize = 0;
	        let highestLabelSize = 0;
	        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
	        for(i = 0; i < length; i += increment){
	            label = ticks[i].label;
	            tickFont = this._resolveTickFontOptions(i);
	            ctx.font = fontString = tickFont.string;
	            cache = caches[fontString] = caches[fontString] || {
	                data: {},
	                gc: []
	            };
	            lineHeight = tickFont.lineHeight;
	            width = height = 0;
	            if (!isNullOrUndef(label) && !isArray$1(label)) {
	                width = _measureText(ctx, cache.data, cache.gc, width, label);
	                height = lineHeight;
	            } else if (isArray$1(label)) {
	                for(j = 0, jlen = label.length; j < jlen; ++j){
	                    nestedLabel =  label[j];
	                    if (!isNullOrUndef(nestedLabel) && !isArray$1(nestedLabel)) {
	                        width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
	                        height += lineHeight;
	                    }
	                }
	            }
	            widths.push(width);
	            heights.push(height);
	            widestLabelSize = Math.max(width, widestLabelSize);
	            highestLabelSize = Math.max(height, highestLabelSize);
	        }
	        garbageCollect(caches, length);
	        const widest = widths.indexOf(widestLabelSize);
	        const highest = heights.indexOf(highestLabelSize);
	        const valueAt = (idx)=>({
	                width: widths[idx] || 0,
	                height: heights[idx] || 0
	            });
	        return {
	            first: valueAt(0),
	            last: valueAt(length - 1),
	            widest: valueAt(widest),
	            highest: valueAt(highest),
	            widths,
	            heights
	        };
	    }
	 getLabelForValue(value) {
	        return value;
	    }
	 getPixelForValue(value, index) {
	        return NaN;
	    }
	 getValueForPixel(pixel) {}
	 getPixelForTick(index) {
	        const ticks = this.ticks;
	        if (index < 0 || index > ticks.length - 1) {
	            return null;
	        }
	        return this.getPixelForValue(ticks[index].value);
	    }
	 getPixelForDecimal(decimal) {
	        if (this._reversePixels) {
	            decimal = 1 - decimal;
	        }
	        const pixel = this._startPixel + decimal * this._length;
	        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
	    }
	 getDecimalForPixel(pixel) {
	        const decimal = (pixel - this._startPixel) / this._length;
	        return this._reversePixels ? 1 - decimal : decimal;
	    }
	 getBasePixel() {
	        return this.getPixelForValue(this.getBaseValue());
	    }
	 getBaseValue() {
	        const { min , max  } = this;
	        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
	    }
	 getContext(index) {
	        const ticks = this.ticks || [];
	        if (index >= 0 && index < ticks.length) {
	            const tick = ticks[index];
	            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
	        }
	        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
	    }
	 _tickSize() {
	        const optionTicks = this.options.ticks;
	        const rot = toRadians(this.labelRotation);
	        const cos = Math.abs(Math.cos(rot));
	        const sin = Math.abs(Math.sin(rot));
	        const labelSizes = this._getLabelSizes();
	        const padding = optionTicks.autoSkipPadding || 0;
	        const w = labelSizes ? labelSizes.widest.width + padding : 0;
	        const h = labelSizes ? labelSizes.highest.height + padding : 0;
	        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
	    }
	 _isVisible() {
	        const display = this.options.display;
	        if (display !== 'auto') {
	            return !!display;
	        }
	        return this.getMatchingVisibleMetas().length > 0;
	    }
	 _computeGridLineItems(chartArea) {
	        const axis = this.axis;
	        const chart = this.chart;
	        const options = this.options;
	        const { grid , position , border  } = options;
	        const offset = grid.offset;
	        const isHorizontal = this.isHorizontal();
	        const ticks = this.ticks;
	        const ticksLength = ticks.length + (offset ? 1 : 0);
	        const tl = getTickMarkLength(grid);
	        const items = [];
	        const borderOpts = border.setContext(this.getContext());
	        const axisWidth = borderOpts.display ? borderOpts.width : 0;
	        const axisHalfWidth = axisWidth / 2;
	        const alignBorderValue = function(pixel) {
	            return _alignPixel(chart, pixel, axisWidth);
	        };
	        let borderValue, i, lineValue, alignedLineValue;
	        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
	        if (position === 'top') {
	            borderValue = alignBorderValue(this.bottom);
	            ty1 = this.bottom - tl;
	            ty2 = borderValue - axisHalfWidth;
	            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
	            y2 = chartArea.bottom;
	        } else if (position === 'bottom') {
	            borderValue = alignBorderValue(this.top);
	            y1 = chartArea.top;
	            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
	            ty1 = borderValue + axisHalfWidth;
	            ty2 = this.top + tl;
	        } else if (position === 'left') {
	            borderValue = alignBorderValue(this.right);
	            tx1 = this.right - tl;
	            tx2 = borderValue - axisHalfWidth;
	            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
	            x2 = chartArea.right;
	        } else if (position === 'right') {
	            borderValue = alignBorderValue(this.left);
	            x1 = chartArea.left;
	            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
	            tx1 = borderValue + axisHalfWidth;
	            tx2 = this.left + tl;
	        } else if (axis === 'x') {
	            if (position === 'center') {
	                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
	            } else if (isObject$1(position)) {
	                const positionAxisID = Object.keys(position)[0];
	                const value = position[positionAxisID];
	                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
	            }
	            y1 = chartArea.top;
	            y2 = chartArea.bottom;
	            ty1 = borderValue + axisHalfWidth;
	            ty2 = ty1 + tl;
	        } else if (axis === 'y') {
	            if (position === 'center') {
	                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
	            } else if (isObject$1(position)) {
	                const positionAxisID = Object.keys(position)[0];
	                const value = position[positionAxisID];
	                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
	            }
	            tx1 = borderValue - axisHalfWidth;
	            tx2 = tx1 - tl;
	            x1 = chartArea.left;
	            x2 = chartArea.right;
	        }
	        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
	        const step = Math.max(1, Math.ceil(ticksLength / limit));
	        for(i = 0; i < ticksLength; i += step){
	            const context = this.getContext(i);
	            const optsAtIndex = grid.setContext(context);
	            const optsAtIndexBorder = border.setContext(context);
	            const lineWidth = optsAtIndex.lineWidth;
	            const lineColor = optsAtIndex.color;
	            const borderDash = optsAtIndexBorder.dash || [];
	            const borderDashOffset = optsAtIndexBorder.dashOffset;
	            const tickWidth = optsAtIndex.tickWidth;
	            const tickColor = optsAtIndex.tickColor;
	            const tickBorderDash = optsAtIndex.tickBorderDash || [];
	            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
	            lineValue = getPixelForGridLine(this, i, offset);
	            if (lineValue === undefined) {
	                continue;
	            }
	            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
	            if (isHorizontal) {
	                tx1 = tx2 = x1 = x2 = alignedLineValue;
	            } else {
	                ty1 = ty2 = y1 = y2 = alignedLineValue;
	            }
	            items.push({
	                tx1,
	                ty1,
	                tx2,
	                ty2,
	                x1,
	                y1,
	                x2,
	                y2,
	                width: lineWidth,
	                color: lineColor,
	                borderDash,
	                borderDashOffset,
	                tickWidth,
	                tickColor,
	                tickBorderDash,
	                tickBorderDashOffset
	            });
	        }
	        this._ticksLength = ticksLength;
	        this._borderValue = borderValue;
	        return items;
	    }
	 _computeLabelItems(chartArea) {
	        const axis = this.axis;
	        const options = this.options;
	        const { position , ticks: optionTicks  } = options;
	        const isHorizontal = this.isHorizontal();
	        const ticks = this.ticks;
	        const { align , crossAlign , padding , mirror  } = optionTicks;
	        const tl = getTickMarkLength(options.grid);
	        const tickAndPadding = tl + padding;
	        const hTickAndPadding = mirror ? -padding : tickAndPadding;
	        const rotation = -toRadians(this.labelRotation);
	        const items = [];
	        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
	        let textBaseline = 'middle';
	        if (position === 'top') {
	            y = this.bottom - hTickAndPadding;
	            textAlign = this._getXAxisLabelAlignment();
	        } else if (position === 'bottom') {
	            y = this.top + hTickAndPadding;
	            textAlign = this._getXAxisLabelAlignment();
	        } else if (position === 'left') {
	            const ret = this._getYAxisLabelAlignment(tl);
	            textAlign = ret.textAlign;
	            x = ret.x;
	        } else if (position === 'right') {
	            const ret = this._getYAxisLabelAlignment(tl);
	            textAlign = ret.textAlign;
	            x = ret.x;
	        } else if (axis === 'x') {
	            if (position === 'center') {
	                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
	            } else if (isObject$1(position)) {
	                const positionAxisID = Object.keys(position)[0];
	                const value = position[positionAxisID];
	                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
	            }
	            textAlign = this._getXAxisLabelAlignment();
	        } else if (axis === 'y') {
	            if (position === 'center') {
	                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
	            } else if (isObject$1(position)) {
	                const positionAxisID = Object.keys(position)[0];
	                const value = position[positionAxisID];
	                x = this.chart.scales[positionAxisID].getPixelForValue(value);
	            }
	            textAlign = this._getYAxisLabelAlignment(tl).textAlign;
	        }
	        if (axis === 'y') {
	            if (align === 'start') {
	                textBaseline = 'top';
	            } else if (align === 'end') {
	                textBaseline = 'bottom';
	            }
	        }
	        const labelSizes = this._getLabelSizes();
	        for(i = 0, ilen = ticks.length; i < ilen; ++i){
	            tick = ticks[i];
	            label = tick.label;
	            const optsAtIndex = optionTicks.setContext(this.getContext(i));
	            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
	            font = this._resolveTickFontOptions(i);
	            lineHeight = font.lineHeight;
	            lineCount = isArray$1(label) ? label.length : 1;
	            const halfCount = lineCount / 2;
	            const color = optsAtIndex.color;
	            const strokeColor = optsAtIndex.textStrokeColor;
	            const strokeWidth = optsAtIndex.textStrokeWidth;
	            let tickTextAlign = textAlign;
	            if (isHorizontal) {
	                x = pixel;
	                if (textAlign === 'inner') {
	                    if (i === ilen - 1) {
	                        tickTextAlign = !this.options.reverse ? 'right' : 'left';
	                    } else if (i === 0) {
	                        tickTextAlign = !this.options.reverse ? 'left' : 'right';
	                    } else {
	                        tickTextAlign = 'center';
	                    }
	                }
	                if (position === 'top') {
	                    if (crossAlign === 'near' || rotation !== 0) {
	                        textOffset = -lineCount * lineHeight + lineHeight / 2;
	                    } else if (crossAlign === 'center') {
	                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
	                    } else {
	                        textOffset = -labelSizes.highest.height + lineHeight / 2;
	                    }
	                } else {
	                    if (crossAlign === 'near' || rotation !== 0) {
	                        textOffset = lineHeight / 2;
	                    } else if (crossAlign === 'center') {
	                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
	                    } else {
	                        textOffset = labelSizes.highest.height - lineCount * lineHeight;
	                    }
	                }
	                if (mirror) {
	                    textOffset *= -1;
	                }
	                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
	                    x += lineHeight / 2 * Math.sin(rotation);
	                }
	            } else {
	                y = pixel;
	                textOffset = (1 - lineCount) * lineHeight / 2;
	            }
	            let backdrop;
	            if (optsAtIndex.showLabelBackdrop) {
	                const labelPadding = toPadding(optsAtIndex.backdropPadding);
	                const height = labelSizes.heights[i];
	                const width = labelSizes.widths[i];
	                let top = textOffset - labelPadding.top;
	                let left = 0 - labelPadding.left;
	                switch(textBaseline){
	                    case 'middle':
	                        top -= height / 2;
	                        break;
	                    case 'bottom':
	                        top -= height;
	                        break;
	                }
	                switch(textAlign){
	                    case 'center':
	                        left -= width / 2;
	                        break;
	                    case 'right':
	                        left -= width;
	                        break;
	                    case 'inner':
	                        if (i === ilen - 1) {
	                            left -= width;
	                        } else if (i > 0) {
	                            left -= width / 2;
	                        }
	                        break;
	                }
	                backdrop = {
	                    left,
	                    top,
	                    width: width + labelPadding.width,
	                    height: height + labelPadding.height,
	                    color: optsAtIndex.backdropColor
	                };
	            }
	            items.push({
	                label,
	                font,
	                textOffset,
	                options: {
	                    rotation,
	                    color,
	                    strokeColor,
	                    strokeWidth,
	                    textAlign: tickTextAlign,
	                    textBaseline,
	                    translation: [
	                        x,
	                        y
	                    ],
	                    backdrop
	                }
	            });
	        }
	        return items;
	    }
	    _getXAxisLabelAlignment() {
	        const { position , ticks  } = this.options;
	        const rotation = -toRadians(this.labelRotation);
	        if (rotation) {
	            return position === 'top' ? 'left' : 'right';
	        }
	        let align = 'center';
	        if (ticks.align === 'start') {
	            align = 'left';
	        } else if (ticks.align === 'end') {
	            align = 'right';
	        } else if (ticks.align === 'inner') {
	            align = 'inner';
	        }
	        return align;
	    }
	    _getYAxisLabelAlignment(tl) {
	        const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;
	        const labelSizes = this._getLabelSizes();
	        const tickAndPadding = tl + padding;
	        const widest = labelSizes.widest.width;
	        let textAlign;
	        let x;
	        if (position === 'left') {
	            if (mirror) {
	                x = this.right + padding;
	                if (crossAlign === 'near') {
	                    textAlign = 'left';
	                } else if (crossAlign === 'center') {
	                    textAlign = 'center';
	                    x += widest / 2;
	                } else {
	                    textAlign = 'right';
	                    x += widest;
	                }
	            } else {
	                x = this.right - tickAndPadding;
	                if (crossAlign === 'near') {
	                    textAlign = 'right';
	                } else if (crossAlign === 'center') {
	                    textAlign = 'center';
	                    x -= widest / 2;
	                } else {
	                    textAlign = 'left';
	                    x = this.left;
	                }
	            }
	        } else if (position === 'right') {
	            if (mirror) {
	                x = this.left + padding;
	                if (crossAlign === 'near') {
	                    textAlign = 'right';
	                } else if (crossAlign === 'center') {
	                    textAlign = 'center';
	                    x -= widest / 2;
	                } else {
	                    textAlign = 'left';
	                    x -= widest;
	                }
	            } else {
	                x = this.left + tickAndPadding;
	                if (crossAlign === 'near') {
	                    textAlign = 'left';
	                } else if (crossAlign === 'center') {
	                    textAlign = 'center';
	                    x += widest / 2;
	                } else {
	                    textAlign = 'right';
	                    x = this.right;
	                }
	            }
	        } else {
	            textAlign = 'right';
	        }
	        return {
	            textAlign,
	            x
	        };
	    }
	 _computeLabelArea() {
	        if (this.options.ticks.mirror) {
	            return;
	        }
	        const chart = this.chart;
	        const position = this.options.position;
	        if (position === 'left' || position === 'right') {
	            return {
	                top: 0,
	                left: this.left,
	                bottom: chart.height,
	                right: this.right
	            };
	        }
	        if (position === 'top' || position === 'bottom') {
	            return {
	                top: this.top,
	                left: 0,
	                bottom: this.bottom,
	                right: chart.width
	            };
	        }
	    }
	 drawBackground() {
	        const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;
	        if (backgroundColor) {
	            ctx.save();
	            ctx.fillStyle = backgroundColor;
	            ctx.fillRect(left, top, width, height);
	            ctx.restore();
	        }
	    }
	    getLineWidthForValue(value) {
	        const grid = this.options.grid;
	        if (!this._isVisible() || !grid.display) {
	            return 0;
	        }
	        const ticks = this.ticks;
	        const index = ticks.findIndex((t)=>t.value === value);
	        if (index >= 0) {
	            const opts = grid.setContext(this.getContext(index));
	            return opts.lineWidth;
	        }
	        return 0;
	    }
	 drawGrid(chartArea) {
	        const grid = this.options.grid;
	        const ctx = this.ctx;
	        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
	        let i, ilen;
	        const drawLine = (p1, p2, style)=>{
	            if (!style.width || !style.color) {
	                return;
	            }
	            ctx.save();
	            ctx.lineWidth = style.width;
	            ctx.strokeStyle = style.color;
	            ctx.setLineDash(style.borderDash || []);
	            ctx.lineDashOffset = style.borderDashOffset;
	            ctx.beginPath();
	            ctx.moveTo(p1.x, p1.y);
	            ctx.lineTo(p2.x, p2.y);
	            ctx.stroke();
	            ctx.restore();
	        };
	        if (grid.display) {
	            for(i = 0, ilen = items.length; i < ilen; ++i){
	                const item = items[i];
	                if (grid.drawOnChartArea) {
	                    drawLine({
	                        x: item.x1,
	                        y: item.y1
	                    }, {
	                        x: item.x2,
	                        y: item.y2
	                    }, item);
	                }
	                if (grid.drawTicks) {
	                    drawLine({
	                        x: item.tx1,
	                        y: item.ty1
	                    }, {
	                        x: item.tx2,
	                        y: item.ty2
	                    }, {
	                        color: item.tickColor,
	                        width: item.tickWidth,
	                        borderDash: item.tickBorderDash,
	                        borderDashOffset: item.tickBorderDashOffset
	                    });
	                }
	            }
	        }
	    }
	 drawBorder() {
	        const { chart , ctx , options: { border , grid  }  } = this;
	        const borderOpts = border.setContext(this.getContext());
	        const axisWidth = border.display ? borderOpts.width : 0;
	        if (!axisWidth) {
	            return;
	        }
	        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
	        const borderValue = this._borderValue;
	        let x1, x2, y1, y2;
	        if (this.isHorizontal()) {
	            x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
	            x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
	            y1 = y2 = borderValue;
	        } else {
	            y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
	            y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
	            x1 = x2 = borderValue;
	        }
	        ctx.save();
	        ctx.lineWidth = borderOpts.width;
	        ctx.strokeStyle = borderOpts.color;
	        ctx.beginPath();
	        ctx.moveTo(x1, y1);
	        ctx.lineTo(x2, y2);
	        ctx.stroke();
	        ctx.restore();
	    }
	 drawLabels(chartArea) {
	        const optionTicks = this.options.ticks;
	        if (!optionTicks.display) {
	            return;
	        }
	        const ctx = this.ctx;
	        const area = this._computeLabelArea();
	        if (area) {
	            clipArea(ctx, area);
	        }
	        const items = this.getLabelItems(chartArea);
	        for (const item of items){
	            const renderTextOptions = item.options;
	            const tickFont = item.font;
	            const label = item.label;
	            const y = item.textOffset;
	            renderText(ctx, label, 0, y, tickFont, renderTextOptions);
	        }
	        if (area) {
	            unclipArea(ctx);
	        }
	    }
	 drawTitle() {
	        const { ctx , options: { position , title , reverse  }  } = this;
	        if (!title.display) {
	            return;
	        }
	        const font = toFont(title.font);
	        const padding = toPadding(title.padding);
	        const align = title.align;
	        let offset = font.lineHeight / 2;
	        if (position === 'bottom' || position === 'center' || isObject$1(position)) {
	            offset += padding.bottom;
	            if (isArray$1(title.text)) {
	                offset += font.lineHeight * (title.text.length - 1);
	            }
	        } else {
	            offset += padding.top;
	        }
	        const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);
	        renderText(ctx, title.text, 0, 0, font, {
	            color: title.color,
	            maxWidth,
	            rotation,
	            textAlign: titleAlign(align, position, reverse),
	            textBaseline: 'middle',
	            translation: [
	                titleX,
	                titleY
	            ]
	        });
	    }
	    draw(chartArea) {
	        if (!this._isVisible()) {
	            return;
	        }
	        this.drawBackground();
	        this.drawGrid(chartArea);
	        this.drawBorder();
	        this.drawTitle();
	        this.drawLabels(chartArea);
	    }
	 _layers() {
	        const opts = this.options;
	        const tz = opts.ticks && opts.ticks.z || 0;
	        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
	        const bz = valueOrDefault(opts.border && opts.border.z, 0);
	        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
	            return [
	                {
	                    z: tz,
	                    draw: (chartArea)=>{
	                        this.draw(chartArea);
	                    }
	                }
	            ];
	        }
	        return [
	            {
	                z: gz,
	                draw: (chartArea)=>{
	                    this.drawBackground();
	                    this.drawGrid(chartArea);
	                    this.drawTitle();
	                }
	            },
	            {
	                z: bz,
	                draw: ()=>{
	                    this.drawBorder();
	                }
	            },
	            {
	                z: tz,
	                draw: (chartArea)=>{
	                    this.drawLabels(chartArea);
	                }
	            }
	        ];
	    }
	 getMatchingVisibleMetas(type) {
	        const metas = this.chart.getSortedVisibleDatasetMetas();
	        const axisID = this.axis + 'AxisID';
	        const result = [];
	        let i, ilen;
	        for(i = 0, ilen = metas.length; i < ilen; ++i){
	            const meta = metas[i];
	            if (meta[axisID] === this.id && (!type || meta.type === type)) {
	                result.push(meta);
	            }
	        }
	        return result;
	    }
	 _resolveTickFontOptions(index) {
	        const opts = this.options.ticks.setContext(this.getContext(index));
	        return toFont(opts.font);
	    }
	 _maxDigits() {
	        const fontSize = this._resolveTickFontOptions(0).lineHeight;
	        return (this.isHorizontal() ? this.width : this.height) / fontSize;
	    }
	}

	class TypedRegistry {
	    constructor(type, scope, override){
	        this.type = type;
	        this.scope = scope;
	        this.override = override;
	        this.items = Object.create(null);
	    }
	    isForType(type) {
	        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
	    }
	 register(item) {
	        const proto = Object.getPrototypeOf(item);
	        let parentScope;
	        if (isIChartComponent(proto)) {
	            parentScope = this.register(proto);
	        }
	        const items = this.items;
	        const id = item.id;
	        const scope = this.scope + '.' + id;
	        if (!id) {
	            throw new Error('class does not have id: ' + item);
	        }
	        if (id in items) {
	            return scope;
	        }
	        items[id] = item;
	        registerDefaults(item, scope, parentScope);
	        if (this.override) {
	            defaults.override(item.id, item.overrides);
	        }
	        return scope;
	    }
	 get(id) {
	        return this.items[id];
	    }
	 unregister(item) {
	        const items = this.items;
	        const id = item.id;
	        const scope = this.scope;
	        if (id in items) {
	            delete items[id];
	        }
	        if (scope && id in defaults[scope]) {
	            delete defaults[scope][id];
	            if (this.override) {
	                delete overrides[id];
	            }
	        }
	    }
	}
	function registerDefaults(item, scope, parentScope) {
	    const itemDefaults = merge(Object.create(null), [
	        parentScope ? defaults.get(parentScope) : {},
	        defaults.get(scope),
	        item.defaults
	    ]);
	    defaults.set(scope, itemDefaults);
	    if (item.defaultRoutes) {
	        routeDefaults(scope, item.defaultRoutes);
	    }
	    if (item.descriptors) {
	        defaults.describe(scope, item.descriptors);
	    }
	}
	function routeDefaults(scope, routes) {
	    Object.keys(routes).forEach((property)=>{
	        const propertyParts = property.split('.');
	        const sourceName = propertyParts.pop();
	        const sourceScope = [
	            scope
	        ].concat(propertyParts).join('.');
	        const parts = routes[property].split('.');
	        const targetName = parts.pop();
	        const targetScope = parts.join('.');
	        defaults.route(sourceScope, sourceName, targetScope, targetName);
	    });
	}
	function isIChartComponent(proto) {
	    return 'id' in proto && 'defaults' in proto;
	}

	class Registry {
	    constructor(){
	        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
	        this.elements = new TypedRegistry(Element, 'elements');
	        this.plugins = new TypedRegistry(Object, 'plugins');
	        this.scales = new TypedRegistry(Scale, 'scales');
	        this._typedRegistries = [
	            this.controllers,
	            this.scales,
	            this.elements
	        ];
	    }
	 add(...args) {
	        this._each('register', args);
	    }
	    remove(...args) {
	        this._each('unregister', args);
	    }
	 addControllers(...args) {
	        this._each('register', args, this.controllers);
	    }
	 addElements(...args) {
	        this._each('register', args, this.elements);
	    }
	 addPlugins(...args) {
	        this._each('register', args, this.plugins);
	    }
	 addScales(...args) {
	        this._each('register', args, this.scales);
	    }
	 getController(id) {
	        return this._get(id, this.controllers, 'controller');
	    }
	 getElement(id) {
	        return this._get(id, this.elements, 'element');
	    }
	 getPlugin(id) {
	        return this._get(id, this.plugins, 'plugin');
	    }
	 getScale(id) {
	        return this._get(id, this.scales, 'scale');
	    }
	 removeControllers(...args) {
	        this._each('unregister', args, this.controllers);
	    }
	 removeElements(...args) {
	        this._each('unregister', args, this.elements);
	    }
	 removePlugins(...args) {
	        this._each('unregister', args, this.plugins);
	    }
	 removeScales(...args) {
	        this._each('unregister', args, this.scales);
	    }
	 _each(method, args, typedRegistry) {
	        [
	            ...args
	        ].forEach((arg)=>{
	            const reg = typedRegistry || this._getRegistryForType(arg);
	            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
	                this._exec(method, reg, arg);
	            } else {
	                each(arg, (item)=>{
	                    const itemReg = typedRegistry || this._getRegistryForType(item);
	                    this._exec(method, itemReg, item);
	                });
	            }
	        });
	    }
	 _exec(method, registry, component) {
	        const camelMethod = _capitalize(method);
	        callback(component['before' + camelMethod], [], component);
	        registry[method](component);
	        callback(component['after' + camelMethod], [], component);
	    }
	 _getRegistryForType(type) {
	        for(let i = 0; i < this._typedRegistries.length; i++){
	            const reg = this._typedRegistries[i];
	            if (reg.isForType(type)) {
	                return reg;
	            }
	        }
	        return this.plugins;
	    }
	 _get(id, typedRegistry, type) {
	        const item = typedRegistry.get(id);
	        if (item === undefined) {
	            throw new Error('"' + id + '" is not a registered ' + type + '.');
	        }
	        return item;
	    }
	}
	var registry = /* #__PURE__ */ new Registry();

	class PluginService {
	    constructor(){
	        this._init = [];
	    }
	 notify(chart, hook, args, filter) {
	        if (hook === 'beforeInit') {
	            this._init = this._createDescriptors(chart, true);
	            this._notify(this._init, chart, 'install');
	        }
	        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
	        const result = this._notify(descriptors, chart, hook, args);
	        if (hook === 'afterDestroy') {
	            this._notify(descriptors, chart, 'stop');
	            this._notify(this._init, chart, 'uninstall');
	        }
	        return result;
	    }
	 _notify(descriptors, chart, hook, args) {
	        args = args || {};
	        for (const descriptor of descriptors){
	            const plugin = descriptor.plugin;
	            const method = plugin[hook];
	            const params = [
	                chart,
	                args,
	                descriptor.options
	            ];
	            if (callback(method, params, plugin) === false && args.cancelable) {
	                return false;
	            }
	        }
	        return true;
	    }
	    invalidate() {
	        if (!isNullOrUndef(this._cache)) {
	            this._oldCache = this._cache;
	            this._cache = undefined;
	        }
	    }
	 _descriptors(chart) {
	        if (this._cache) {
	            return this._cache;
	        }
	        const descriptors = this._cache = this._createDescriptors(chart);
	        this._notifyStateChanges(chart);
	        return descriptors;
	    }
	    _createDescriptors(chart, all) {
	        const config = chart && chart.config;
	        const options = valueOrDefault(config.options && config.options.plugins, {});
	        const plugins = allPlugins(config);
	        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
	    }
	 _notifyStateChanges(chart) {
	        const previousDescriptors = this._oldCache || [];
	        const descriptors = this._cache;
	        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));
	        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
	        this._notify(diff(descriptors, previousDescriptors), chart, 'start');
	    }
	}
	 function allPlugins(config) {
	    const localIds = {};
	    const plugins = [];
	    const keys = Object.keys(registry.plugins.items);
	    for(let i = 0; i < keys.length; i++){
	        plugins.push(registry.getPlugin(keys[i]));
	    }
	    const local = config.plugins || [];
	    for(let i = 0; i < local.length; i++){
	        const plugin = local[i];
	        if (plugins.indexOf(plugin) === -1) {
	            plugins.push(plugin);
	            localIds[plugin.id] = true;
	        }
	    }
	    return {
	        plugins,
	        localIds
	    };
	}
	function getOpts(options, all) {
	    if (!all && options === false) {
	        return null;
	    }
	    if (options === true) {
	        return {};
	    }
	    return options;
	}
	function createDescriptors(chart, { plugins , localIds  }, options, all) {
	    const result = [];
	    const context = chart.getContext();
	    for (const plugin of plugins){
	        const id = plugin.id;
	        const opts = getOpts(options[id], all);
	        if (opts === null) {
	            continue;
	        }
	        result.push({
	            plugin,
	            options: pluginOpts(chart.config, {
	                plugin,
	                local: localIds[id]
	            }, opts, context)
	        });
	    }
	    return result;
	}
	function pluginOpts(config, { plugin , local  }, opts, context) {
	    const keys = config.pluginScopeKeys(plugin);
	    const scopes = config.getOptionScopes(opts, keys);
	    if (local && plugin.defaults) {
	        scopes.push(plugin.defaults);
	    }
	    return config.createResolver(scopes, context, [
	        ''
	    ], {
	        scriptable: false,
	        indexable: false,
	        allKeys: true
	    });
	}

	function getIndexAxis(type, options) {
	    const datasetDefaults = defaults.datasets[type] || {};
	    const datasetOptions = (options.datasets || {})[type] || {};
	    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
	}
	function getAxisFromDefaultScaleID(id, indexAxis) {
	    let axis = id;
	    if (id === '_index_') {
	        axis = indexAxis;
	    } else if (id === '_value_') {
	        axis = indexAxis === 'x' ? 'y' : 'x';
	    }
	    return axis;
	}
	function getDefaultScaleIDFromAxis(axis, indexAxis) {
	    return axis === indexAxis ? '_index_' : '_value_';
	}
	function idMatchesAxis(id) {
	    if (id === 'x' || id === 'y' || id === 'r') {
	        return id;
	    }
	}
	function axisFromPosition(position) {
	    if (position === 'top' || position === 'bottom') {
	        return 'x';
	    }
	    if (position === 'left' || position === 'right') {
	        return 'y';
	    }
	}
	function determineAxis(id, ...scaleOptions) {
	    if (idMatchesAxis(id)) {
	        return id;
	    }
	    for (const opts of scaleOptions){
	        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
	        if (axis) {
	            return axis;
	        }
	    }
	    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
	}
	function getAxisFromDataset(id, axis, dataset) {
	    if (dataset[axis + 'AxisID'] === id) {
	        return {
	            axis
	        };
	    }
	}
	function retrieveAxisFromDatasets(id, config) {
	    if (config.data && config.data.datasets) {
	        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);
	        if (boundDs.length) {
	            return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);
	        }
	    }
	    return {};
	}
	function mergeScaleConfig(config, options) {
	    const chartDefaults = overrides[config.type] || {
	        scales: {}
	    };
	    const configScales = options.scales || {};
	    const chartIndexAxis = getIndexAxis(config.type, options);
	    const scales = Object.create(null);
	    Object.keys(configScales).forEach((id)=>{
	        const scaleConf = configScales[id];
	        if (!isObject$1(scaleConf)) {
	            return console.error(`Invalid scale configuration for scale: ${id}`);
	        }
	        if (scaleConf._proxy) {
	            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
	        }
	        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
	        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
	        const defaultScaleOptions = chartDefaults.scales || {};
	        scales[id] = mergeIf(Object.create(null), [
	            {
	                axis
	            },
	            scaleConf,
	            defaultScaleOptions[axis],
	            defaultScaleOptions[defaultId]
	        ]);
	    });
	    config.data.datasets.forEach((dataset)=>{
	        const type = dataset.type || config.type;
	        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
	        const datasetDefaults = overrides[type] || {};
	        const defaultScaleOptions = datasetDefaults.scales || {};
	        Object.keys(defaultScaleOptions).forEach((defaultID)=>{
	            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
	            const id = dataset[axis + 'AxisID'] || axis;
	            scales[id] = scales[id] || Object.create(null);
	            mergeIf(scales[id], [
	                {
	                    axis
	                },
	                configScales[id],
	                defaultScaleOptions[defaultID]
	            ]);
	        });
	    });
	    Object.keys(scales).forEach((key)=>{
	        const scale = scales[key];
	        mergeIf(scale, [
	            defaults.scales[scale.type],
	            defaults.scale
	        ]);
	    });
	    return scales;
	}
	function initOptions(config) {
	    const options = config.options || (config.options = {});
	    options.plugins = valueOrDefault(options.plugins, {});
	    options.scales = mergeScaleConfig(config, options);
	}
	function initData(data) {
	    data = data || {};
	    data.datasets = data.datasets || [];
	    data.labels = data.labels || [];
	    return data;
	}
	function initConfig(config) {
	    config = config || {};
	    config.data = initData(config.data);
	    initOptions(config);
	    return config;
	}
	const keyCache = new Map();
	const keysCached = new Set();
	function cachedKeys(cacheKey, generate) {
	    let keys = keyCache.get(cacheKey);
	    if (!keys) {
	        keys = generate();
	        keyCache.set(cacheKey, keys);
	        keysCached.add(keys);
	    }
	    return keys;
	}
	const addIfFound = (set, obj, key)=>{
	    const opts = resolveObjectKey(obj, key);
	    if (opts !== undefined) {
	        set.add(opts);
	    }
	};
	class Config {
	    constructor(config){
	        this._config = initConfig(config);
	        this._scopeCache = new Map();
	        this._resolverCache = new Map();
	    }
	    get platform() {
	        return this._config.platform;
	    }
	    get type() {
	        return this._config.type;
	    }
	    set type(type) {
	        this._config.type = type;
	    }
	    get data() {
	        return this._config.data;
	    }
	    set data(data) {
	        this._config.data = initData(data);
	    }
	    get options() {
	        return this._config.options;
	    }
	    set options(options) {
	        this._config.options = options;
	    }
	    get plugins() {
	        return this._config.plugins;
	    }
	    update() {
	        const config = this._config;
	        this.clearCache();
	        initOptions(config);
	    }
	    clearCache() {
	        this._scopeCache.clear();
	        this._resolverCache.clear();
	    }
	 datasetScopeKeys(datasetType) {
	        return cachedKeys(datasetType, ()=>[
	                [
	                    `datasets.${datasetType}`,
	                    ''
	                ]
	            ]);
	    }
	 datasetAnimationScopeKeys(datasetType, transition) {
	        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[
	                [
	                    `datasets.${datasetType}.transitions.${transition}`,
	                    `transitions.${transition}`
	                ],
	                [
	                    `datasets.${datasetType}`,
	                    ''
	                ]
	            ]);
	    }
	 datasetElementScopeKeys(datasetType, elementType) {
	        return cachedKeys(`${datasetType}-${elementType}`, ()=>[
	                [
	                    `datasets.${datasetType}.elements.${elementType}`,
	                    `datasets.${datasetType}`,
	                    `elements.${elementType}`,
	                    ''
	                ]
	            ]);
	    }
	 pluginScopeKeys(plugin) {
	        const id = plugin.id;
	        const type = this.type;
	        return cachedKeys(`${type}-plugin-${id}`, ()=>[
	                [
	                    `plugins.${id}`,
	                    ...plugin.additionalOptionScopes || []
	                ]
	            ]);
	    }
	 _cachedScopes(mainScope, resetCache) {
	        const _scopeCache = this._scopeCache;
	        let cache = _scopeCache.get(mainScope);
	        if (!cache || resetCache) {
	            cache = new Map();
	            _scopeCache.set(mainScope, cache);
	        }
	        return cache;
	    }
	 getOptionScopes(mainScope, keyLists, resetCache) {
	        const { options , type  } = this;
	        const cache = this._cachedScopes(mainScope, resetCache);
	        const cached = cache.get(keyLists);
	        if (cached) {
	            return cached;
	        }
	        const scopes = new Set();
	        keyLists.forEach((keys)=>{
	            if (mainScope) {
	                scopes.add(mainScope);
	                keys.forEach((key)=>addIfFound(scopes, mainScope, key));
	            }
	            keys.forEach((key)=>addIfFound(scopes, options, key));
	            keys.forEach((key)=>addIfFound(scopes, overrides[type] || {}, key));
	            keys.forEach((key)=>addIfFound(scopes, defaults, key));
	            keys.forEach((key)=>addIfFound(scopes, descriptors, key));
	        });
	        const array = Array.from(scopes);
	        if (array.length === 0) {
	            array.push(Object.create(null));
	        }
	        if (keysCached.has(keyLists)) {
	            cache.set(keyLists, array);
	        }
	        return array;
	    }
	 chartOptionScopes() {
	        const { options , type  } = this;
	        return [
	            options,
	            overrides[type] || {},
	            defaults.datasets[type] || {},
	            {
	                type
	            },
	            defaults,
	            descriptors
	        ];
	    }
	 resolveNamedOptions(scopes, names, context, prefixes = [
	        ''
	    ]) {
	        const result = {
	            $shared: true
	        };
	        const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);
	        let options = resolver;
	        if (needContext(resolver, names)) {
	            result.$shared = false;
	            context = isFunction$1(context) ? context() : context;
	            const subResolver = this.createResolver(scopes, context, subPrefixes);
	            options = _attachContext(resolver, context, subResolver);
	        }
	        for (const prop of names){
	            result[prop] = options[prop];
	        }
	        return result;
	    }
	 createResolver(scopes, context, prefixes = [
	        ''
	    ], descriptorDefaults) {
	        const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);
	        return isObject$1(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;
	    }
	}
	function getResolver(resolverCache, scopes, prefixes) {
	    let cache = resolverCache.get(scopes);
	    if (!cache) {
	        cache = new Map();
	        resolverCache.set(scopes, cache);
	    }
	    const cacheKey = prefixes.join();
	    let cached = cache.get(cacheKey);
	    if (!cached) {
	        const resolver = _createResolver(scopes, prefixes);
	        cached = {
	            resolver,
	            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))
	        };
	        cache.set(cacheKey, cached);
	    }
	    return cached;
	}
	const hasFunction = (value)=>isObject$1(value) && Object.getOwnPropertyNames(value).some((key)=>isFunction$1(value[key]));
	function needContext(proxy, names) {
	    const { isScriptable , isIndexable  } = _descriptors(proxy);
	    for (const prop of names){
	        const scriptable = isScriptable(prop);
	        const indexable = isIndexable(prop);
	        const value = (indexable || scriptable) && proxy[prop];
	        if (scriptable && (isFunction$1(value) || hasFunction(value)) || indexable && isArray$1(value)) {
	            return true;
	        }
	    }
	    return false;
	}

	var version = "4.4.4";

	const KNOWN_POSITIONS = [
	    'top',
	    'bottom',
	    'left',
	    'right',
	    'chartArea'
	];
	function positionIsHorizontal(position, axis) {
	    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';
	}
	function compare2Level(l1, l2) {
	    return function(a, b) {
	        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
	    };
	}
	function onAnimationsComplete(context) {
	    const chart = context.chart;
	    const animationOptions = chart.options.animation;
	    chart.notifyPlugins('afterRender');
	    callback(animationOptions && animationOptions.onComplete, [
	        context
	    ], chart);
	}
	function onAnimationProgress(context) {
	    const chart = context.chart;
	    const animationOptions = chart.options.animation;
	    callback(animationOptions && animationOptions.onProgress, [
	        context
	    ], chart);
	}
	 function getCanvas(item) {
	    if (_isDomSupported() && typeof item === 'string') {
	        item = document.getElementById(item);
	    } else if (item && item.length) {
	        item = item[0];
	    }
	    if (item && item.canvas) {
	        item = item.canvas;
	    }
	    return item;
	}
	const instances = {};
	const getChart = (key)=>{
	    const canvas = getCanvas(key);
	    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();
	};
	function moveNumericKeys(obj, start, move) {
	    const keys = Object.keys(obj);
	    for (const key of keys){
	        const intKey = +key;
	        if (intKey >= start) {
	            const value = obj[key];
	            delete obj[key];
	            if (move > 0 || intKey > start) {
	                obj[intKey + move] = value;
	            }
	        }
	    }
	}
	 function determineLastEvent(e, lastEvent, inChartArea, isClick) {
	    if (!inChartArea || e.type === 'mouseout') {
	        return null;
	    }
	    if (isClick) {
	        return lastEvent;
	    }
	    return e;
	}
	function getSizeForArea(scale, chartArea, field) {
	    return scale.options.clip ? scale[field] : chartArea[field];
	}
	function getDatasetArea(meta, chartArea) {
	    const { xScale , yScale  } = meta;
	    if (xScale && yScale) {
	        return {
	            left: getSizeForArea(xScale, chartArea, 'left'),
	            right: getSizeForArea(xScale, chartArea, 'right'),
	            top: getSizeForArea(yScale, chartArea, 'top'),
	            bottom: getSizeForArea(yScale, chartArea, 'bottom')
	        };
	    }
	    return chartArea;
	}
	class Chart {
	    static defaults = defaults;
	    static instances = instances;
	    static overrides = overrides;
	    static registry = registry;
	    static version = version;
	    static getChart = getChart;
	    static register(...items) {
	        registry.add(...items);
	        invalidatePlugins();
	    }
	    static unregister(...items) {
	        registry.remove(...items);
	        invalidatePlugins();
	    }
	    constructor(item, userConfig){
	        const config = this.config = new Config(userConfig);
	        const initialCanvas = getCanvas(item);
	        const existingChart = getChart(initialCanvas);
	        if (existingChart) {
	            throw new Error('Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' + ' must be destroyed before the canvas with ID \'' + existingChart.canvas.id + '\' can be reused.');
	        }
	        const options = config.createResolver(config.chartOptionScopes(), this.getContext());
	        this.platform = new (config.platform || _detectPlatform(initialCanvas))();
	        this.platform.updateConfig(config);
	        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
	        const canvas = context && context.canvas;
	        const height = canvas && canvas.height;
	        const width = canvas && canvas.width;
	        this.id = uid();
	        this.ctx = context;
	        this.canvas = canvas;
	        this.width = width;
	        this.height = height;
	        this._options = options;
	        this._aspectRatio = this.aspectRatio;
	        this._layers = [];
	        this._metasets = [];
	        this._stacks = undefined;
	        this.boxes = [];
	        this.currentDevicePixelRatio = undefined;
	        this.chartArea = undefined;
	        this._active = [];
	        this._lastEvent = undefined;
	        this._listeners = {};
	         this._responsiveListeners = undefined;
	        this._sortedMetasets = [];
	        this.scales = {};
	        this._plugins = new PluginService();
	        this.$proxies = {};
	        this._hiddenIndices = {};
	        this.attached = false;
	        this._animationsDisabled = undefined;
	        this.$context = undefined;
	        this._doResize = debounce((mode)=>this.update(mode), options.resizeDelay || 0);
	        this._dataChanges = [];
	        instances[this.id] = this;
	        if (!context || !canvas) {
	            console.error("Failed to create chart: can't acquire context from the given item");
	            return;
	        }
	        animator.listen(this, 'complete', onAnimationsComplete);
	        animator.listen(this, 'progress', onAnimationProgress);
	        this._initialize();
	        if (this.attached) {
	            this.update();
	        }
	    }
	    get aspectRatio() {
	        const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;
	        if (!isNullOrUndef(aspectRatio)) {
	            return aspectRatio;
	        }
	        if (maintainAspectRatio && _aspectRatio) {
	            return _aspectRatio;
	        }
	        return height ? width / height : null;
	    }
	    get data() {
	        return this.config.data;
	    }
	    set data(data) {
	        this.config.data = data;
	    }
	    get options() {
	        return this._options;
	    }
	    set options(options) {
	        this.config.options = options;
	    }
	    get registry() {
	        return registry;
	    }
	 _initialize() {
	        this.notifyPlugins('beforeInit');
	        if (this.options.responsive) {
	            this.resize();
	        } else {
	            retinaScale(this, this.options.devicePixelRatio);
	        }
	        this.bindEvents();
	        this.notifyPlugins('afterInit');
	        return this;
	    }
	    clear() {
	        clearCanvas(this.canvas, this.ctx);
	        return this;
	    }
	    stop() {
	        animator.stop(this);
	        return this;
	    }
	 resize(width, height) {
	        if (!animator.running(this)) {
	            this._resize(width, height);
	        } else {
	            this._resizeBeforeDraw = {
	                width,
	                height
	            };
	        }
	    }
	    _resize(width, height) {
	        const options = this.options;
	        const canvas = this.canvas;
	        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
	        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
	        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
	        const mode = this.width ? 'resize' : 'attach';
	        this.width = newSize.width;
	        this.height = newSize.height;
	        this._aspectRatio = this.aspectRatio;
	        if (!retinaScale(this, newRatio, true)) {
	            return;
	        }
	        this.notifyPlugins('resize', {
	            size: newSize
	        });
	        callback(options.onResize, [
	            this,
	            newSize
	        ], this);
	        if (this.attached) {
	            if (this._doResize(mode)) {
	                this.render();
	            }
	        }
	    }
	    ensureScalesHaveIDs() {
	        const options = this.options;
	        const scalesOptions = options.scales || {};
	        each(scalesOptions, (axisOptions, axisID)=>{
	            axisOptions.id = axisID;
	        });
	    }
	 buildOrUpdateScales() {
	        const options = this.options;
	        const scaleOpts = options.scales;
	        const scales = this.scales;
	        const updated = Object.keys(scales).reduce((obj, id)=>{
	            obj[id] = false;
	            return obj;
	        }, {});
	        let items = [];
	        if (scaleOpts) {
	            items = items.concat(Object.keys(scaleOpts).map((id)=>{
	                const scaleOptions = scaleOpts[id];
	                const axis = determineAxis(id, scaleOptions);
	                const isRadial = axis === 'r';
	                const isHorizontal = axis === 'x';
	                return {
	                    options: scaleOptions,
	                    dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
	                    dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
	                };
	            }));
	        }
	        each(items, (item)=>{
	            const scaleOptions = item.options;
	            const id = scaleOptions.id;
	            const axis = determineAxis(id, scaleOptions);
	            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
	            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
	                scaleOptions.position = item.dposition;
	            }
	            updated[id] = true;
	            let scale = null;
	            if (id in scales && scales[id].type === scaleType) {
	                scale = scales[id];
	            } else {
	                const scaleClass = registry.getScale(scaleType);
	                scale = new scaleClass({
	                    id,
	                    type: scaleType,
	                    ctx: this.ctx,
	                    chart: this
	                });
	                scales[scale.id] = scale;
	            }
	            scale.init(scaleOptions, options);
	        });
	        each(updated, (hasUpdated, id)=>{
	            if (!hasUpdated) {
	                delete scales[id];
	            }
	        });
	        each(scales, (scale)=>{
	            layouts.configure(this, scale, scale.options);
	            layouts.addBox(this, scale);
	        });
	    }
	 _updateMetasets() {
	        const metasets = this._metasets;
	        const numData = this.data.datasets.length;
	        const numMeta = metasets.length;
	        metasets.sort((a, b)=>a.index - b.index);
	        if (numMeta > numData) {
	            for(let i = numData; i < numMeta; ++i){
	                this._destroyDatasetMeta(i);
	            }
	            metasets.splice(numData, numMeta - numData);
	        }
	        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
	    }
	 _removeUnreferencedMetasets() {
	        const { _metasets: metasets , data: { datasets  }  } = this;
	        if (metasets.length > datasets.length) {
	            delete this._stacks;
	        }
	        metasets.forEach((meta, index)=>{
	            if (datasets.filter((x)=>x === meta._dataset).length === 0) {
	                this._destroyDatasetMeta(index);
	            }
	        });
	    }
	    buildOrUpdateControllers() {
	        const newControllers = [];
	        const datasets = this.data.datasets;
	        let i, ilen;
	        this._removeUnreferencedMetasets();
	        for(i = 0, ilen = datasets.length; i < ilen; i++){
	            const dataset = datasets[i];
	            let meta = this.getDatasetMeta(i);
	            const type = dataset.type || this.config.type;
	            if (meta.type && meta.type !== type) {
	                this._destroyDatasetMeta(i);
	                meta = this.getDatasetMeta(i);
	            }
	            meta.type = type;
	            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
	            meta.order = dataset.order || 0;
	            meta.index = i;
	            meta.label = '' + dataset.label;
	            meta.visible = this.isDatasetVisible(i);
	            if (meta.controller) {
	                meta.controller.updateIndex(i);
	                meta.controller.linkScales();
	            } else {
	                const ControllerClass = registry.getController(type);
	                const { datasetElementType , dataElementType  } = defaults.datasets[type];
	                Object.assign(ControllerClass, {
	                    dataElementType: registry.getElement(dataElementType),
	                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)
	                });
	                meta.controller = new ControllerClass(this, i);
	                newControllers.push(meta.controller);
	            }
	        }
	        this._updateMetasets();
	        return newControllers;
	    }
	 _resetElements() {
	        each(this.data.datasets, (dataset, datasetIndex)=>{
	            this.getDatasetMeta(datasetIndex).controller.reset();
	        }, this);
	    }
	 reset() {
	        this._resetElements();
	        this.notifyPlugins('reset');
	    }
	    update(mode) {
	        const config = this.config;
	        config.update();
	        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
	        const animsDisabled = this._animationsDisabled = !options.animation;
	        this._updateScales();
	        this._checkEventBindings();
	        this._updateHiddenIndices();
	        this._plugins.invalidate();
	        if (this.notifyPlugins('beforeUpdate', {
	            mode,
	            cancelable: true
	        }) === false) {
	            return;
	        }
	        const newControllers = this.buildOrUpdateControllers();
	        this.notifyPlugins('beforeElementsUpdate');
	        let minPadding = 0;
	        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){
	            const { controller  } = this.getDatasetMeta(i);
	            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
	            controller.buildOrUpdateElements(reset);
	            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
	        }
	        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
	        this._updateLayout(minPadding);
	        if (!animsDisabled) {
	            each(newControllers, (controller)=>{
	                controller.reset();
	            });
	        }
	        this._updateDatasets(mode);
	        this.notifyPlugins('afterUpdate', {
	            mode
	        });
	        this._layers.sort(compare2Level('z', '_idx'));
	        const { _active , _lastEvent  } = this;
	        if (_lastEvent) {
	            this._eventHandler(_lastEvent, true);
	        } else if (_active.length) {
	            this._updateHoverStyles(_active, _active, true);
	        }
	        this.render();
	    }
	 _updateScales() {
	        each(this.scales, (scale)=>{
	            layouts.removeBox(this, scale);
	        });
	        this.ensureScalesHaveIDs();
	        this.buildOrUpdateScales();
	    }
	 _checkEventBindings() {
	        const options = this.options;
	        const existingEvents = new Set(Object.keys(this._listeners));
	        const newEvents = new Set(options.events);
	        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
	            this.unbindEvents();
	            this.bindEvents();
	        }
	    }
	 _updateHiddenIndices() {
	        const { _hiddenIndices  } = this;
	        const changes = this._getUniformDataChanges() || [];
	        for (const { method , start , count  } of changes){
	            const move = method === '_removeElements' ? -count : count;
	            moveNumericKeys(_hiddenIndices, start, move);
	        }
	    }
	 _getUniformDataChanges() {
	        const _dataChanges = this._dataChanges;
	        if (!_dataChanges || !_dataChanges.length) {
	            return;
	        }
	        this._dataChanges = [];
	        const datasetCount = this.data.datasets.length;
	        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));
	        const changeSet = makeSet(0);
	        for(let i = 1; i < datasetCount; i++){
	            if (!setsEqual(changeSet, makeSet(i))) {
	                return;
	            }
	        }
	        return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({
	                method: a[1],
	                start: +a[2],
	                count: +a[3]
	            }));
	    }
	 _updateLayout(minPadding) {
	        if (this.notifyPlugins('beforeLayout', {
	            cancelable: true
	        }) === false) {
	            return;
	        }
	        layouts.update(this, this.width, this.height, minPadding);
	        const area = this.chartArea;
	        const noArea = area.width <= 0 || area.height <= 0;
	        this._layers = [];
	        each(this.boxes, (box)=>{
	            if (noArea && box.position === 'chartArea') {
	                return;
	            }
	            if (box.configure) {
	                box.configure();
	            }
	            this._layers.push(...box._layers());
	        }, this);
	        this._layers.forEach((item, index)=>{
	            item._idx = index;
	        });
	        this.notifyPlugins('afterLayout');
	    }
	 _updateDatasets(mode) {
	        if (this.notifyPlugins('beforeDatasetsUpdate', {
	            mode,
	            cancelable: true
	        }) === false) {
	            return;
	        }
	        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
	            this.getDatasetMeta(i).controller.configure();
	        }
	        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
	            this._updateDataset(i, isFunction$1(mode) ? mode({
	                datasetIndex: i
	            }) : mode);
	        }
	        this.notifyPlugins('afterDatasetsUpdate', {
	            mode
	        });
	    }
	 _updateDataset(index, mode) {
	        const meta = this.getDatasetMeta(index);
	        const args = {
	            meta,
	            index,
	            mode,
	            cancelable: true
	        };
	        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
	            return;
	        }
	        meta.controller._update(mode);
	        args.cancelable = false;
	        this.notifyPlugins('afterDatasetUpdate', args);
	    }
	    render() {
	        if (this.notifyPlugins('beforeRender', {
	            cancelable: true
	        }) === false) {
	            return;
	        }
	        if (animator.has(this)) {
	            if (this.attached && !animator.running(this)) {
	                animator.start(this);
	            }
	        } else {
	            this.draw();
	            onAnimationsComplete({
	                chart: this
	            });
	        }
	    }
	    draw() {
	        let i;
	        if (this._resizeBeforeDraw) {
	            const { width , height  } = this._resizeBeforeDraw;
	            this._resizeBeforeDraw = null;
	            this._resize(width, height);
	        }
	        this.clear();
	        if (this.width <= 0 || this.height <= 0) {
	            return;
	        }
	        if (this.notifyPlugins('beforeDraw', {
	            cancelable: true
	        }) === false) {
	            return;
	        }
	        const layers = this._layers;
	        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){
	            layers[i].draw(this.chartArea);
	        }
	        this._drawDatasets();
	        for(; i < layers.length; ++i){
	            layers[i].draw(this.chartArea);
	        }
	        this.notifyPlugins('afterDraw');
	    }
	 _getSortedDatasetMetas(filterVisible) {
	        const metasets = this._sortedMetasets;
	        const result = [];
	        let i, ilen;
	        for(i = 0, ilen = metasets.length; i < ilen; ++i){
	            const meta = metasets[i];
	            if (!filterVisible || meta.visible) {
	                result.push(meta);
	            }
	        }
	        return result;
	    }
	 getSortedVisibleDatasetMetas() {
	        return this._getSortedDatasetMetas(true);
	    }
	 _drawDatasets() {
	        if (this.notifyPlugins('beforeDatasetsDraw', {
	            cancelable: true
	        }) === false) {
	            return;
	        }
	        const metasets = this.getSortedVisibleDatasetMetas();
	        for(let i = metasets.length - 1; i >= 0; --i){
	            this._drawDataset(metasets[i]);
	        }
	        this.notifyPlugins('afterDatasetsDraw');
	    }
	 _drawDataset(meta) {
	        const ctx = this.ctx;
	        const clip = meta._clip;
	        const useClip = !clip.disabled;
	        const area = getDatasetArea(meta, this.chartArea);
	        const args = {
	            meta,
	            index: meta.index,
	            cancelable: true
	        };
	        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
	            return;
	        }
	        if (useClip) {
	            clipArea(ctx, {
	                left: clip.left === false ? 0 : area.left - clip.left,
	                right: clip.right === false ? this.width : area.right + clip.right,
	                top: clip.top === false ? 0 : area.top - clip.top,
	                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
	            });
	        }
	        meta.controller.draw();
	        if (useClip) {
	            unclipArea(ctx);
	        }
	        args.cancelable = false;
	        this.notifyPlugins('afterDatasetDraw', args);
	    }
	 isPointInArea(point) {
	        return _isPointInArea(point, this.chartArea, this._minPadding);
	    }
	    getElementsAtEventForMode(e, mode, options, useFinalPosition) {
	        const method = Interaction.modes[mode];
	        if (typeof method === 'function') {
	            return method(this, e, options, useFinalPosition);
	        }
	        return [];
	    }
	    getDatasetMeta(datasetIndex) {
	        const dataset = this.data.datasets[datasetIndex];
	        const metasets = this._metasets;
	        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();
	        if (!meta) {
	            meta = {
	                type: null,
	                data: [],
	                dataset: null,
	                controller: null,
	                hidden: null,
	                xAxisID: null,
	                yAxisID: null,
	                order: dataset && dataset.order || 0,
	                index: datasetIndex,
	                _dataset: dataset,
	                _parsed: [],
	                _sorted: false
	            };
	            metasets.push(meta);
	        }
	        return meta;
	    }
	    getContext() {
	        return this.$context || (this.$context = createContext(null, {
	            chart: this,
	            type: 'chart'
	        }));
	    }
	    getVisibleDatasetCount() {
	        return this.getSortedVisibleDatasetMetas().length;
	    }
	    isDatasetVisible(datasetIndex) {
	        const dataset = this.data.datasets[datasetIndex];
	        if (!dataset) {
	            return false;
	        }
	        const meta = this.getDatasetMeta(datasetIndex);
	        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
	    }
	    setDatasetVisibility(datasetIndex, visible) {
	        const meta = this.getDatasetMeta(datasetIndex);
	        meta.hidden = !visible;
	    }
	    toggleDataVisibility(index) {
	        this._hiddenIndices[index] = !this._hiddenIndices[index];
	    }
	    getDataVisibility(index) {
	        return !this._hiddenIndices[index];
	    }
	 _updateVisibility(datasetIndex, dataIndex, visible) {
	        const mode = visible ? 'show' : 'hide';
	        const meta = this.getDatasetMeta(datasetIndex);
	        const anims = meta.controller._resolveAnimations(undefined, mode);
	        if (defined(dataIndex)) {
	            meta.data[dataIndex].hidden = !visible;
	            this.update();
	        } else {
	            this.setDatasetVisibility(datasetIndex, visible);
	            anims.update(meta, {
	                visible
	            });
	            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);
	        }
	    }
	    hide(datasetIndex, dataIndex) {
	        this._updateVisibility(datasetIndex, dataIndex, false);
	    }
	    show(datasetIndex, dataIndex) {
	        this._updateVisibility(datasetIndex, dataIndex, true);
	    }
	 _destroyDatasetMeta(datasetIndex) {
	        const meta = this._metasets[datasetIndex];
	        if (meta && meta.controller) {
	            meta.controller._destroy();
	        }
	        delete this._metasets[datasetIndex];
	    }
	    _stop() {
	        let i, ilen;
	        this.stop();
	        animator.remove(this);
	        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
	            this._destroyDatasetMeta(i);
	        }
	    }
	    destroy() {
	        this.notifyPlugins('beforeDestroy');
	        const { canvas , ctx  } = this;
	        this._stop();
	        this.config.clearCache();
	        if (canvas) {
	            this.unbindEvents();
	            clearCanvas(canvas, ctx);
	            this.platform.releaseContext(ctx);
	            this.canvas = null;
	            this.ctx = null;
	        }
	        delete instances[this.id];
	        this.notifyPlugins('afterDestroy');
	    }
	    toBase64Image(...args) {
	        return this.canvas.toDataURL(...args);
	    }
	 bindEvents() {
	        this.bindUserEvents();
	        if (this.options.responsive) {
	            this.bindResponsiveEvents();
	        } else {
	            this.attached = true;
	        }
	    }
	 bindUserEvents() {
	        const listeners = this._listeners;
	        const platform = this.platform;
	        const _add = (type, listener)=>{
	            platform.addEventListener(this, type, listener);
	            listeners[type] = listener;
	        };
	        const listener = (e, x, y)=>{
	            e.offsetX = x;
	            e.offsetY = y;
	            this._eventHandler(e);
	        };
	        each(this.options.events, (type)=>_add(type, listener));
	    }
	 bindResponsiveEvents() {
	        if (!this._responsiveListeners) {
	            this._responsiveListeners = {};
	        }
	        const listeners = this._responsiveListeners;
	        const platform = this.platform;
	        const _add = (type, listener)=>{
	            platform.addEventListener(this, type, listener);
	            listeners[type] = listener;
	        };
	        const _remove = (type, listener)=>{
	            if (listeners[type]) {
	                platform.removeEventListener(this, type, listener);
	                delete listeners[type];
	            }
	        };
	        const listener = (width, height)=>{
	            if (this.canvas) {
	                this.resize(width, height);
	            }
	        };
	        let detached;
	        const attached = ()=>{
	            _remove('attach', attached);
	            this.attached = true;
	            this.resize();
	            _add('resize', listener);
	            _add('detach', detached);
	        };
	        detached = ()=>{
	            this.attached = false;
	            _remove('resize', listener);
	            this._stop();
	            this._resize(0, 0);
	            _add('attach', attached);
	        };
	        if (platform.isAttached(this.canvas)) {
	            attached();
	        } else {
	            detached();
	        }
	    }
	 unbindEvents() {
	        each(this._listeners, (listener, type)=>{
	            this.platform.removeEventListener(this, type, listener);
	        });
	        this._listeners = {};
	        each(this._responsiveListeners, (listener, type)=>{
	            this.platform.removeEventListener(this, type, listener);
	        });
	        this._responsiveListeners = undefined;
	    }
	    updateHoverStyle(items, mode, enabled) {
	        const prefix = enabled ? 'set' : 'remove';
	        let meta, item, i, ilen;
	        if (mode === 'dataset') {
	            meta = this.getDatasetMeta(items[0].datasetIndex);
	            meta.controller['_' + prefix + 'DatasetHoverStyle']();
	        }
	        for(i = 0, ilen = items.length; i < ilen; ++i){
	            item = items[i];
	            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
	            if (controller) {
	                controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
	            }
	        }
	    }
	 getActiveElements() {
	        return this._active || [];
	    }
	 setActiveElements(activeElements) {
	        const lastActive = this._active || [];
	        const active = activeElements.map(({ datasetIndex , index  })=>{
	            const meta = this.getDatasetMeta(datasetIndex);
	            if (!meta) {
	                throw new Error('No dataset found at index ' + datasetIndex);
	            }
	            return {
	                datasetIndex,
	                element: meta.data[index],
	                index
	            };
	        });
	        const changed = !_elementsEqual(active, lastActive);
	        if (changed) {
	            this._active = active;
	            this._lastEvent = null;
	            this._updateHoverStyles(active, lastActive);
	        }
	    }
	 notifyPlugins(hook, args, filter) {
	        return this._plugins.notify(this, hook, args, filter);
	    }
	 isPluginEnabled(pluginId) {
	        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;
	    }
	 _updateHoverStyles(active, lastActive, replay) {
	        const hoverOptions = this.options.hover;
	        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));
	        const deactivated = diff(lastActive, active);
	        const activated = replay ? active : diff(active, lastActive);
	        if (deactivated.length) {
	            this.updateHoverStyle(deactivated, hoverOptions.mode, false);
	        }
	        if (activated.length && hoverOptions.mode) {
	            this.updateHoverStyle(activated, hoverOptions.mode, true);
	        }
	    }
	 _eventHandler(e, replay) {
	        const args = {
	            event: e,
	            replay,
	            cancelable: true,
	            inChartArea: this.isPointInArea(e)
	        };
	        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);
	        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {
	            return;
	        }
	        const changed = this._handleEvent(e, replay, args.inChartArea);
	        args.cancelable = false;
	        this.notifyPlugins('afterEvent', args, eventFilter);
	        if (changed || args.changed) {
	            this.render();
	        }
	        return this;
	    }
	 _handleEvent(e, replay, inChartArea) {
	        const { _active: lastActive = [] , options  } = this;
	        const useFinalPosition = replay;
	        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
	        const isClick = _isClickEvent(e);
	        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
	        if (inChartArea) {
	            this._lastEvent = null;
	            callback(options.onHover, [
	                e,
	                active,
	                this
	            ], this);
	            if (isClick) {
	                callback(options.onClick, [
	                    e,
	                    active,
	                    this
	                ], this);
	            }
	        }
	        const changed = !_elementsEqual(active, lastActive);
	        if (changed || replay) {
	            this._active = active;
	            this._updateHoverStyles(active, lastActive, replay);
	        }
	        this._lastEvent = lastEvent;
	        return changed;
	    }
	 _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
	        if (e.type === 'mouseout') {
	            return [];
	        }
	        if (!inChartArea) {
	            return lastActive;
	        }
	        const hoverOptions = this.options.hover;
	        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
	    }
	}
	function invalidatePlugins() {
	    return each(Chart.instances, (chart)=>chart._plugins.invalidate());
	}

	function clipArc(ctx, element, endAngle) {
	    const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;
	    let angleMargin = pixelMargin / outerRadius;
	    // Draw an inner border by clipping the arc and drawing a double-width border
	    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
	    ctx.beginPath();
	    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
	    if (innerRadius > pixelMargin) {
	        angleMargin = pixelMargin / innerRadius;
	        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
	    } else {
	        ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
	    }
	    ctx.closePath();
	    ctx.clip();
	}
	function toRadiusCorners(value) {
	    return _readValueToProps(value, [
	        'outerStart',
	        'outerEnd',
	        'innerStart',
	        'innerEnd'
	    ]);
	}
	/**
	 * Parse border radius from the provided options
	 */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
	    const o = toRadiusCorners(arc.options.borderRadius);
	    const halfThickness = (outerRadius - innerRadius) / 2;
	    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
	    // Outer limits are complicated. We want to compute the available angular distance at
	    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.
	    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.
	    //
	    // If the borderRadius is large, that value can become negative.
	    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius
	    // we know that the thickness term will dominate and compute the limits at that point
	    const computeOuterLimit = (val)=>{
	        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
	        return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
	    };
	    return {
	        outerStart: computeOuterLimit(o.outerStart),
	        outerEnd: computeOuterLimit(o.outerEnd),
	        innerStart: _limitValue(o.innerStart, 0, innerLimit),
	        innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
	    };
	}
	/**
	 * Convert (r, ) to (x, y)
	 */ function rThetaToXY(r, theta, x, y) {
	    return {
	        x: x + r * Math.cos(theta),
	        y: y + r * Math.sin(theta)
	    };
	}
	/**
	 * Path the arc, respecting border radius by separating into left and right halves.
	 *
	 *   Start      End
	 *
	 *    1--->a--->2    Outer
	 *   /           \
	 *   8           3
	 *   |           |
	 *   |           |
	 *   7           4
	 *   \           /
	 *    6<---b<---5    Inner
	 */ function pathArc(ctx, element, offset, spacing, end, circular) {
	    const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;
	    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
	    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
	    let spacingOffset = 0;
	    const alpha = end - start;
	    if (spacing) {
	        // When spacing is present, it is the same for all items
	        // So we adjust the start and end angle of the arc such that
	        // the distance is the same as it would be without the spacing
	        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
	        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
	        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
	        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
	        spacingOffset = (alpha - adjustedAngle) / 2;
	    }
	    const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;
	    const angleOffset = (alpha - beta) / 2;
	    const startAngle = start + angleOffset + spacingOffset;
	    const endAngle = end - angleOffset - spacingOffset;
	    const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
	    const outerStartAdjustedRadius = outerRadius - outerStart;
	    const outerEndAdjustedRadius = outerRadius - outerEnd;
	    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
	    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
	    const innerStartAdjustedRadius = innerRadius + innerStart;
	    const innerEndAdjustedRadius = innerRadius + innerEnd;
	    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
	    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
	    ctx.beginPath();
	    if (circular) {
	        // The first arc segments from point 1 to point a to point 2
	        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
	        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
	        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
	        // The corner segment from point 2 to point 3
	        if (outerEnd > 0) {
	            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
	            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
	        }
	        // The line from point 3 to point 4
	        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
	        ctx.lineTo(p4.x, p4.y);
	        // The corner segment from point 4 to point 5
	        if (innerEnd > 0) {
	            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
	            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
	        }
	        // The inner arc from point 5 to point b to point 6
	        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
	        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
	        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
	        // The corner segment from point 6 to point 7
	        if (innerStart > 0) {
	            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
	            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
	        }
	        // The line from point 7 to point 8
	        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
	        ctx.lineTo(p8.x, p8.y);
	        // The corner segment from point 8 to point 1
	        if (outerStart > 0) {
	            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
	            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
	        }
	    } else {
	        ctx.moveTo(x, y);
	        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
	        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
	        ctx.lineTo(outerStartX, outerStartY);
	        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
	        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
	        ctx.lineTo(outerEndX, outerEndY);
	    }
	    ctx.closePath();
	}
	function drawArc(ctx, element, offset, spacing, circular) {
	    const { fullCircles , startAngle , circumference  } = element;
	    let endAngle = element.endAngle;
	    if (fullCircles) {
	        pathArc(ctx, element, offset, spacing, endAngle, circular);
	        for(let i = 0; i < fullCircles; ++i){
	            ctx.fill();
	        }
	        if (!isNaN(circumference)) {
	            endAngle = startAngle + (circumference % TAU || TAU);
	        }
	    }
	    pathArc(ctx, element, offset, spacing, endAngle, circular);
	    ctx.fill();
	    return endAngle;
	}
	function drawBorder(ctx, element, offset, spacing, circular) {
	    const { fullCircles , startAngle , circumference , options  } = element;
	    const { borderWidth , borderJoinStyle , borderDash , borderDashOffset  } = options;
	    const inner = options.borderAlign === 'inner';
	    if (!borderWidth) {
	        return;
	    }
	    ctx.setLineDash(borderDash || []);
	    ctx.lineDashOffset = borderDashOffset;
	    if (inner) {
	        ctx.lineWidth = borderWidth * 2;
	        ctx.lineJoin = borderJoinStyle || 'round';
	    } else {
	        ctx.lineWidth = borderWidth;
	        ctx.lineJoin = borderJoinStyle || 'bevel';
	    }
	    let endAngle = element.endAngle;
	    if (fullCircles) {
	        pathArc(ctx, element, offset, spacing, endAngle, circular);
	        for(let i = 0; i < fullCircles; ++i){
	            ctx.stroke();
	        }
	        if (!isNaN(circumference)) {
	            endAngle = startAngle + (circumference % TAU || TAU);
	        }
	    }
	    if (inner) {
	        clipArc(ctx, element, endAngle);
	    }
	    if (!fullCircles) {
	        pathArc(ctx, element, offset, spacing, endAngle, circular);
	        ctx.stroke();
	    }
	}
	class ArcElement extends Element {
	    static id = 'arc';
	    static defaults = {
	        borderAlign: 'center',
	        borderColor: '#fff',
	        borderDash: [],
	        borderDashOffset: 0,
	        borderJoinStyle: undefined,
	        borderRadius: 0,
	        borderWidth: 2,
	        offset: 0,
	        spacing: 0,
	        angle: undefined,
	        circular: true
	    };
	    static defaultRoutes = {
	        backgroundColor: 'backgroundColor'
	    };
	    static descriptors = {
	        _scriptable: true,
	        _indexable: (name)=>name !== 'borderDash'
	    };
	    circumference;
	    endAngle;
	    fullCircles;
	    innerRadius;
	    outerRadius;
	    pixelMargin;
	    startAngle;
	    constructor(cfg){
	        super();
	        this.options = undefined;
	        this.circumference = undefined;
	        this.startAngle = undefined;
	        this.endAngle = undefined;
	        this.innerRadius = undefined;
	        this.outerRadius = undefined;
	        this.pixelMargin = 0;
	        this.fullCircles = 0;
	        if (cfg) {
	            Object.assign(this, cfg);
	        }
	    }
	    inRange(chartX, chartY, useFinalPosition) {
	        const point = this.getProps([
	            'x',
	            'y'
	        ], useFinalPosition);
	        const { angle , distance  } = getAngleFromPoint(point, {
	            x: chartX,
	            y: chartY
	        });
	        const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([
	            'startAngle',
	            'endAngle',
	            'innerRadius',
	            'outerRadius',
	            'circumference'
	        ], useFinalPosition);
	        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
	        const _circumference = valueOrDefault(circumference, endAngle - startAngle);
	        const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
	        const betweenAngles = _circumference >= TAU || nonZeroBetween;
	        const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
	        return betweenAngles && withinRadius;
	    }
	    getCenterPoint(useFinalPosition) {
	        const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([
	            'x',
	            'y',
	            'startAngle',
	            'endAngle',
	            'innerRadius',
	            'outerRadius'
	        ], useFinalPosition);
	        const { offset , spacing  } = this.options;
	        const halfAngle = (startAngle + endAngle) / 2;
	        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
	        return {
	            x: x + Math.cos(halfAngle) * halfRadius,
	            y: y + Math.sin(halfAngle) * halfRadius
	        };
	    }
	    tooltipPosition(useFinalPosition) {
	        return this.getCenterPoint(useFinalPosition);
	    }
	    draw(ctx) {
	        const { options , circumference  } = this;
	        const offset = (options.offset || 0) / 4;
	        const spacing = (options.spacing || 0) / 2;
	        const circular = options.circular;
	        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;
	        this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
	        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
	            return;
	        }
	        ctx.save();
	        const halfAngle = (this.startAngle + this.endAngle) / 2;
	        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
	        const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
	        const radiusOffset = offset * fix;
	        ctx.fillStyle = options.backgroundColor;
	        ctx.strokeStyle = options.borderColor;
	        drawArc(ctx, this, radiusOffset, spacing, circular);
	        drawBorder(ctx, this, radiusOffset, spacing, circular);
	        ctx.restore();
	    }
	}

	function setStyle(ctx, options, style = options) {
	    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
	    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
	    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
	    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
	    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
	    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
	}
	function lineTo(ctx, previous, target) {
	    ctx.lineTo(target.x, target.y);
	}
	 function getLineMethod(options) {
	    if (options.stepped) {
	        return _steppedLineTo;
	    }
	    if (options.tension || options.cubicInterpolationMode === 'monotone') {
	        return _bezierCurveTo;
	    }
	    return lineTo;
	}
	function pathVars(points, segment, params = {}) {
	    const count = points.length;
	    const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;
	    const { start: segmentStart , end: segmentEnd  } = segment;
	    const start = Math.max(paramsStart, segmentStart);
	    const end = Math.min(paramsEnd, segmentEnd);
	    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
	    return {
	        count,
	        start,
	        loop: segment.loop,
	        ilen: end < start && !outside ? count + end - start : end - start
	    };
	}
	 function pathSegment(ctx, line, segment, params) {
	    const { points , options  } = line;
	    const { count , start , loop , ilen  } = pathVars(points, segment, params);
	    const lineMethod = getLineMethod(options);
	    let { move =true , reverse  } = params || {};
	    let i, point, prev;
	    for(i = 0; i <= ilen; ++i){
	        point = points[(start + (reverse ? ilen - i : i)) % count];
	        if (point.skip) {
	            continue;
	        } else if (move) {
	            ctx.moveTo(point.x, point.y);
	            move = false;
	        } else {
	            lineMethod(ctx, prev, point, reverse, options.stepped);
	        }
	        prev = point;
	    }
	    if (loop) {
	        point = points[(start + (reverse ? ilen : 0)) % count];
	        lineMethod(ctx, prev, point, reverse, options.stepped);
	    }
	    return !!loop;
	}
	 function fastPathSegment(ctx, line, segment, params) {
	    const points = line.points;
	    const { count , start , ilen  } = pathVars(points, segment, params);
	    const { move =true , reverse  } = params || {};
	    let avgX = 0;
	    let countX = 0;
	    let i, point, prevX, minY, maxY, lastY;
	    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;
	    const drawX = ()=>{
	        if (minY !== maxY) {
	            ctx.lineTo(avgX, maxY);
	            ctx.lineTo(avgX, minY);
	            ctx.lineTo(avgX, lastY);
	        }
	    };
	    if (move) {
	        point = points[pointIndex(0)];
	        ctx.moveTo(point.x, point.y);
	    }
	    for(i = 0; i <= ilen; ++i){
	        point = points[pointIndex(i)];
	        if (point.skip) {
	            continue;
	        }
	        const x = point.x;
	        const y = point.y;
	        const truncX = x | 0;
	        if (truncX === prevX) {
	            if (y < minY) {
	                minY = y;
	            } else if (y > maxY) {
	                maxY = y;
	            }
	            avgX = (countX * avgX + x) / ++countX;
	        } else {
	            drawX();
	            ctx.lineTo(x, y);
	            prevX = truncX;
	            countX = 0;
	            minY = maxY = y;
	        }
	        lastY = y;
	    }
	    drawX();
	}
	 function _getSegmentMethod(line) {
	    const opts = line.options;
	    const borderDash = opts.borderDash && opts.borderDash.length;
	    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
	    return useFastPath ? fastPathSegment : pathSegment;
	}
	 function _getInterpolationMethod(options) {
	    if (options.stepped) {
	        return _steppedInterpolation;
	    }
	    if (options.tension || options.cubicInterpolationMode === 'monotone') {
	        return _bezierInterpolation;
	    }
	    return _pointInLine;
	}
	function strokePathWithCache(ctx, line, start, count) {
	    let path = line._path;
	    if (!path) {
	        path = line._path = new Path2D();
	        if (line.path(path, start, count)) {
	            path.closePath();
	        }
	    }
	    setStyle(ctx, line.options);
	    ctx.stroke(path);
	}
	function strokePathDirect(ctx, line, start, count) {
	    const { segments , options  } = line;
	    const segmentMethod = _getSegmentMethod(line);
	    for (const segment of segments){
	        setStyle(ctx, options, segment.style);
	        ctx.beginPath();
	        if (segmentMethod(ctx, line, segment, {
	            start,
	            end: start + count - 1
	        })) {
	            ctx.closePath();
	        }
	        ctx.stroke();
	    }
	}
	const usePath2D = typeof Path2D === 'function';
	function draw(ctx, line, start, count) {
	    if (usePath2D && !line.options.segment) {
	        strokePathWithCache(ctx, line, start, count);
	    } else {
	        strokePathDirect(ctx, line, start, count);
	    }
	}
	class LineElement extends Element {
	    static id = 'line';
	 static defaults = {
	        borderCapStyle: 'butt',
	        borderDash: [],
	        borderDashOffset: 0,
	        borderJoinStyle: 'miter',
	        borderWidth: 3,
	        capBezierPoints: true,
	        cubicInterpolationMode: 'default',
	        fill: false,
	        spanGaps: false,
	        stepped: false,
	        tension: 0
	    };
	 static defaultRoutes = {
	        backgroundColor: 'backgroundColor',
	        borderColor: 'borderColor'
	    };
	    static descriptors = {
	        _scriptable: true,
	        _indexable: (name)=>name !== 'borderDash' && name !== 'fill'
	    };
	    constructor(cfg){
	        super();
	        this.animated = true;
	        this.options = undefined;
	        this._chart = undefined;
	        this._loop = undefined;
	        this._fullLoop = undefined;
	        this._path = undefined;
	        this._points = undefined;
	        this._segments = undefined;
	        this._decimated = false;
	        this._pointsUpdated = false;
	        this._datasetIndex = undefined;
	        if (cfg) {
	            Object.assign(this, cfg);
	        }
	    }
	    updateControlPoints(chartArea, indexAxis) {
	        const options = this.options;
	        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
	            const loop = options.spanGaps ? this._loop : this._fullLoop;
	            _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
	            this._pointsUpdated = true;
	        }
	    }
	    set points(points) {
	        this._points = points;
	        delete this._segments;
	        delete this._path;
	        this._pointsUpdated = false;
	    }
	    get points() {
	        return this._points;
	    }
	    get segments() {
	        return this._segments || (this._segments = _computeSegments(this, this.options.segment));
	    }
	 first() {
	        const segments = this.segments;
	        const points = this.points;
	        return segments.length && points[segments[0].start];
	    }
	 last() {
	        const segments = this.segments;
	        const points = this.points;
	        const count = segments.length;
	        return count && points[segments[count - 1].end];
	    }
	 interpolate(point, property) {
	        const options = this.options;
	        const value = point[property];
	        const points = this.points;
	        const segments = _boundSegments(this, {
	            property,
	            start: value,
	            end: value
	        });
	        if (!segments.length) {
	            return;
	        }
	        const result = [];
	        const _interpolate = _getInterpolationMethod(options);
	        let i, ilen;
	        for(i = 0, ilen = segments.length; i < ilen; ++i){
	            const { start , end  } = segments[i];
	            const p1 = points[start];
	            const p2 = points[end];
	            if (p1 === p2) {
	                result.push(p1);
	                continue;
	            }
	            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
	            const interpolated = _interpolate(p1, p2, t, options.stepped);
	            interpolated[property] = point[property];
	            result.push(interpolated);
	        }
	        return result.length === 1 ? result[0] : result;
	    }
	 pathSegment(ctx, segment, params) {
	        const segmentMethod = _getSegmentMethod(this);
	        return segmentMethod(ctx, this, segment, params);
	    }
	 path(ctx, start, count) {
	        const segments = this.segments;
	        const segmentMethod = _getSegmentMethod(this);
	        let loop = this._loop;
	        start = start || 0;
	        count = count || this.points.length - start;
	        for (const segment of segments){
	            loop &= segmentMethod(ctx, this, segment, {
	                start,
	                end: start + count - 1
	            });
	        }
	        return !!loop;
	    }
	 draw(ctx, chartArea, start, count) {
	        const options = this.options || {};
	        const points = this.points || [];
	        if (points.length && options.borderWidth) {
	            ctx.save();
	            draw(ctx, this, start, count);
	            ctx.restore();
	        }
	        if (this.animated) {
	            this._pointsUpdated = false;
	            this._path = undefined;
	        }
	    }
	}

	function inRange$1(el, pos, axis, useFinalPosition) {
	    const options = el.options;
	    const { [axis]: value  } = el.getProps([
	        axis
	    ], useFinalPosition);
	    return Math.abs(pos - value) < options.radius + options.hitRadius;
	}
	class PointElement extends Element {
	    static id = 'point';
	    parsed;
	    skip;
	    stop;
	    /**
	   * @type {any}
	   */ static defaults = {
	        borderWidth: 1,
	        hitRadius: 1,
	        hoverBorderWidth: 1,
	        hoverRadius: 4,
	        pointStyle: 'circle',
	        radius: 3,
	        rotation: 0
	    };
	    /**
	   * @type {any}
	   */ static defaultRoutes = {
	        backgroundColor: 'backgroundColor',
	        borderColor: 'borderColor'
	    };
	    constructor(cfg){
	        super();
	        this.options = undefined;
	        this.parsed = undefined;
	        this.skip = undefined;
	        this.stop = undefined;
	        if (cfg) {
	            Object.assign(this, cfg);
	        }
	    }
	    inRange(mouseX, mouseY, useFinalPosition) {
	        const options = this.options;
	        const { x , y  } = this.getProps([
	            'x',
	            'y'
	        ], useFinalPosition);
	        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
	    }
	    inXRange(mouseX, useFinalPosition) {
	        return inRange$1(this, mouseX, 'x', useFinalPosition);
	    }
	    inYRange(mouseY, useFinalPosition) {
	        return inRange$1(this, mouseY, 'y', useFinalPosition);
	    }
	    getCenterPoint(useFinalPosition) {
	        const { x , y  } = this.getProps([
	            'x',
	            'y'
	        ], useFinalPosition);
	        return {
	            x,
	            y
	        };
	    }
	    size(options) {
	        options = options || this.options || {};
	        let radius = options.radius || 0;
	        radius = Math.max(radius, radius && options.hoverRadius || 0);
	        const borderWidth = radius && options.borderWidth || 0;
	        return (radius + borderWidth) * 2;
	    }
	    draw(ctx, area) {
	        const options = this.options;
	        if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
	            return;
	        }
	        ctx.strokeStyle = options.borderColor;
	        ctx.lineWidth = options.borderWidth;
	        ctx.fillStyle = options.backgroundColor;
	        drawPoint(ctx, options, this.x, this.y);
	    }
	    getRange() {
	        const options = this.options || {};
	        // @ts-expect-error Fallbacks should never be hit in practice
	        return options.radius + options.hitRadius;
	    }
	}

	function getBarBounds(bar, useFinalPosition) {
	    const { x , y , base , width , height  } =  bar.getProps([
	        'x',
	        'y',
	        'base',
	        'width',
	        'height'
	    ], useFinalPosition);
	    let left, right, top, bottom, half;
	    if (bar.horizontal) {
	        half = height / 2;
	        left = Math.min(x, base);
	        right = Math.max(x, base);
	        top = y - half;
	        bottom = y + half;
	    } else {
	        half = width / 2;
	        left = x - half;
	        right = x + half;
	        top = Math.min(y, base);
	        bottom = Math.max(y, base);
	    }
	    return {
	        left,
	        top,
	        right,
	        bottom
	    };
	}
	function skipOrLimit(skip, value, min, max) {
	    return skip ? 0 : _limitValue(value, min, max);
	}
	function parseBorderWidth(bar, maxW, maxH) {
	    const value = bar.options.borderWidth;
	    const skip = bar.borderSkipped;
	    const o = toTRBL(value);
	    return {
	        t: skipOrLimit(skip.top, o.top, 0, maxH),
	        r: skipOrLimit(skip.right, o.right, 0, maxW),
	        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
	        l: skipOrLimit(skip.left, o.left, 0, maxW)
	    };
	}
	function parseBorderRadius(bar, maxW, maxH) {
	    const { enableBorderRadius  } = bar.getProps([
	        'enableBorderRadius'
	    ]);
	    const value = bar.options.borderRadius;
	    const o = toTRBLCorners(value);
	    const maxR = Math.min(maxW, maxH);
	    const skip = bar.borderSkipped;
	    const enableBorder = enableBorderRadius || isObject$1(value);
	    return {
	        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
	        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
	        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
	        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
	    };
	}
	function boundingRects(bar) {
	    const bounds = getBarBounds(bar);
	    const width = bounds.right - bounds.left;
	    const height = bounds.bottom - bounds.top;
	    const border = parseBorderWidth(bar, width / 2, height / 2);
	    const radius = parseBorderRadius(bar, width / 2, height / 2);
	    return {
	        outer: {
	            x: bounds.left,
	            y: bounds.top,
	            w: width,
	            h: height,
	            radius
	        },
	        inner: {
	            x: bounds.left + border.l,
	            y: bounds.top + border.t,
	            w: width - border.l - border.r,
	            h: height - border.t - border.b,
	            radius: {
	                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
	                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
	                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
	                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
	            }
	        }
	    };
	}
	function inRange(bar, x, y, useFinalPosition) {
	    const skipX = x === null;
	    const skipY = y === null;
	    const skipBoth = skipX && skipY;
	    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
	    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
	}
	function hasRadius(radius) {
	    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
	}
	 function addNormalRectPath(ctx, rect) {
	    ctx.rect(rect.x, rect.y, rect.w, rect.h);
	}
	function inflateRect(rect, amount, refRect = {}) {
	    const x = rect.x !== refRect.x ? -amount : 0;
	    const y = rect.y !== refRect.y ? -amount : 0;
	    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
	    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
	    return {
	        x: rect.x + x,
	        y: rect.y + y,
	        w: rect.w + w,
	        h: rect.h + h,
	        radius: rect.radius
	    };
	}
	class BarElement extends Element {
	    static id = 'bar';
	 static defaults = {
	        borderSkipped: 'start',
	        borderWidth: 0,
	        borderRadius: 0,
	        inflateAmount: 'auto',
	        pointStyle: undefined
	    };
	 static defaultRoutes = {
	        backgroundColor: 'backgroundColor',
	        borderColor: 'borderColor'
	    };
	    constructor(cfg){
	        super();
	        this.options = undefined;
	        this.horizontal = undefined;
	        this.base = undefined;
	        this.width = undefined;
	        this.height = undefined;
	        this.inflateAmount = undefined;
	        if (cfg) {
	            Object.assign(this, cfg);
	        }
	    }
	    draw(ctx) {
	        const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;
	        const { inner , outer  } = boundingRects(this);
	        const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
	        ctx.save();
	        if (outer.w !== inner.w || outer.h !== inner.h) {
	            ctx.beginPath();
	            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
	            ctx.clip();
	            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
	            ctx.fillStyle = borderColor;
	            ctx.fill('evenodd');
	        }
	        ctx.beginPath();
	        addRectPath(ctx, inflateRect(inner, inflateAmount));
	        ctx.fillStyle = backgroundColor;
	        ctx.fill();
	        ctx.restore();
	    }
	    inRange(mouseX, mouseY, useFinalPosition) {
	        return inRange(this, mouseX, mouseY, useFinalPosition);
	    }
	    inXRange(mouseX, useFinalPosition) {
	        return inRange(this, mouseX, null, useFinalPosition);
	    }
	    inYRange(mouseY, useFinalPosition) {
	        return inRange(this, null, mouseY, useFinalPosition);
	    }
	    getCenterPoint(useFinalPosition) {
	        const { x , y , base , horizontal  } =  this.getProps([
	            'x',
	            'y',
	            'base',
	            'horizontal'
	        ], useFinalPosition);
	        return {
	            x: horizontal ? (x + base) / 2 : x,
	            y: horizontal ? y : (y + base) / 2
	        };
	    }
	    getRange(axis) {
	        return axis === 'x' ? this.width / 2 : this.height / 2;
	    }
	}

	function _segments(line, target, property) {
	    const segments = line.segments;
	    const points = line.points;
	    const tpoints = target.points;
	    const parts = [];
	    for (const segment of segments){
	        let { start , end  } = segment;
	        end = _findSegmentEnd(start, end, points);
	        const bounds = _getBounds(property, points[start], points[end], segment.loop);
	        if (!target.segments) {
	            parts.push({
	                source: segment,
	                target: bounds,
	                start: points[start],
	                end: points[end]
	            });
	            continue;
	        }
	        const targetSegments = _boundSegments(target, bounds);
	        for (const tgt of targetSegments){
	            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
	            const fillSources = _boundSegment(segment, points, subBounds);
	            for (const fillSource of fillSources){
	                parts.push({
	                    source: fillSource,
	                    target: tgt,
	                    start: {
	                        [property]: _getEdge(bounds, subBounds, 'start', Math.max)
	                    },
	                    end: {
	                        [property]: _getEdge(bounds, subBounds, 'end', Math.min)
	                    }
	                });
	            }
	        }
	    }
	    return parts;
	}
	function _getBounds(property, first, last, loop) {
	    if (loop) {
	        return;
	    }
	    let start = first[property];
	    let end = last[property];
	    if (property === 'angle') {
	        start = _normalizeAngle(start);
	        end = _normalizeAngle(end);
	    }
	    return {
	        property,
	        start,
	        end
	    };
	}
	function _pointsFromSegments(boundary, line) {
	    const { x =null , y =null  } = boundary || {};
	    const linePoints = line.points;
	    const points = [];
	    line.segments.forEach(({ start , end  })=>{
	        end = _findSegmentEnd(start, end, linePoints);
	        const first = linePoints[start];
	        const last = linePoints[end];
	        if (y !== null) {
	            points.push({
	                x: first.x,
	                y
	            });
	            points.push({
	                x: last.x,
	                y
	            });
	        } else if (x !== null) {
	            points.push({
	                x,
	                y: first.y
	            });
	            points.push({
	                x,
	                y: last.y
	            });
	        }
	    });
	    return points;
	}
	function _findSegmentEnd(start, end, points) {
	    for(; end > start; end--){
	        const point = points[end];
	        if (!isNaN(point.x) && !isNaN(point.y)) {
	            break;
	        }
	    }
	    return end;
	}
	function _getEdge(a, b, prop, fn) {
	    if (a && b) {
	        return fn(a[prop], b[prop]);
	    }
	    return a ? a[prop] : b ? b[prop] : 0;
	}

	function _createBoundaryLine(boundary, line) {
	    let points = [];
	    let _loop = false;
	    if (isArray$1(boundary)) {
	        _loop = true;
	        points = boundary;
	    } else {
	        points = _pointsFromSegments(boundary, line);
	    }
	    return points.length ? new LineElement({
	        points,
	        options: {
	            tension: 0
	        },
	        _loop,
	        _fullLoop: _loop
	    }) : null;
	}
	function _shouldApplyFill(source) {
	    return source && source.fill !== false;
	}

	function _resolveTarget(sources, index, propagate) {
	    const source = sources[index];
	    let fill = source.fill;
	    const visited = [
	        index
	    ];
	    let target;
	    if (!propagate) {
	        return fill;
	    }
	    while(fill !== false && visited.indexOf(fill) === -1){
	        if (!isNumberFinite(fill)) {
	            return fill;
	        }
	        target = sources[fill];
	        if (!target) {
	            return false;
	        }
	        if (target.visible) {
	            return fill;
	        }
	        visited.push(fill);
	        fill = target.fill;
	    }
	    return false;
	}
	 function _decodeFill(line, index, count) {
	     const fill = parseFillOption(line);
	    if (isObject$1(fill)) {
	        return isNaN(fill.value) ? false : fill;
	    }
	    let target = parseFloat(fill);
	    if (isNumberFinite(target) && Math.floor(target) === target) {
	        return decodeTargetIndex(fill[0], index, target, count);
	    }
	    return [
	        'origin',
	        'start',
	        'end',
	        'stack',
	        'shape'
	    ].indexOf(fill) >= 0 && fill;
	}
	function decodeTargetIndex(firstCh, index, target, count) {
	    if (firstCh === '-' || firstCh === '+') {
	        target = index + target;
	    }
	    if (target === index || target < 0 || target >= count) {
	        return false;
	    }
	    return target;
	}
	 function _getTargetPixel(fill, scale) {
	    let pixel = null;
	    if (fill === 'start') {
	        pixel = scale.bottom;
	    } else if (fill === 'end') {
	        pixel = scale.top;
	    } else if (isObject$1(fill)) {
	        pixel = scale.getPixelForValue(fill.value);
	    } else if (scale.getBasePixel) {
	        pixel = scale.getBasePixel();
	    }
	    return pixel;
	}
	 function _getTargetValue(fill, scale, startValue) {
	    let value;
	    if (fill === 'start') {
	        value = startValue;
	    } else if (fill === 'end') {
	        value = scale.options.reverse ? scale.min : scale.max;
	    } else if (isObject$1(fill)) {
	        value = fill.value;
	    } else {
	        value = scale.getBaseValue();
	    }
	    return value;
	}
	 function parseFillOption(line) {
	    const options = line.options;
	    const fillOption = options.fill;
	    let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
	    if (fill === undefined) {
	        fill = !!options.backgroundColor;
	    }
	    if (fill === false || fill === null) {
	        return false;
	    }
	    if (fill === true) {
	        return 'origin';
	    }
	    return fill;
	}

	function _buildStackLine(source) {
	    const { scale , index , line  } = source;
	    const points = [];
	    const segments = line.segments;
	    const sourcePoints = line.points;
	    const linesBelow = getLinesBelow(scale, index);
	    linesBelow.push(_createBoundaryLine({
	        x: null,
	        y: scale.bottom
	    }, line));
	    for(let i = 0; i < segments.length; i++){
	        const segment = segments[i];
	        for(let j = segment.start; j <= segment.end; j++){
	            addPointsBelow(points, sourcePoints[j], linesBelow);
	        }
	    }
	    return new LineElement({
	        points,
	        options: {}
	    });
	}
	 function getLinesBelow(scale, index) {
	    const below = [];
	    const metas = scale.getMatchingVisibleMetas('line');
	    for(let i = 0; i < metas.length; i++){
	        const meta = metas[i];
	        if (meta.index === index) {
	            break;
	        }
	        if (!meta.hidden) {
	            below.unshift(meta.dataset);
	        }
	    }
	    return below;
	}
	 function addPointsBelow(points, sourcePoint, linesBelow) {
	    const postponed = [];
	    for(let j = 0; j < linesBelow.length; j++){
	        const line = linesBelow[j];
	        const { first , last , point  } = findPoint(line, sourcePoint, 'x');
	        if (!point || first && last) {
	            continue;
	        }
	        if (first) {
	            postponed.unshift(point);
	        } else {
	            points.push(point);
	            if (!last) {
	                break;
	            }
	        }
	    }
	    points.push(...postponed);
	}
	 function findPoint(line, sourcePoint, property) {
	    const point = line.interpolate(sourcePoint, property);
	    if (!point) {
	        return {};
	    }
	    const pointValue = point[property];
	    const segments = line.segments;
	    const linePoints = line.points;
	    let first = false;
	    let last = false;
	    for(let i = 0; i < segments.length; i++){
	        const segment = segments[i];
	        const firstValue = linePoints[segment.start][property];
	        const lastValue = linePoints[segment.end][property];
	        if (_isBetween(pointValue, firstValue, lastValue)) {
	            first = pointValue === firstValue;
	            last = pointValue === lastValue;
	            break;
	        }
	    }
	    return {
	        first,
	        last,
	        point
	    };
	}

	class simpleArc {
	    constructor(opts){
	        this.x = opts.x;
	        this.y = opts.y;
	        this.radius = opts.radius;
	    }
	    pathSegment(ctx, bounds, opts) {
	        const { x , y , radius  } = this;
	        bounds = bounds || {
	            start: 0,
	            end: TAU
	        };
	        ctx.arc(x, y, radius, bounds.end, bounds.start, true);
	        return !opts.bounds;
	    }
	    interpolate(point) {
	        const { x , y , radius  } = this;
	        const angle = point.angle;
	        return {
	            x: x + Math.cos(angle) * radius,
	            y: y + Math.sin(angle) * radius,
	            angle
	        };
	    }
	}

	function _getTarget(source) {
	    const { chart , fill , line  } = source;
	    if (isNumberFinite(fill)) {
	        return getLineByIndex(chart, fill);
	    }
	    if (fill === 'stack') {
	        return _buildStackLine(source);
	    }
	    if (fill === 'shape') {
	        return true;
	    }
	    const boundary = computeBoundary(source);
	    if (boundary instanceof simpleArc) {
	        return boundary;
	    }
	    return _createBoundaryLine(boundary, line);
	}
	 function getLineByIndex(chart, index) {
	    const meta = chart.getDatasetMeta(index);
	    const visible = meta && chart.isDatasetVisible(index);
	    return visible ? meta.dataset : null;
	}
	function computeBoundary(source) {
	    const scale = source.scale || {};
	    if (scale.getPointPositionForValue) {
	        return computeCircularBoundary(source);
	    }
	    return computeLinearBoundary(source);
	}
	function computeLinearBoundary(source) {
	    const { scale ={} , fill  } = source;
	    const pixel = _getTargetPixel(fill, scale);
	    if (isNumberFinite(pixel)) {
	        const horizontal = scale.isHorizontal();
	        return {
	            x: horizontal ? pixel : null,
	            y: horizontal ? null : pixel
	        };
	    }
	    return null;
	}
	function computeCircularBoundary(source) {
	    const { scale , fill  } = source;
	    const options = scale.options;
	    const length = scale.getLabels().length;
	    const start = options.reverse ? scale.max : scale.min;
	    const value = _getTargetValue(fill, scale, start);
	    const target = [];
	    if (options.grid.circular) {
	        const center = scale.getPointPositionForValue(0, start);
	        return new simpleArc({
	            x: center.x,
	            y: center.y,
	            radius: scale.getDistanceFromCenterForValue(value)
	        });
	    }
	    for(let i = 0; i < length; ++i){
	        target.push(scale.getPointPositionForValue(i, value));
	    }
	    return target;
	}

	function _drawfill(ctx, source, area) {
	    const target = _getTarget(source);
	    const { line , scale , axis  } = source;
	    const lineOpts = line.options;
	    const fillOption = lineOpts.fill;
	    const color = lineOpts.backgroundColor;
	    const { above =color , below =color  } = fillOption || {};
	    if (target && line.points.length) {
	        clipArea(ctx, area);
	        doFill(ctx, {
	            line,
	            target,
	            above,
	            below,
	            area,
	            scale,
	            axis
	        });
	        unclipArea(ctx);
	    }
	}
	function doFill(ctx, cfg) {
	    const { line , target , above , below , area , scale  } = cfg;
	    const property = line._loop ? 'angle' : cfg.axis;
	    ctx.save();
	    if (property === 'x' && below !== above) {
	        clipVertical(ctx, target, area.top);
	        fill(ctx, {
	            line,
	            target,
	            color: above,
	            scale,
	            property
	        });
	        ctx.restore();
	        ctx.save();
	        clipVertical(ctx, target, area.bottom);
	    }
	    fill(ctx, {
	        line,
	        target,
	        color: below,
	        scale,
	        property
	    });
	    ctx.restore();
	}
	function clipVertical(ctx, target, clipY) {
	    const { segments , points  } = target;
	    let first = true;
	    let lineLoop = false;
	    ctx.beginPath();
	    for (const segment of segments){
	        const { start , end  } = segment;
	        const firstPoint = points[start];
	        const lastPoint = points[_findSegmentEnd(start, end, points)];
	        if (first) {
	            ctx.moveTo(firstPoint.x, firstPoint.y);
	            first = false;
	        } else {
	            ctx.lineTo(firstPoint.x, clipY);
	            ctx.lineTo(firstPoint.x, firstPoint.y);
	        }
	        lineLoop = !!target.pathSegment(ctx, segment, {
	            move: lineLoop
	        });
	        if (lineLoop) {
	            ctx.closePath();
	        } else {
	            ctx.lineTo(lastPoint.x, clipY);
	        }
	    }
	    ctx.lineTo(target.first().x, clipY);
	    ctx.closePath();
	    ctx.clip();
	}
	function fill(ctx, cfg) {
	    const { line , target , property , color , scale  } = cfg;
	    const segments = _segments(line, target, property);
	    for (const { source: src , target: tgt , start , end  } of segments){
	        const { style: { backgroundColor =color  } = {}  } = src;
	        const notShape = target !== true;
	        ctx.save();
	        ctx.fillStyle = backgroundColor;
	        clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
	        ctx.beginPath();
	        const lineLoop = !!line.pathSegment(ctx, src);
	        let loop;
	        if (notShape) {
	            if (lineLoop) {
	                ctx.closePath();
	            } else {
	                interpolatedLineTo(ctx, target, end, property);
	            }
	            const targetLoop = !!target.pathSegment(ctx, tgt, {
	                move: lineLoop,
	                reverse: true
	            });
	            loop = lineLoop && targetLoop;
	            if (!loop) {
	                interpolatedLineTo(ctx, target, start, property);
	            }
	        }
	        ctx.closePath();
	        ctx.fill(loop ? 'evenodd' : 'nonzero');
	        ctx.restore();
	    }
	}
	function clipBounds(ctx, scale, bounds) {
	    const { top , bottom  } = scale.chart.chartArea;
	    const { property , start , end  } = bounds || {};
	    if (property === 'x') {
	        ctx.beginPath();
	        ctx.rect(start, top, end - start, bottom - top);
	        ctx.clip();
	    }
	}
	function interpolatedLineTo(ctx, target, point, property) {
	    const interpolatedPoint = target.interpolate(point, property);
	    if (interpolatedPoint) {
	        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
	    }
	}

	var index = {
	    id: 'filler',
	    afterDatasetsUpdate (chart, _args, options) {
	        const count = (chart.data.datasets || []).length;
	        const sources = [];
	        let meta, i, line, source;
	        for(i = 0; i < count; ++i){
	            meta = chart.getDatasetMeta(i);
	            line = meta.dataset;
	            source = null;
	            if (line && line.options && line instanceof LineElement) {
	                source = {
	                    visible: chart.isDatasetVisible(i),
	                    index: i,
	                    fill: _decodeFill(line, i, count),
	                    chart,
	                    axis: meta.controller.options.indexAxis,
	                    scale: meta.vScale,
	                    line
	                };
	            }
	            meta.$filler = source;
	            sources.push(source);
	        }
	        for(i = 0; i < count; ++i){
	            source = sources[i];
	            if (!source || source.fill === false) {
	                continue;
	            }
	            source.fill = _resolveTarget(sources, i, options.propagate);
	        }
	    },
	    beforeDraw (chart, _args, options) {
	        const draw = options.drawTime === 'beforeDraw';
	        const metasets = chart.getSortedVisibleDatasetMetas();
	        const area = chart.chartArea;
	        for(let i = metasets.length - 1; i >= 0; --i){
	            const source = metasets[i].$filler;
	            if (!source) {
	                continue;
	            }
	            source.line.updateControlPoints(area, source.axis);
	            if (draw && source.fill) {
	                _drawfill(chart.ctx, source, area);
	            }
	        }
	    },
	    beforeDatasetsDraw (chart, _args, options) {
	        if (options.drawTime !== 'beforeDatasetsDraw') {
	            return;
	        }
	        const metasets = chart.getSortedVisibleDatasetMetas();
	        for(let i = metasets.length - 1; i >= 0; --i){
	            const source = metasets[i].$filler;
	            if (_shouldApplyFill(source)) {
	                _drawfill(chart.ctx, source, chart.chartArea);
	            }
	        }
	    },
	    beforeDatasetDraw (chart, args, options) {
	        const source = args.meta.$filler;
	        if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {
	            return;
	        }
	        _drawfill(chart.ctx, source, chart.chartArea);
	    },
	    defaults: {
	        propagate: true,
	        drawTime: 'beforeDatasetDraw'
	    }
	};

	const getBoxSize = (labelOpts, fontSize)=>{
	    let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;
	    if (labelOpts.usePointStyle) {
	        boxHeight = Math.min(boxHeight, fontSize);
	        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
	    }
	    return {
	        boxWidth,
	        boxHeight,
	        itemHeight: Math.max(fontSize, boxHeight)
	    };
	};
	const itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
	class Legend extends Element {
	 constructor(config){
	        super();
	        this._added = false;
	        this.legendHitBoxes = [];
	 this._hoveredItem = null;
	        this.doughnutMode = false;
	        this.chart = config.chart;
	        this.options = config.options;
	        this.ctx = config.ctx;
	        this.legendItems = undefined;
	        this.columnSizes = undefined;
	        this.lineWidths = undefined;
	        this.maxHeight = undefined;
	        this.maxWidth = undefined;
	        this.top = undefined;
	        this.bottom = undefined;
	        this.left = undefined;
	        this.right = undefined;
	        this.height = undefined;
	        this.width = undefined;
	        this._margins = undefined;
	        this.position = undefined;
	        this.weight = undefined;
	        this.fullSize = undefined;
	    }
	    update(maxWidth, maxHeight, margins) {
	        this.maxWidth = maxWidth;
	        this.maxHeight = maxHeight;
	        this._margins = margins;
	        this.setDimensions();
	        this.buildLabels();
	        this.fit();
	    }
	    setDimensions() {
	        if (this.isHorizontal()) {
	            this.width = this.maxWidth;
	            this.left = this._margins.left;
	            this.right = this.width;
	        } else {
	            this.height = this.maxHeight;
	            this.top = this._margins.top;
	            this.bottom = this.height;
	        }
	    }
	    buildLabels() {
	        const labelOpts = this.options.labels || {};
	        let legendItems = callback(labelOpts.generateLabels, [
	            this.chart
	        ], this) || [];
	        if (labelOpts.filter) {
	            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));
	        }
	        if (labelOpts.sort) {
	            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));
	        }
	        if (this.options.reverse) {
	            legendItems.reverse();
	        }
	        this.legendItems = legendItems;
	    }
	    fit() {
	        const { options , ctx  } = this;
	        if (!options.display) {
	            this.width = this.height = 0;
	            return;
	        }
	        const labelOpts = options.labels;
	        const labelFont = toFont(labelOpts.font);
	        const fontSize = labelFont.size;
	        const titleHeight = this._computeTitleHeight();
	        const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);
	        let width, height;
	        ctx.font = labelFont.string;
	        if (this.isHorizontal()) {
	            width = this.maxWidth;
	            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
	        } else {
	            height = this.maxHeight;
	            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
	        }
	        this.width = Math.min(width, options.maxWidth || this.maxWidth);
	        this.height = Math.min(height, options.maxHeight || this.maxHeight);
	    }
	 _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
	        const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;
	        const hitboxes = this.legendHitBoxes = [];
	        const lineWidths = this.lineWidths = [
	            0
	        ];
	        const lineHeight = itemHeight + padding;
	        let totalHeight = titleHeight;
	        ctx.textAlign = 'left';
	        ctx.textBaseline = 'middle';
	        let row = -1;
	        let top = -lineHeight;
	        this.legendItems.forEach((legendItem, i)=>{
	            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
	            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
	                totalHeight += lineHeight;
	                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
	                top += lineHeight;
	                row++;
	            }
	            hitboxes[i] = {
	                left: 0,
	                top,
	                row,
	                width: itemWidth,
	                height: itemHeight
	            };
	            lineWidths[lineWidths.length - 1] += itemWidth + padding;
	        });
	        return totalHeight;
	    }
	    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
	        const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;
	        const hitboxes = this.legendHitBoxes = [];
	        const columnSizes = this.columnSizes = [];
	        const heightLimit = maxHeight - titleHeight;
	        let totalWidth = padding;
	        let currentColWidth = 0;
	        let currentColHeight = 0;
	        let left = 0;
	        let col = 0;
	        this.legendItems.forEach((legendItem, i)=>{
	            const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
	            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
	                totalWidth += currentColWidth + padding;
	                columnSizes.push({
	                    width: currentColWidth,
	                    height: currentColHeight
	                });
	                left += currentColWidth + padding;
	                col++;
	                currentColWidth = currentColHeight = 0;
	            }
	            hitboxes[i] = {
	                left,
	                top: currentColHeight,
	                col,
	                width: itemWidth,
	                height: itemHeight
	            };
	            currentColWidth = Math.max(currentColWidth, itemWidth);
	            currentColHeight += itemHeight + padding;
	        });
	        totalWidth += currentColWidth;
	        columnSizes.push({
	            width: currentColWidth,
	            height: currentColHeight
	        });
	        return totalWidth;
	    }
	    adjustHitBoxes() {
	        if (!this.options.display) {
	            return;
	        }
	        const titleHeight = this._computeTitleHeight();
	        const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;
	        const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
	        if (this.isHorizontal()) {
	            let row = 0;
	            let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
	            for (const hitbox of hitboxes){
	                if (row !== hitbox.row) {
	                    row = hitbox.row;
	                    left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
	                }
	                hitbox.top += this.top + titleHeight + padding;
	                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
	                left += hitbox.width + padding;
	            }
	        } else {
	            let col = 0;
	            let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
	            for (const hitbox of hitboxes){
	                if (hitbox.col !== col) {
	                    col = hitbox.col;
	                    top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
	                }
	                hitbox.top = top;
	                hitbox.left += this.left + padding;
	                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
	                top += hitbox.height + padding;
	            }
	        }
	    }
	    isHorizontal() {
	        return this.options.position === 'top' || this.options.position === 'bottom';
	    }
	    draw() {
	        if (this.options.display) {
	            const ctx = this.ctx;
	            clipArea(ctx, this);
	            this._draw();
	            unclipArea(ctx);
	        }
	    }
	 _draw() {
	        const { options: opts , columnSizes , lineWidths , ctx  } = this;
	        const { align , labels: labelOpts  } = opts;
	        const defaultColor = defaults.color;
	        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
	        const labelFont = toFont(labelOpts.font);
	        const { padding  } = labelOpts;
	        const fontSize = labelFont.size;
	        const halfFontSize = fontSize / 2;
	        let cursor;
	        this.drawTitle();
	        ctx.textAlign = rtlHelper.textAlign('left');
	        ctx.textBaseline = 'middle';
	        ctx.lineWidth = 0.5;
	        ctx.font = labelFont.string;
	        const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);
	        const drawLegendBox = function(x, y, legendItem) {
	            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
	                return;
	            }
	            ctx.save();
	            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
	            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
	            ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');
	            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
	            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');
	            ctx.lineWidth = lineWidth;
	            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
	            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
	            if (labelOpts.usePointStyle) {
	                const drawOptions = {
	                    radius: boxHeight * Math.SQRT2 / 2,
	                    pointStyle: legendItem.pointStyle,
	                    rotation: legendItem.rotation,
	                    borderWidth: lineWidth
	                };
	                const centerX = rtlHelper.xPlus(x, boxWidth / 2);
	                const centerY = y + halfFontSize;
	                drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
	            } else {
	                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
	                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
	                const borderRadius = toTRBLCorners(legendItem.borderRadius);
	                ctx.beginPath();
	                if (Object.values(borderRadius).some((v)=>v !== 0)) {
	                    addRoundedRectPath(ctx, {
	                        x: xBoxLeft,
	                        y: yBoxTop,
	                        w: boxWidth,
	                        h: boxHeight,
	                        radius: borderRadius
	                    });
	                } else {
	                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
	                }
	                ctx.fill();
	                if (lineWidth !== 0) {
	                    ctx.stroke();
	                }
	            }
	            ctx.restore();
	        };
	        const fillText = function(x, y, legendItem) {
	            renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
	                strikethrough: legendItem.hidden,
	                textAlign: rtlHelper.textAlign(legendItem.textAlign)
	            });
	        };
	        const isHorizontal = this.isHorizontal();
	        const titleHeight = this._computeTitleHeight();
	        if (isHorizontal) {
	            cursor = {
	                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
	                y: this.top + padding + titleHeight,
	                line: 0
	            };
	        } else {
	            cursor = {
	                x: this.left + padding,
	                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
	                line: 0
	            };
	        }
	        overrideTextDirection(this.ctx, opts.textDirection);
	        const lineHeight = itemHeight + padding;
	        this.legendItems.forEach((legendItem, i)=>{
	            ctx.strokeStyle = legendItem.fontColor;
	            ctx.fillStyle = legendItem.fontColor;
	            const textWidth = ctx.measureText(legendItem.text).width;
	            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
	            const width = boxWidth + halfFontSize + textWidth;
	            let x = cursor.x;
	            let y = cursor.y;
	            rtlHelper.setWidth(this.width);
	            if (isHorizontal) {
	                if (i > 0 && x + width + padding > this.right) {
	                    y = cursor.y += lineHeight;
	                    cursor.line++;
	                    x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
	                }
	            } else if (i > 0 && y + lineHeight > this.bottom) {
	                x = cursor.x = x + columnSizes[cursor.line].width + padding;
	                cursor.line++;
	                y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
	            }
	            const realX = rtlHelper.x(x);
	            drawLegendBox(realX, y, legendItem);
	            x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
	            fillText(rtlHelper.x(x), y, legendItem);
	            if (isHorizontal) {
	                cursor.x += width + padding;
	            } else if (typeof legendItem.text !== 'string') {
	                const fontLineHeight = labelFont.lineHeight;
	                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
	            } else {
	                cursor.y += lineHeight;
	            }
	        });
	        restoreTextDirection(this.ctx, opts.textDirection);
	    }
	 drawTitle() {
	        const opts = this.options;
	        const titleOpts = opts.title;
	        const titleFont = toFont(titleOpts.font);
	        const titlePadding = toPadding(titleOpts.padding);
	        if (!titleOpts.display) {
	            return;
	        }
	        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
	        const ctx = this.ctx;
	        const position = titleOpts.position;
	        const halfFontSize = titleFont.size / 2;
	        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
	        let y;
	        let left = this.left;
	        let maxWidth = this.width;
	        if (this.isHorizontal()) {
	            maxWidth = Math.max(...this.lineWidths);
	            y = this.top + topPaddingPlusHalfFontSize;
	            left = _alignStartEnd(opts.align, left, this.right - maxWidth);
	        } else {
	            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);
	            y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
	        }
	        const x = _alignStartEnd(position, left, left + maxWidth);
	        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
	        ctx.textBaseline = 'middle';
	        ctx.strokeStyle = titleOpts.color;
	        ctx.fillStyle = titleOpts.color;
	        ctx.font = titleFont.string;
	        renderText(ctx, titleOpts.text, x, y, titleFont);
	    }
	 _computeTitleHeight() {
	        const titleOpts = this.options.title;
	        const titleFont = toFont(titleOpts.font);
	        const titlePadding = toPadding(titleOpts.padding);
	        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
	    }
	 _getLegendItemAt(x, y) {
	        let i, hitBox, lh;
	        if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
	            lh = this.legendHitBoxes;
	            for(i = 0; i < lh.length; ++i){
	                hitBox = lh[i];
	                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
	                    return this.legendItems[i];
	                }
	            }
	        }
	        return null;
	    }
	 handleEvent(e) {
	        const opts = this.options;
	        if (!isListened(e.type, opts)) {
	            return;
	        }
	        const hoveredItem = this._getLegendItemAt(e.x, e.y);
	        if (e.type === 'mousemove' || e.type === 'mouseout') {
	            const previous = this._hoveredItem;
	            const sameItem = itemsEqual(previous, hoveredItem);
	            if (previous && !sameItem) {
	                callback(opts.onLeave, [
	                    e,
	                    previous,
	                    this
	                ], this);
	            }
	            this._hoveredItem = hoveredItem;
	            if (hoveredItem && !sameItem) {
	                callback(opts.onHover, [
	                    e,
	                    hoveredItem,
	                    this
	                ], this);
	            }
	        } else if (hoveredItem) {
	            callback(opts.onClick, [
	                e,
	                hoveredItem,
	                this
	            ], this);
	        }
	    }
	}
	function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
	    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
	    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
	    return {
	        itemWidth,
	        itemHeight
	    };
	}
	function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
	    let legendItemText = legendItem.text;
	    if (legendItemText && typeof legendItemText !== 'string') {
	        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);
	    }
	    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
	}
	function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
	    let itemHeight = _itemHeight;
	    if (typeof legendItem.text !== 'string') {
	        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
	    }
	    return itemHeight;
	}
	function calculateLegendItemHeight(legendItem, fontLineHeight) {
	    const labelHeight = legendItem.text ? legendItem.text.length : 0;
	    return fontLineHeight * labelHeight;
	}
	function isListened(type, opts) {
	    if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {
	        return true;
	    }
	    if (opts.onClick && (type === 'click' || type === 'mouseup')) {
	        return true;
	    }
	    return false;
	}
	var plugin_legend = {
	    id: 'legend',
	 _element: Legend,
	    start (chart, _args, options) {
	        const legend = chart.legend = new Legend({
	            ctx: chart.ctx,
	            options,
	            chart
	        });
	        layouts.configure(chart, legend, options);
	        layouts.addBox(chart, legend);
	    },
	    stop (chart) {
	        layouts.removeBox(chart, chart.legend);
	        delete chart.legend;
	    },
	    beforeUpdate (chart, _args, options) {
	        const legend = chart.legend;
	        layouts.configure(chart, legend, options);
	        legend.options = options;
	    },
	    afterUpdate (chart) {
	        const legend = chart.legend;
	        legend.buildLabels();
	        legend.adjustHitBoxes();
	    },
	    afterEvent (chart, args) {
	        if (!args.replay) {
	            chart.legend.handleEvent(args.event);
	        }
	    },
	    defaults: {
	        display: true,
	        position: 'top',
	        align: 'center',
	        fullSize: true,
	        reverse: false,
	        weight: 1000,
	        onClick (e, legendItem, legend) {
	            const index = legendItem.datasetIndex;
	            const ci = legend.chart;
	            if (ci.isDatasetVisible(index)) {
	                ci.hide(index);
	                legendItem.hidden = true;
	            } else {
	                ci.show(index);
	                legendItem.hidden = false;
	            }
	        },
	        onHover: null,
	        onLeave: null,
	        labels: {
	            color: (ctx)=>ctx.chart.options.color,
	            boxWidth: 40,
	            padding: 10,
	            generateLabels (chart) {
	                const datasets = chart.data.datasets;
	                const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;
	                return chart._getSortedDatasetMetas().map((meta)=>{
	                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
	                    const borderWidth = toPadding(style.borderWidth);
	                    return {
	                        text: datasets[meta.index].label,
	                        fillStyle: style.backgroundColor,
	                        fontColor: color,
	                        hidden: !meta.visible,
	                        lineCap: style.borderCapStyle,
	                        lineDash: style.borderDash,
	                        lineDashOffset: style.borderDashOffset,
	                        lineJoin: style.borderJoinStyle,
	                        lineWidth: (borderWidth.width + borderWidth.height) / 4,
	                        strokeStyle: style.borderColor,
	                        pointStyle: pointStyle || style.pointStyle,
	                        rotation: style.rotation,
	                        textAlign: textAlign || style.textAlign,
	                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
	                        datasetIndex: meta.index
	                    };
	                }, this);
	            }
	        },
	        title: {
	            color: (ctx)=>ctx.chart.options.color,
	            display: false,
	            position: 'center',
	            text: ''
	        }
	    },
	    descriptors: {
	        _scriptable: (name)=>!name.startsWith('on'),
	        labels: {
	            _scriptable: (name)=>![
	                    'generateLabels',
	                    'filter',
	                    'sort'
	                ].includes(name)
	        }
	    }
	};

	const positioners = {
	 average (items) {
	        if (!items.length) {
	            return false;
	        }
	        let i, len;
	        let xSet = new Set();
	        let y = 0;
	        let count = 0;
	        for(i = 0, len = items.length; i < len; ++i){
	            const el = items[i].element;
	            if (el && el.hasValue()) {
	                const pos = el.tooltipPosition();
	                xSet.add(pos.x);
	                y += pos.y;
	                ++count;
	            }
	        }
	        if (count === 0 || xSet.size === 0) {
	            return false;
	        }
	        const xAverage = [
	            ...xSet
	        ].reduce((a, b)=>a + b) / xSet.size;
	        return {
	            x: xAverage,
	            y: y / count
	        };
	    },
	 nearest (items, eventPosition) {
	        if (!items.length) {
	            return false;
	        }
	        let x = eventPosition.x;
	        let y = eventPosition.y;
	        let minDistance = Number.POSITIVE_INFINITY;
	        let i, len, nearestElement;
	        for(i = 0, len = items.length; i < len; ++i){
	            const el = items[i].element;
	            if (el && el.hasValue()) {
	                const center = el.getCenterPoint();
	                const d = distanceBetweenPoints(eventPosition, center);
	                if (d < minDistance) {
	                    minDistance = d;
	                    nearestElement = el;
	                }
	            }
	        }
	        if (nearestElement) {
	            const tp = nearestElement.tooltipPosition();
	            x = tp.x;
	            y = tp.y;
	        }
	        return {
	            x,
	            y
	        };
	    }
	};
	function pushOrConcat(base, toPush) {
	    if (toPush) {
	        if (isArray$1(toPush)) {
	            Array.prototype.push.apply(base, toPush);
	        } else {
	            base.push(toPush);
	        }
	    }
	    return base;
	}
	 function splitNewlines(str) {
	    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
	        return str.split('\n');
	    }
	    return str;
	}
	 function createTooltipItem(chart, item) {
	    const { element , datasetIndex , index  } = item;
	    const controller = chart.getDatasetMeta(datasetIndex).controller;
	    const { label , value  } = controller.getLabelAndValue(index);
	    return {
	        chart,
	        label,
	        parsed: controller.getParsed(index),
	        raw: chart.data.datasets[datasetIndex].data[index],
	        formattedValue: value,
	        dataset: controller.getDataset(),
	        dataIndex: index,
	        datasetIndex,
	        element
	    };
	}
	 function getTooltipSize(tooltip, options) {
	    const ctx = tooltip.chart.ctx;
	    const { body , footer , title  } = tooltip;
	    const { boxWidth , boxHeight  } = options;
	    const bodyFont = toFont(options.bodyFont);
	    const titleFont = toFont(options.titleFont);
	    const footerFont = toFont(options.footerFont);
	    const titleLineCount = title.length;
	    const footerLineCount = footer.length;
	    const bodyLineItemCount = body.length;
	    const padding = toPadding(options.padding);
	    let height = padding.height;
	    let width = 0;
	    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
	    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
	    if (titleLineCount) {
	        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
	    }
	    if (combinedBodyLength) {
	        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
	        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
	    }
	    if (footerLineCount) {
	        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
	    }
	    let widthPadding = 0;
	    const maxLineWidth = function(line) {
	        width = Math.max(width, ctx.measureText(line).width + widthPadding);
	    };
	    ctx.save();
	    ctx.font = titleFont.string;
	    each(tooltip.title, maxLineWidth);
	    ctx.font = bodyFont.string;
	    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
	    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
	    each(body, (bodyItem)=>{
	        each(bodyItem.before, maxLineWidth);
	        each(bodyItem.lines, maxLineWidth);
	        each(bodyItem.after, maxLineWidth);
	    });
	    widthPadding = 0;
	    ctx.font = footerFont.string;
	    each(tooltip.footer, maxLineWidth);
	    ctx.restore();
	    width += padding.width;
	    return {
	        width,
	        height
	    };
	}
	function determineYAlign(chart, size) {
	    const { y , height  } = size;
	    if (y < height / 2) {
	        return 'top';
	    } else if (y > chart.height - height / 2) {
	        return 'bottom';
	    }
	    return 'center';
	}
	function doesNotFitWithAlign(xAlign, chart, options, size) {
	    const { x , width  } = size;
	    const caret = options.caretSize + options.caretPadding;
	    if (xAlign === 'left' && x + width + caret > chart.width) {
	        return true;
	    }
	    if (xAlign === 'right' && x - width - caret < 0) {
	        return true;
	    }
	}
	function determineXAlign(chart, options, size, yAlign) {
	    const { x , width  } = size;
	    const { width: chartWidth , chartArea: { left , right  }  } = chart;
	    let xAlign = 'center';
	    if (yAlign === 'center') {
	        xAlign = x <= (left + right) / 2 ? 'left' : 'right';
	    } else if (x <= width / 2) {
	        xAlign = 'left';
	    } else if (x >= chartWidth - width / 2) {
	        xAlign = 'right';
	    }
	    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
	        xAlign = 'center';
	    }
	    return xAlign;
	}
	 function determineAlignment(chart, options, size) {
	    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
	    return {
	        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
	        yAlign
	    };
	}
	function alignX(size, xAlign) {
	    let { x , width  } = size;
	    if (xAlign === 'right') {
	        x -= width;
	    } else if (xAlign === 'center') {
	        x -= width / 2;
	    }
	    return x;
	}
	function alignY(size, yAlign, paddingAndSize) {
	    let { y , height  } = size;
	    if (yAlign === 'top') {
	        y += paddingAndSize;
	    } else if (yAlign === 'bottom') {
	        y -= height + paddingAndSize;
	    } else {
	        y -= height / 2;
	    }
	    return y;
	}
	 function getBackgroundPoint(options, size, alignment, chart) {
	    const { caretSize , caretPadding , cornerRadius  } = options;
	    const { xAlign , yAlign  } = alignment;
	    const paddingAndSize = caretSize + caretPadding;
	    const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);
	    let x = alignX(size, xAlign);
	    const y = alignY(size, yAlign, paddingAndSize);
	    if (yAlign === 'center') {
	        if (xAlign === 'left') {
	            x += paddingAndSize;
	        } else if (xAlign === 'right') {
	            x -= paddingAndSize;
	        }
	    } else if (xAlign === 'left') {
	        x -= Math.max(topLeft, bottomLeft) + caretSize;
	    } else if (xAlign === 'right') {
	        x += Math.max(topRight, bottomRight) + caretSize;
	    }
	    return {
	        x: _limitValue(x, 0, chart.width - size.width),
	        y: _limitValue(y, 0, chart.height - size.height)
	    };
	}
	function getAlignedX(tooltip, align, options) {
	    const padding = toPadding(options.padding);
	    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
	}
	 function getBeforeAfterBodyLines(callback) {
	    return pushOrConcat([], splitNewlines(callback));
	}
	function createTooltipContext(parent, tooltip, tooltipItems) {
	    return createContext(parent, {
	        tooltip,
	        tooltipItems,
	        type: 'tooltip'
	    });
	}
	function overrideCallbacks(callbacks, context) {
	    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
	    return override ? callbacks.override(override) : callbacks;
	}
	const defaultCallbacks = {
	    beforeTitle: noop,
	    title (tooltipItems) {
	        if (tooltipItems.length > 0) {
	            const item = tooltipItems[0];
	            const labels = item.chart.data.labels;
	            const labelCount = labels ? labels.length : 0;
	            if (this && this.options && this.options.mode === 'dataset') {
	                return item.dataset.label || '';
	            } else if (item.label) {
	                return item.label;
	            } else if (labelCount > 0 && item.dataIndex < labelCount) {
	                return labels[item.dataIndex];
	            }
	        }
	        return '';
	    },
	    afterTitle: noop,
	    beforeBody: noop,
	    beforeLabel: noop,
	    label (tooltipItem) {
	        if (this && this.options && this.options.mode === 'dataset') {
	            return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
	        }
	        let label = tooltipItem.dataset.label || '';
	        if (label) {
	            label += ': ';
	        }
	        const value = tooltipItem.formattedValue;
	        if (!isNullOrUndef(value)) {
	            label += value;
	        }
	        return label;
	    },
	    labelColor (tooltipItem) {
	        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
	        const options = meta.controller.getStyle(tooltipItem.dataIndex);
	        return {
	            borderColor: options.borderColor,
	            backgroundColor: options.backgroundColor,
	            borderWidth: options.borderWidth,
	            borderDash: options.borderDash,
	            borderDashOffset: options.borderDashOffset,
	            borderRadius: 0
	        };
	    },
	    labelTextColor () {
	        return this.options.bodyColor;
	    },
	    labelPointStyle (tooltipItem) {
	        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
	        const options = meta.controller.getStyle(tooltipItem.dataIndex);
	        return {
	            pointStyle: options.pointStyle,
	            rotation: options.rotation
	        };
	    },
	    afterLabel: noop,
	    afterBody: noop,
	    beforeFooter: noop,
	    footer: noop,
	    afterFooter: noop
	};
	 function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
	    const result = callbacks[name].call(ctx, arg);
	    if (typeof result === 'undefined') {
	        return defaultCallbacks[name].call(ctx, arg);
	    }
	    return result;
	}
	class Tooltip extends Element {
	 static positioners = positioners;
	    constructor(config){
	        super();
	        this.opacity = 0;
	        this._active = [];
	        this._eventPosition = undefined;
	        this._size = undefined;
	        this._cachedAnimations = undefined;
	        this._tooltipItems = [];
	        this.$animations = undefined;
	        this.$context = undefined;
	        this.chart = config.chart;
	        this.options = config.options;
	        this.dataPoints = undefined;
	        this.title = undefined;
	        this.beforeBody = undefined;
	        this.body = undefined;
	        this.afterBody = undefined;
	        this.footer = undefined;
	        this.xAlign = undefined;
	        this.yAlign = undefined;
	        this.x = undefined;
	        this.y = undefined;
	        this.height = undefined;
	        this.width = undefined;
	        this.caretX = undefined;
	        this.caretY = undefined;
	        this.labelColors = undefined;
	        this.labelPointStyles = undefined;
	        this.labelTextColors = undefined;
	    }
	    initialize(options) {
	        this.options = options;
	        this._cachedAnimations = undefined;
	        this.$context = undefined;
	    }
	 _resolveAnimations() {
	        const cached = this._cachedAnimations;
	        if (cached) {
	            return cached;
	        }
	        const chart = this.chart;
	        const options = this.options.setContext(this.getContext());
	        const opts = options.enabled && chart.options.animation && options.animations;
	        const animations = new Animations(this.chart, opts);
	        if (opts._cacheable) {
	            this._cachedAnimations = Object.freeze(animations);
	        }
	        return animations;
	    }
	 getContext() {
	        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
	    }
	    getTitle(context, options) {
	        const { callbacks  } = options;
	        const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);
	        const title = invokeCallbackWithFallback(callbacks, 'title', this, context);
	        const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);
	        let lines = [];
	        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
	        lines = pushOrConcat(lines, splitNewlines(title));
	        lines = pushOrConcat(lines, splitNewlines(afterTitle));
	        return lines;
	    }
	    getBeforeBody(tooltipItems, options) {
	        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));
	    }
	    getBody(tooltipItems, options) {
	        const { callbacks  } = options;
	        const bodyItems = [];
	        each(tooltipItems, (context)=>{
	            const bodyItem = {
	                before: [],
	                lines: [],
	                after: []
	            };
	            const scoped = overrideCallbacks(callbacks, context);
	            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));
	            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));
	            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));
	            bodyItems.push(bodyItem);
	        });
	        return bodyItems;
	    }
	    getAfterBody(tooltipItems, options) {
	        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));
	    }
	    getFooter(tooltipItems, options) {
	        const { callbacks  } = options;
	        const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);
	        const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);
	        const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);
	        let lines = [];
	        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
	        lines = pushOrConcat(lines, splitNewlines(footer));
	        lines = pushOrConcat(lines, splitNewlines(afterFooter));
	        return lines;
	    }
	 _createItems(options) {
	        const active = this._active;
	        const data = this.chart.data;
	        const labelColors = [];
	        const labelPointStyles = [];
	        const labelTextColors = [];
	        let tooltipItems = [];
	        let i, len;
	        for(i = 0, len = active.length; i < len; ++i){
	            tooltipItems.push(createTooltipItem(this.chart, active[i]));
	        }
	        if (options.filter) {
	            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));
	        }
	        if (options.itemSort) {
	            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));
	        }
	        each(tooltipItems, (context)=>{
	            const scoped = overrideCallbacks(options.callbacks, context);
	            labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));
	            labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));
	            labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));
	        });
	        this.labelColors = labelColors;
	        this.labelPointStyles = labelPointStyles;
	        this.labelTextColors = labelTextColors;
	        this.dataPoints = tooltipItems;
	        return tooltipItems;
	    }
	    update(changed, replay) {
	        const options = this.options.setContext(this.getContext());
	        const active = this._active;
	        let properties;
	        let tooltipItems = [];
	        if (!active.length) {
	            if (this.opacity !== 0) {
	                properties = {
	                    opacity: 0
	                };
	            }
	        } else {
	            const position = positioners[options.position].call(this, active, this._eventPosition);
	            tooltipItems = this._createItems(options);
	            this.title = this.getTitle(tooltipItems, options);
	            this.beforeBody = this.getBeforeBody(tooltipItems, options);
	            this.body = this.getBody(tooltipItems, options);
	            this.afterBody = this.getAfterBody(tooltipItems, options);
	            this.footer = this.getFooter(tooltipItems, options);
	            const size = this._size = getTooltipSize(this, options);
	            const positionAndSize = Object.assign({}, position, size);
	            const alignment = determineAlignment(this.chart, options, positionAndSize);
	            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
	            this.xAlign = alignment.xAlign;
	            this.yAlign = alignment.yAlign;
	            properties = {
	                opacity: 1,
	                x: backgroundPoint.x,
	                y: backgroundPoint.y,
	                width: size.width,
	                height: size.height,
	                caretX: position.x,
	                caretY: position.y
	            };
	        }
	        this._tooltipItems = tooltipItems;
	        this.$context = undefined;
	        if (properties) {
	            this._resolveAnimations().update(this, properties);
	        }
	        if (changed && options.external) {
	            options.external.call(this, {
	                chart: this.chart,
	                tooltip: this,
	                replay
	            });
	        }
	    }
	    drawCaret(tooltipPoint, ctx, size, options) {
	        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
	        ctx.lineTo(caretPosition.x1, caretPosition.y1);
	        ctx.lineTo(caretPosition.x2, caretPosition.y2);
	        ctx.lineTo(caretPosition.x3, caretPosition.y3);
	    }
	    getCaretPosition(tooltipPoint, size, options) {
	        const { xAlign , yAlign  } = this;
	        const { caretSize , cornerRadius  } = options;
	        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);
	        const { x: ptX , y: ptY  } = tooltipPoint;
	        const { width , height  } = size;
	        let x1, x2, x3, y1, y2, y3;
	        if (yAlign === 'center') {
	            y2 = ptY + height / 2;
	            if (xAlign === 'left') {
	                x1 = ptX;
	                x2 = x1 - caretSize;
	                y1 = y2 + caretSize;
	                y3 = y2 - caretSize;
	            } else {
	                x1 = ptX + width;
	                x2 = x1 + caretSize;
	                y1 = y2 - caretSize;
	                y3 = y2 + caretSize;
	            }
	            x3 = x1;
	        } else {
	            if (xAlign === 'left') {
	                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
	            } else if (xAlign === 'right') {
	                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
	            } else {
	                x2 = this.caretX;
	            }
	            if (yAlign === 'top') {
	                y1 = ptY;
	                y2 = y1 - caretSize;
	                x1 = x2 - caretSize;
	                x3 = x2 + caretSize;
	            } else {
	                y1 = ptY + height;
	                y2 = y1 + caretSize;
	                x1 = x2 + caretSize;
	                x3 = x2 - caretSize;
	            }
	            y3 = y1;
	        }
	        return {
	            x1,
	            x2,
	            x3,
	            y1,
	            y2,
	            y3
	        };
	    }
	    drawTitle(pt, ctx, options) {
	        const title = this.title;
	        const length = title.length;
	        let titleFont, titleSpacing, i;
	        if (length) {
	            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
	            pt.x = getAlignedX(this, options.titleAlign, options);
	            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
	            ctx.textBaseline = 'middle';
	            titleFont = toFont(options.titleFont);
	            titleSpacing = options.titleSpacing;
	            ctx.fillStyle = options.titleColor;
	            ctx.font = titleFont.string;
	            for(i = 0; i < length; ++i){
	                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
	                pt.y += titleFont.lineHeight + titleSpacing;
	                if (i + 1 === length) {
	                    pt.y += options.titleMarginBottom - titleSpacing;
	                }
	            }
	        }
	    }
	 _drawColorBox(ctx, pt, i, rtlHelper, options) {
	        const labelColor = this.labelColors[i];
	        const labelPointStyle = this.labelPointStyles[i];
	        const { boxHeight , boxWidth  } = options;
	        const bodyFont = toFont(options.bodyFont);
	        const colorX = getAlignedX(this, 'left', options);
	        const rtlColorX = rtlHelper.x(colorX);
	        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
	        const colorY = pt.y + yOffSet;
	        if (options.usePointStyle) {
	            const drawOptions = {
	                radius: Math.min(boxWidth, boxHeight) / 2,
	                pointStyle: labelPointStyle.pointStyle,
	                rotation: labelPointStyle.rotation,
	                borderWidth: 1
	            };
	            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
	            const centerY = colorY + boxHeight / 2;
	            ctx.strokeStyle = options.multiKeyBackground;
	            ctx.fillStyle = options.multiKeyBackground;
	            drawPoint(ctx, drawOptions, centerX, centerY);
	            ctx.strokeStyle = labelColor.borderColor;
	            ctx.fillStyle = labelColor.backgroundColor;
	            drawPoint(ctx, drawOptions, centerX, centerY);
	        } else {
	            ctx.lineWidth = isObject$1(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
	            ctx.strokeStyle = labelColor.borderColor;
	            ctx.setLineDash(labelColor.borderDash || []);
	            ctx.lineDashOffset = labelColor.borderDashOffset || 0;
	            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
	            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
	            const borderRadius = toTRBLCorners(labelColor.borderRadius);
	            if (Object.values(borderRadius).some((v)=>v !== 0)) {
	                ctx.beginPath();
	                ctx.fillStyle = options.multiKeyBackground;
	                addRoundedRectPath(ctx, {
	                    x: outerX,
	                    y: colorY,
	                    w: boxWidth,
	                    h: boxHeight,
	                    radius: borderRadius
	                });
	                ctx.fill();
	                ctx.stroke();
	                ctx.fillStyle = labelColor.backgroundColor;
	                ctx.beginPath();
	                addRoundedRectPath(ctx, {
	                    x: innerX,
	                    y: colorY + 1,
	                    w: boxWidth - 2,
	                    h: boxHeight - 2,
	                    radius: borderRadius
	                });
	                ctx.fill();
	            } else {
	                ctx.fillStyle = options.multiKeyBackground;
	                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
	                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
	                ctx.fillStyle = labelColor.backgroundColor;
	                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
	            }
	        }
	        ctx.fillStyle = this.labelTextColors[i];
	    }
	    drawBody(pt, ctx, options) {
	        const { body  } = this;
	        const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;
	        const bodyFont = toFont(options.bodyFont);
	        let bodyLineHeight = bodyFont.lineHeight;
	        let xLinePadding = 0;
	        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
	        const fillLineOfText = function(line) {
	            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
	            pt.y += bodyLineHeight + bodySpacing;
	        };
	        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
	        let bodyItem, textColor, lines, i, j, ilen, jlen;
	        ctx.textAlign = bodyAlign;
	        ctx.textBaseline = 'middle';
	        ctx.font = bodyFont.string;
	        pt.x = getAlignedX(this, bodyAlignForCalculation, options);
	        ctx.fillStyle = options.bodyColor;
	        each(this.beforeBody, fillLineOfText);
	        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
	        for(i = 0, ilen = body.length; i < ilen; ++i){
	            bodyItem = body[i];
	            textColor = this.labelTextColors[i];
	            ctx.fillStyle = textColor;
	            each(bodyItem.before, fillLineOfText);
	            lines = bodyItem.lines;
	            if (displayColors && lines.length) {
	                this._drawColorBox(ctx, pt, i, rtlHelper, options);
	                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
	            }
	            for(j = 0, jlen = lines.length; j < jlen; ++j){
	                fillLineOfText(lines[j]);
	                bodyLineHeight = bodyFont.lineHeight;
	            }
	            each(bodyItem.after, fillLineOfText);
	        }
	        xLinePadding = 0;
	        bodyLineHeight = bodyFont.lineHeight;
	        each(this.afterBody, fillLineOfText);
	        pt.y -= bodySpacing;
	    }
	    drawFooter(pt, ctx, options) {
	        const footer = this.footer;
	        const length = footer.length;
	        let footerFont, i;
	        if (length) {
	            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
	            pt.x = getAlignedX(this, options.footerAlign, options);
	            pt.y += options.footerMarginTop;
	            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
	            ctx.textBaseline = 'middle';
	            footerFont = toFont(options.footerFont);
	            ctx.fillStyle = options.footerColor;
	            ctx.font = footerFont.string;
	            for(i = 0; i < length; ++i){
	                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
	                pt.y += footerFont.lineHeight + options.footerSpacing;
	            }
	        }
	    }
	    drawBackground(pt, ctx, tooltipSize, options) {
	        const { xAlign , yAlign  } = this;
	        const { x , y  } = pt;
	        const { width , height  } = tooltipSize;
	        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(options.cornerRadius);
	        ctx.fillStyle = options.backgroundColor;
	        ctx.strokeStyle = options.borderColor;
	        ctx.lineWidth = options.borderWidth;
	        ctx.beginPath();
	        ctx.moveTo(x + topLeft, y);
	        if (yAlign === 'top') {
	            this.drawCaret(pt, ctx, tooltipSize, options);
	        }
	        ctx.lineTo(x + width - topRight, y);
	        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
	        if (yAlign === 'center' && xAlign === 'right') {
	            this.drawCaret(pt, ctx, tooltipSize, options);
	        }
	        ctx.lineTo(x + width, y + height - bottomRight);
	        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
	        if (yAlign === 'bottom') {
	            this.drawCaret(pt, ctx, tooltipSize, options);
	        }
	        ctx.lineTo(x + bottomLeft, y + height);
	        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
	        if (yAlign === 'center' && xAlign === 'left') {
	            this.drawCaret(pt, ctx, tooltipSize, options);
	        }
	        ctx.lineTo(x, y + topLeft);
	        ctx.quadraticCurveTo(x, y, x + topLeft, y);
	        ctx.closePath();
	        ctx.fill();
	        if (options.borderWidth > 0) {
	            ctx.stroke();
	        }
	    }
	 _updateAnimationTarget(options) {
	        const chart = this.chart;
	        const anims = this.$animations;
	        const animX = anims && anims.x;
	        const animY = anims && anims.y;
	        if (animX || animY) {
	            const position = positioners[options.position].call(this, this._active, this._eventPosition);
	            if (!position) {
	                return;
	            }
	            const size = this._size = getTooltipSize(this, options);
	            const positionAndSize = Object.assign({}, position, this._size);
	            const alignment = determineAlignment(chart, options, positionAndSize);
	            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
	            if (animX._to !== point.x || animY._to !== point.y) {
	                this.xAlign = alignment.xAlign;
	                this.yAlign = alignment.yAlign;
	                this.width = size.width;
	                this.height = size.height;
	                this.caretX = position.x;
	                this.caretY = position.y;
	                this._resolveAnimations().update(this, point);
	            }
	        }
	    }
	 _willRender() {
	        return !!this.opacity;
	    }
	    draw(ctx) {
	        const options = this.options.setContext(this.getContext());
	        let opacity = this.opacity;
	        if (!opacity) {
	            return;
	        }
	        this._updateAnimationTarget(options);
	        const tooltipSize = {
	            width: this.width,
	            height: this.height
	        };
	        const pt = {
	            x: this.x,
	            y: this.y
	        };
	        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
	        const padding = toPadding(options.padding);
	        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
	        if (options.enabled && hasTooltipContent) {
	            ctx.save();
	            ctx.globalAlpha = opacity;
	            this.drawBackground(pt, ctx, tooltipSize, options);
	            overrideTextDirection(ctx, options.textDirection);
	            pt.y += padding.top;
	            this.drawTitle(pt, ctx, options);
	            this.drawBody(pt, ctx, options);
	            this.drawFooter(pt, ctx, options);
	            restoreTextDirection(ctx, options.textDirection);
	            ctx.restore();
	        }
	    }
	 getActiveElements() {
	        return this._active || [];
	    }
	 setActiveElements(activeElements, eventPosition) {
	        const lastActive = this._active;
	        const active = activeElements.map(({ datasetIndex , index  })=>{
	            const meta = this.chart.getDatasetMeta(datasetIndex);
	            if (!meta) {
	                throw new Error('Cannot find a dataset at index ' + datasetIndex);
	            }
	            return {
	                datasetIndex,
	                element: meta.data[index],
	                index
	            };
	        });
	        const changed = !_elementsEqual(lastActive, active);
	        const positionChanged = this._positionChanged(active, eventPosition);
	        if (changed || positionChanged) {
	            this._active = active;
	            this._eventPosition = eventPosition;
	            this._ignoreReplayEvents = true;
	            this.update(true);
	        }
	    }
	 handleEvent(e, replay, inChartArea = true) {
	        if (replay && this._ignoreReplayEvents) {
	            return false;
	        }
	        this._ignoreReplayEvents = false;
	        const options = this.options;
	        const lastActive = this._active || [];
	        const active = this._getActiveElements(e, lastActive, replay, inChartArea);
	        const positionChanged = this._positionChanged(active, e);
	        const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
	        if (changed) {
	            this._active = active;
	            if (options.enabled || options.external) {
	                this._eventPosition = {
	                    x: e.x,
	                    y: e.y
	                };
	                this.update(true, replay);
	            }
	        }
	        return changed;
	    }
	 _getActiveElements(e, lastActive, replay, inChartArea) {
	        const options = this.options;
	        if (e.type === 'mouseout') {
	            return [];
	        }
	        if (!inChartArea) {
	            return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);
	        }
	        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
	        if (options.reverse) {
	            active.reverse();
	        }
	        return active;
	    }
	 _positionChanged(active, e) {
	        const { caretX , caretY , options  } = this;
	        const position = positioners[options.position].call(this, active, e);
	        return position !== false && (caretX !== position.x || caretY !== position.y);
	    }
	}
	var plugin_tooltip = {
	    id: 'tooltip',
	    _element: Tooltip,
	    positioners,
	    afterInit (chart, _args, options) {
	        if (options) {
	            chart.tooltip = new Tooltip({
	                chart,
	                options
	            });
	        }
	    },
	    beforeUpdate (chart, _args, options) {
	        if (chart.tooltip) {
	            chart.tooltip.initialize(options);
	        }
	    },
	    reset (chart, _args, options) {
	        if (chart.tooltip) {
	            chart.tooltip.initialize(options);
	        }
	    },
	    afterDraw (chart) {
	        const tooltip = chart.tooltip;
	        if (tooltip && tooltip._willRender()) {
	            const args = {
	                tooltip
	            };
	            if (chart.notifyPlugins('beforeTooltipDraw', {
	                ...args,
	                cancelable: true
	            }) === false) {
	                return;
	            }
	            tooltip.draw(chart.ctx);
	            chart.notifyPlugins('afterTooltipDraw', args);
	        }
	    },
	    afterEvent (chart, args) {
	        if (chart.tooltip) {
	            const useFinalPosition = args.replay;
	            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
	                args.changed = true;
	            }
	        }
	    },
	    defaults: {
	        enabled: true,
	        external: null,
	        position: 'average',
	        backgroundColor: 'rgba(0,0,0,0.8)',
	        titleColor: '#fff',
	        titleFont: {
	            weight: 'bold'
	        },
	        titleSpacing: 2,
	        titleMarginBottom: 6,
	        titleAlign: 'left',
	        bodyColor: '#fff',
	        bodySpacing: 2,
	        bodyFont: {},
	        bodyAlign: 'left',
	        footerColor: '#fff',
	        footerSpacing: 2,
	        footerMarginTop: 6,
	        footerFont: {
	            weight: 'bold'
	        },
	        footerAlign: 'left',
	        padding: 6,
	        caretPadding: 2,
	        caretSize: 5,
	        cornerRadius: 6,
	        boxHeight: (ctx, opts)=>opts.bodyFont.size,
	        boxWidth: (ctx, opts)=>opts.bodyFont.size,
	        multiKeyBackground: '#fff',
	        displayColors: true,
	        boxPadding: 0,
	        borderColor: 'rgba(0,0,0,0)',
	        borderWidth: 0,
	        animation: {
	            duration: 400,
	            easing: 'easeOutQuart'
	        },
	        animations: {
	            numbers: {
	                type: 'number',
	                properties: [
	                    'x',
	                    'y',
	                    'width',
	                    'height',
	                    'caretX',
	                    'caretY'
	                ]
	            },
	            opacity: {
	                easing: 'linear',
	                duration: 200
	            }
	        },
	        callbacks: defaultCallbacks
	    },
	    defaultRoutes: {
	        bodyFont: 'font',
	        footerFont: 'font',
	        titleFont: 'font'
	    },
	    descriptors: {
	        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',
	        _indexable: false,
	        callbacks: {
	            _scriptable: false,
	            _indexable: false
	        },
	        animation: {
	            _fallback: false
	        },
	        animations: {
	            _fallback: 'animation'
	        }
	    },
	    additionalOptionScopes: [
	        'interaction'
	    ]
	};

	const addIfString = (labels, raw, index, addedLabels)=>{
	    if (typeof raw === 'string') {
	        index = labels.push(raw) - 1;
	        addedLabels.unshift({
	            index,
	            label: raw
	        });
	    } else if (isNaN(raw)) {
	        index = null;
	    }
	    return index;
	};
	function findOrAddLabel(labels, raw, index, addedLabels) {
	    const first = labels.indexOf(raw);
	    if (first === -1) {
	        return addIfString(labels, raw, index, addedLabels);
	    }
	    const last = labels.lastIndexOf(raw);
	    return first !== last ? index : first;
	}
	const validIndex = (index, max)=>index === null ? null : _limitValue(Math.round(index), 0, max);
	function _getLabelForValue(value) {
	    const labels = this.getLabels();
	    if (value >= 0 && value < labels.length) {
	        return labels[value];
	    }
	    return value;
	}
	class CategoryScale extends Scale {
	    static id = 'category';
	 static defaults = {
	        ticks: {
	            callback: _getLabelForValue
	        }
	    };
	    constructor(cfg){
	        super(cfg);
	         this._startValue = undefined;
	        this._valueRange = 0;
	        this._addedLabels = [];
	    }
	    init(scaleOptions) {
	        const added = this._addedLabels;
	        if (added.length) {
	            const labels = this.getLabels();
	            for (const { index , label  } of added){
	                if (labels[index] === label) {
	                    labels.splice(index, 1);
	                }
	            }
	            this._addedLabels = [];
	        }
	        super.init(scaleOptions);
	    }
	    parse(raw, index) {
	        if (isNullOrUndef(raw)) {
	            return null;
	        }
	        const labels = this.getLabels();
	        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
	        return validIndex(index, labels.length - 1);
	    }
	    determineDataLimits() {
	        const { minDefined , maxDefined  } = this.getUserBounds();
	        let { min , max  } = this.getMinMax(true);
	        if (this.options.bounds === 'ticks') {
	            if (!minDefined) {
	                min = 0;
	            }
	            if (!maxDefined) {
	                max = this.getLabels().length - 1;
	            }
	        }
	        this.min = min;
	        this.max = max;
	    }
	    buildTicks() {
	        const min = this.min;
	        const max = this.max;
	        const offset = this.options.offset;
	        const ticks = [];
	        let labels = this.getLabels();
	        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
	        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
	        this._startValue = this.min - (offset ? 0.5 : 0);
	        for(let value = min; value <= max; value++){
	            ticks.push({
	                value
	            });
	        }
	        return ticks;
	    }
	    getLabelForValue(value) {
	        return _getLabelForValue.call(this, value);
	    }
	 configure() {
	        super.configure();
	        if (!this.isHorizontal()) {
	            this._reversePixels = !this._reversePixels;
	        }
	    }
	    getPixelForValue(value) {
	        if (typeof value !== 'number') {
	            value = this.parse(value);
	        }
	        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
	    }
	    getPixelForTick(index) {
	        const ticks = this.ticks;
	        if (index < 0 || index > ticks.length - 1) {
	            return null;
	        }
	        return this.getPixelForValue(ticks[index].value);
	    }
	    getValueForPixel(pixel) {
	        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
	    }
	    getBasePixel() {
	        return this.bottom;
	    }
	}

	function generateTicks$1(generationOptions, dataRange) {
	    const ticks = [];
	    const MIN_SPACING = 1e-14;
	    const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;
	    const unit = step || 1;
	    const maxSpaces = maxTicks - 1;
	    const { min: rmin , max: rmax  } = dataRange;
	    const minDefined = !isNullOrUndef(min);
	    const maxDefined = !isNullOrUndef(max);
	    const countDefined = !isNullOrUndef(count);
	    const minSpacing = (rmax - rmin) / (maxDigits + 1);
	    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
	    let factor, niceMin, niceMax, numSpaces;
	    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
	        return [
	            {
	                value: rmin
	            },
	            {
	                value: rmax
	            }
	        ];
	    }
	    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
	    if (numSpaces > maxSpaces) {
	        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
	    }
	    if (!isNullOrUndef(precision)) {
	        factor = Math.pow(10, precision);
	        spacing = Math.ceil(spacing * factor) / factor;
	    }
	    if (bounds === 'ticks') {
	        niceMin = Math.floor(rmin / spacing) * spacing;
	        niceMax = Math.ceil(rmax / spacing) * spacing;
	    } else {
	        niceMin = rmin;
	        niceMax = rmax;
	    }
	    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {
	        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
	        spacing = (max - min) / numSpaces;
	        niceMin = min;
	        niceMax = max;
	    } else if (countDefined) {
	        niceMin = minDefined ? min : niceMin;
	        niceMax = maxDefined ? max : niceMax;
	        numSpaces = count - 1;
	        spacing = (niceMax - niceMin) / numSpaces;
	    } else {
	        numSpaces = (niceMax - niceMin) / spacing;
	        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
	            numSpaces = Math.round(numSpaces);
	        } else {
	            numSpaces = Math.ceil(numSpaces);
	        }
	    }
	    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
	    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
	    niceMin = Math.round(niceMin * factor) / factor;
	    niceMax = Math.round(niceMax * factor) / factor;
	    let j = 0;
	    if (minDefined) {
	        if (includeBounds && niceMin !== min) {
	            ticks.push({
	                value: min
	            });
	            if (niceMin < min) {
	                j++;
	            }
	            if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
	                j++;
	            }
	        } else if (niceMin < min) {
	            j++;
	        }
	    }
	    for(; j < numSpaces; ++j){
	        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
	        if (maxDefined && tickValue > max) {
	            break;
	        }
	        ticks.push({
	            value: tickValue
	        });
	    }
	    if (maxDefined && includeBounds && niceMax !== max) {
	        if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
	            ticks[ticks.length - 1].value = max;
	        } else {
	            ticks.push({
	                value: max
	            });
	        }
	    } else if (!maxDefined || niceMax === max) {
	        ticks.push({
	            value: niceMax
	        });
	    }
	    return ticks;
	}
	function relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {
	    const rad = toRadians(minRotation);
	    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
	    const length = 0.75 * minSpacing * ('' + value).length;
	    return Math.min(minSpacing / ratio, length);
	}
	class LinearScaleBase extends Scale {
	    constructor(cfg){
	        super(cfg);
	         this.start = undefined;
	         this.end = undefined;
	         this._startValue = undefined;
	         this._endValue = undefined;
	        this._valueRange = 0;
	    }
	    parse(raw, index) {
	        if (isNullOrUndef(raw)) {
	            return null;
	        }
	        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
	            return null;
	        }
	        return +raw;
	    }
	    handleTickRangeOptions() {
	        const { beginAtZero  } = this.options;
	        const { minDefined , maxDefined  } = this.getUserBounds();
	        let { min , max  } = this;
	        const setMin = (v)=>min = minDefined ? min : v;
	        const setMax = (v)=>max = maxDefined ? max : v;
	        if (beginAtZero) {
	            const minSign = sign(min);
	            const maxSign = sign(max);
	            if (minSign < 0 && maxSign < 0) {
	                setMax(0);
	            } else if (minSign > 0 && maxSign > 0) {
	                setMin(0);
	            }
	        }
	        if (min === max) {
	            let offset = max === 0 ? 1 : Math.abs(max * 0.05);
	            setMax(max + offset);
	            if (!beginAtZero) {
	                setMin(min - offset);
	            }
	        }
	        this.min = min;
	        this.max = max;
	    }
	    getTickLimit() {
	        const tickOpts = this.options.ticks;
	        let { maxTicksLimit , stepSize  } = tickOpts;
	        let maxTicks;
	        if (stepSize) {
	            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
	            if (maxTicks > 1000) {
	                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
	                maxTicks = 1000;
	            }
	        } else {
	            maxTicks = this.computeTickLimit();
	            maxTicksLimit = maxTicksLimit || 11;
	        }
	        if (maxTicksLimit) {
	            maxTicks = Math.min(maxTicksLimit, maxTicks);
	        }
	        return maxTicks;
	    }
	 computeTickLimit() {
	        return Number.POSITIVE_INFINITY;
	    }
	    buildTicks() {
	        const opts = this.options;
	        const tickOpts = opts.ticks;
	        let maxTicks = this.getTickLimit();
	        maxTicks = Math.max(2, maxTicks);
	        const numericGeneratorOptions = {
	            maxTicks,
	            bounds: opts.bounds,
	            min: opts.min,
	            max: opts.max,
	            precision: tickOpts.precision,
	            step: tickOpts.stepSize,
	            count: tickOpts.count,
	            maxDigits: this._maxDigits(),
	            horizontal: this.isHorizontal(),
	            minRotation: tickOpts.minRotation || 0,
	            includeBounds: tickOpts.includeBounds !== false
	        };
	        const dataRange = this._range || this;
	        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
	        if (opts.bounds === 'ticks') {
	            _setMinAndMaxByKey(ticks, this, 'value');
	        }
	        if (opts.reverse) {
	            ticks.reverse();
	            this.start = this.max;
	            this.end = this.min;
	        } else {
	            this.start = this.min;
	            this.end = this.max;
	        }
	        return ticks;
	    }
	 configure() {
	        const ticks = this.ticks;
	        let start = this.min;
	        let end = this.max;
	        super.configure();
	        if (this.options.offset && ticks.length) {
	            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
	            start -= offset;
	            end += offset;
	        }
	        this._startValue = start;
	        this._endValue = end;
	        this._valueRange = end - start;
	    }
	    getLabelForValue(value) {
	        return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
	    }
	}

	class LinearScale extends LinearScaleBase {
	    static id = 'linear';
	 static defaults = {
	        ticks: {
	            callback: Ticks.formatters.numeric
	        }
	    };
	    determineDataLimits() {
	        const { min , max  } = this.getMinMax(true);
	        this.min = isNumberFinite(min) ? min : 0;
	        this.max = isNumberFinite(max) ? max : 1;
	        this.handleTickRangeOptions();
	    }
	 computeTickLimit() {
	        const horizontal = this.isHorizontal();
	        const length = horizontal ? this.width : this.height;
	        const minRotation = toRadians(this.options.ticks.minRotation);
	        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
	        const tickFont = this._resolveTickFontOptions(0);
	        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
	    }
	    getPixelForValue(value) {
	        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
	    }
	    getValueForPixel(pixel) {
	        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
	    }
	}

	const log10Floor = (v)=>Math.floor(log10(v));
	const changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);
	function isMajor(tickVal) {
	    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
	    return remain === 1;
	}
	function steps(min, max, rangeExp) {
	    const rangeStep = Math.pow(10, rangeExp);
	    const start = Math.floor(min / rangeStep);
	    const end = Math.ceil(max / rangeStep);
	    return end - start;
	}
	function startExp(min, max) {
	    const range = max - min;
	    let rangeExp = log10Floor(range);
	    while(steps(min, max, rangeExp) > 10){
	        rangeExp++;
	    }
	    while(steps(min, max, rangeExp) < 10){
	        rangeExp--;
	    }
	    return Math.min(rangeExp, log10Floor(min));
	}
	 function generateTicks(generationOptions, { min , max  }) {
	    min = finiteOrDefault(generationOptions.min, min);
	    const ticks = [];
	    const minExp = log10Floor(min);
	    let exp = startExp(min, max);
	    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
	    const stepSize = Math.pow(10, exp);
	    const base = minExp > exp ? Math.pow(10, minExp) : 0;
	    const start = Math.round((min - base) * precision) / precision;
	    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
	    let significand = Math.floor((start - offset) / Math.pow(10, exp));
	    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
	    while(value < max){
	        ticks.push({
	            value,
	            major: isMajor(value),
	            significand
	        });
	        if (significand >= 10) {
	            significand = significand < 15 ? 15 : 20;
	        } else {
	            significand++;
	        }
	        if (significand >= 20) {
	            exp++;
	            significand = 2;
	            precision = exp >= 0 ? 1 : precision;
	        }
	        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
	    }
	    const lastTick = finiteOrDefault(generationOptions.max, value);
	    ticks.push({
	        value: lastTick,
	        major: isMajor(lastTick),
	        significand
	    });
	    return ticks;
	}
	class LogarithmicScale extends Scale {
	    static id = 'logarithmic';
	 static defaults = {
	        ticks: {
	            callback: Ticks.formatters.logarithmic,
	            major: {
	                enabled: true
	            }
	        }
	    };
	    constructor(cfg){
	        super(cfg);
	         this.start = undefined;
	         this.end = undefined;
	         this._startValue = undefined;
	        this._valueRange = 0;
	    }
	    parse(raw, index) {
	        const value = LinearScaleBase.prototype.parse.apply(this, [
	            raw,
	            index
	        ]);
	        if (value === 0) {
	            this._zero = true;
	            return undefined;
	        }
	        return isNumberFinite(value) && value > 0 ? value : null;
	    }
	    determineDataLimits() {
	        const { min , max  } = this.getMinMax(true);
	        this.min = isNumberFinite(min) ? Math.max(0, min) : null;
	        this.max = isNumberFinite(max) ? Math.max(0, max) : null;
	        if (this.options.beginAtZero) {
	            this._zero = true;
	        }
	        if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
	            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
	        }
	        this.handleTickRangeOptions();
	    }
	    handleTickRangeOptions() {
	        const { minDefined , maxDefined  } = this.getUserBounds();
	        let min = this.min;
	        let max = this.max;
	        const setMin = (v)=>min = minDefined ? min : v;
	        const setMax = (v)=>max = maxDefined ? max : v;
	        if (min === max) {
	            if (min <= 0) {
	                setMin(1);
	                setMax(10);
	            } else {
	                setMin(changeExponent(min, -1));
	                setMax(changeExponent(max, +1));
	            }
	        }
	        if (min <= 0) {
	            setMin(changeExponent(max, -1));
	        }
	        if (max <= 0) {
	            setMax(changeExponent(min, +1));
	        }
	        this.min = min;
	        this.max = max;
	    }
	    buildTicks() {
	        const opts = this.options;
	        const generationOptions = {
	            min: this._userMin,
	            max: this._userMax
	        };
	        const ticks = generateTicks(generationOptions, this);
	        if (opts.bounds === 'ticks') {
	            _setMinAndMaxByKey(ticks, this, 'value');
	        }
	        if (opts.reverse) {
	            ticks.reverse();
	            this.start = this.max;
	            this.end = this.min;
	        } else {
	            this.start = this.min;
	            this.end = this.max;
	        }
	        return ticks;
	    }
	 getLabelForValue(value) {
	        return value === undefined ? '0' : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
	    }
	 configure() {
	        const start = this.min;
	        super.configure();
	        this._startValue = log10(start);
	        this._valueRange = log10(this.max) - log10(start);
	    }
	    getPixelForValue(value) {
	        if (value === undefined || value === 0) {
	            value = this.min;
	        }
	        if (value === null || isNaN(value)) {
	            return NaN;
	        }
	        return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
	    }
	    getValueForPixel(pixel) {
	        const decimal = this.getDecimalForPixel(pixel);
	        return Math.pow(10, this._startValue + decimal * this._valueRange);
	    }
	}

	function getTickBackdropHeight(opts) {
	    const tickOpts = opts.ticks;
	    if (tickOpts.display && opts.display) {
	        const padding = toPadding(tickOpts.backdropPadding);
	        return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
	    }
	    return 0;
	}
	function measureLabelSize(ctx, font, label) {
	    label = isArray$1(label) ? label : [
	        label
	    ];
	    return {
	        w: _longestText(ctx, font.string, label),
	        h: label.length * font.lineHeight
	    };
	}
	function determineLimits(angle, pos, size, min, max) {
	    if (angle === min || angle === max) {
	        return {
	            start: pos - size / 2,
	            end: pos + size / 2
	        };
	    } else if (angle < min || angle > max) {
	        return {
	            start: pos - size,
	            end: pos
	        };
	    }
	    return {
	        start: pos,
	        end: pos + size
	    };
	}
	 function fitWithPointLabels(scale) {
	    const orig = {
	        l: scale.left + scale._padding.left,
	        r: scale.right - scale._padding.right,
	        t: scale.top + scale._padding.top,
	        b: scale.bottom - scale._padding.bottom
	    };
	    const limits = Object.assign({}, orig);
	    const labelSizes = [];
	    const padding = [];
	    const valueCount = scale._pointLabels.length;
	    const pointLabelOpts = scale.options.pointLabels;
	    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
	    for(let i = 0; i < valueCount; i++){
	        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
	        padding[i] = opts.padding;
	        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
	        const plFont = toFont(opts.font);
	        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
	        labelSizes[i] = textSize;
	        const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
	        const angle = Math.round(toDegrees(angleRadians));
	        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
	        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
	        updateLimits(limits, orig, angleRadians, hLimits, vLimits);
	    }
	    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
	    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
	}
	function updateLimits(limits, orig, angle, hLimits, vLimits) {
	    const sin = Math.abs(Math.sin(angle));
	    const cos = Math.abs(Math.cos(angle));
	    let x = 0;
	    let y = 0;
	    if (hLimits.start < orig.l) {
	        x = (orig.l - hLimits.start) / sin;
	        limits.l = Math.min(limits.l, orig.l - x);
	    } else if (hLimits.end > orig.r) {
	        x = (hLimits.end - orig.r) / sin;
	        limits.r = Math.max(limits.r, orig.r + x);
	    }
	    if (vLimits.start < orig.t) {
	        y = (orig.t - vLimits.start) / cos;
	        limits.t = Math.min(limits.t, orig.t - y);
	    } else if (vLimits.end > orig.b) {
	        y = (vLimits.end - orig.b) / cos;
	        limits.b = Math.max(limits.b, orig.b + y);
	    }
	}
	function createPointLabelItem(scale, index, itemOpts) {
	    const outerDistance = scale.drawingArea;
	    const { extra , additionalAngle , padding , size  } = itemOpts;
	    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
	    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
	    const y = yForAngle(pointLabelPosition.y, size.h, angle);
	    const textAlign = getTextAlignForAngle(angle);
	    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
	    return {
	        visible: true,
	        x: pointLabelPosition.x,
	        y,
	        textAlign,
	        left,
	        top: y,
	        right: left + size.w,
	        bottom: y + size.h
	    };
	}
	function isNotOverlapped(item, area) {
	    if (!area) {
	        return true;
	    }
	    const { left , top , right , bottom  } = item;
	    const apexesInArea = _isPointInArea({
	        x: left,
	        y: top
	    }, area) || _isPointInArea({
	        x: left,
	        y: bottom
	    }, area) || _isPointInArea({
	        x: right,
	        y: top
	    }, area) || _isPointInArea({
	        x: right,
	        y: bottom
	    }, area);
	    return !apexesInArea;
	}
	function buildPointLabelItems(scale, labelSizes, padding) {
	    const items = [];
	    const valueCount = scale._pointLabels.length;
	    const opts = scale.options;
	    const { centerPointLabels , display  } = opts.pointLabels;
	    const itemOpts = {
	        extra: getTickBackdropHeight(opts) / 2,
	        additionalAngle: centerPointLabels ? PI / valueCount : 0
	    };
	    let area;
	    for(let i = 0; i < valueCount; i++){
	        itemOpts.padding = padding[i];
	        itemOpts.size = labelSizes[i];
	        const item = createPointLabelItem(scale, i, itemOpts);
	        items.push(item);
	        if (display === 'auto') {
	            item.visible = isNotOverlapped(item, area);
	            if (item.visible) {
	                area = item;
	            }
	        }
	    }
	    return items;
	}
	function getTextAlignForAngle(angle) {
	    if (angle === 0 || angle === 180) {
	        return 'center';
	    } else if (angle < 180) {
	        return 'left';
	    }
	    return 'right';
	}
	function leftForTextAlign(x, w, align) {
	    if (align === 'right') {
	        x -= w;
	    } else if (align === 'center') {
	        x -= w / 2;
	    }
	    return x;
	}
	function yForAngle(y, h, angle) {
	    if (angle === 90 || angle === 270) {
	        y -= h / 2;
	    } else if (angle > 270 || angle < 90) {
	        y -= h;
	    }
	    return y;
	}
	function drawPointLabelBox(ctx, opts, item) {
	    const { left , top , right , bottom  } = item;
	    const { backdropColor  } = opts;
	    if (!isNullOrUndef(backdropColor)) {
	        const borderRadius = toTRBLCorners(opts.borderRadius);
	        const padding = toPadding(opts.backdropPadding);
	        ctx.fillStyle = backdropColor;
	        const backdropLeft = left - padding.left;
	        const backdropTop = top - padding.top;
	        const backdropWidth = right - left + padding.width;
	        const backdropHeight = bottom - top + padding.height;
	        if (Object.values(borderRadius).some((v)=>v !== 0)) {
	            ctx.beginPath();
	            addRoundedRectPath(ctx, {
	                x: backdropLeft,
	                y: backdropTop,
	                w: backdropWidth,
	                h: backdropHeight,
	                radius: borderRadius
	            });
	            ctx.fill();
	        } else {
	            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
	        }
	    }
	}
	function drawPointLabels(scale, labelCount) {
	    const { ctx , options: { pointLabels  }  } = scale;
	    for(let i = labelCount - 1; i >= 0; i--){
	        const item = scale._pointLabelItems[i];
	        if (!item.visible) {
	            continue;
	        }
	        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
	        drawPointLabelBox(ctx, optsAtIndex, item);
	        const plFont = toFont(optsAtIndex.font);
	        const { x , y , textAlign  } = item;
	        renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
	            color: optsAtIndex.color,
	            textAlign: textAlign,
	            textBaseline: 'middle'
	        });
	    }
	}
	function pathRadiusLine(scale, radius, circular, labelCount) {
	    const { ctx  } = scale;
	    if (circular) {
	        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
	    } else {
	        let pointPosition = scale.getPointPosition(0, radius);
	        ctx.moveTo(pointPosition.x, pointPosition.y);
	        for(let i = 1; i < labelCount; i++){
	            pointPosition = scale.getPointPosition(i, radius);
	            ctx.lineTo(pointPosition.x, pointPosition.y);
	        }
	    }
	}
	function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
	    const ctx = scale.ctx;
	    const circular = gridLineOpts.circular;
	    const { color , lineWidth  } = gridLineOpts;
	    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {
	        return;
	    }
	    ctx.save();
	    ctx.strokeStyle = color;
	    ctx.lineWidth = lineWidth;
	    ctx.setLineDash(borderOpts.dash);
	    ctx.lineDashOffset = borderOpts.dashOffset;
	    ctx.beginPath();
	    pathRadiusLine(scale, radius, circular, labelCount);
	    ctx.closePath();
	    ctx.stroke();
	    ctx.restore();
	}
	function createPointLabelContext(parent, index, label) {
	    return createContext(parent, {
	        label,
	        index,
	        type: 'pointLabel'
	    });
	}
	class RadialLinearScale extends LinearScaleBase {
	    static id = 'radialLinear';
	 static defaults = {
	        display: true,
	        animate: true,
	        position: 'chartArea',
	        angleLines: {
	            display: true,
	            lineWidth: 1,
	            borderDash: [],
	            borderDashOffset: 0.0
	        },
	        grid: {
	            circular: false
	        },
	        startAngle: 0,
	        ticks: {
	            showLabelBackdrop: true,
	            callback: Ticks.formatters.numeric
	        },
	        pointLabels: {
	            backdropColor: undefined,
	            backdropPadding: 2,
	            display: true,
	            font: {
	                size: 10
	            },
	            callback (label) {
	                return label;
	            },
	            padding: 5,
	            centerPointLabels: false
	        }
	    };
	    static defaultRoutes = {
	        'angleLines.color': 'borderColor',
	        'pointLabels.color': 'color',
	        'ticks.color': 'color'
	    };
	    static descriptors = {
	        angleLines: {
	            _fallback: 'grid'
	        }
	    };
	    constructor(cfg){
	        super(cfg);
	         this.xCenter = undefined;
	         this.yCenter = undefined;
	         this.drawingArea = undefined;
	         this._pointLabels = [];
	        this._pointLabelItems = [];
	    }
	    setDimensions() {
	        const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
	        const w = this.width = this.maxWidth - padding.width;
	        const h = this.height = this.maxHeight - padding.height;
	        this.xCenter = Math.floor(this.left + w / 2 + padding.left);
	        this.yCenter = Math.floor(this.top + h / 2 + padding.top);
	        this.drawingArea = Math.floor(Math.min(w, h) / 2);
	    }
	    determineDataLimits() {
	        const { min , max  } = this.getMinMax(false);
	        this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
	        this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
	        this.handleTickRangeOptions();
	    }
	 computeTickLimit() {
	        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
	    }
	    generateTickLabels(ticks) {
	        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
	        this._pointLabels = this.getLabels().map((value, index)=>{
	            const label = callback(this.options.pointLabels.callback, [
	                value,
	                index
	            ], this);
	            return label || label === 0 ? label : '';
	        }).filter((v, i)=>this.chart.getDataVisibility(i));
	    }
	    fit() {
	        const opts = this.options;
	        if (opts.display && opts.pointLabels.display) {
	            fitWithPointLabels(this);
	        } else {
	            this.setCenterPoint(0, 0, 0, 0);
	        }
	    }
	    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
	        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
	        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
	        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
	    }
	    getIndexAngle(index) {
	        const angleMultiplier = TAU / (this._pointLabels.length || 1);
	        const startAngle = this.options.startAngle || 0;
	        return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
	    }
	    getDistanceFromCenterForValue(value) {
	        if (isNullOrUndef(value)) {
	            return NaN;
	        }
	        const scalingFactor = this.drawingArea / (this.max - this.min);
	        if (this.options.reverse) {
	            return (this.max - value) * scalingFactor;
	        }
	        return (value - this.min) * scalingFactor;
	    }
	    getValueForDistanceFromCenter(distance) {
	        if (isNullOrUndef(distance)) {
	            return NaN;
	        }
	        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
	        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
	    }
	    getPointLabelContext(index) {
	        const pointLabels = this._pointLabels || [];
	        if (index >= 0 && index < pointLabels.length) {
	            const pointLabel = pointLabels[index];
	            return createPointLabelContext(this.getContext(), index, pointLabel);
	        }
	    }
	    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
	        const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
	        return {
	            x: Math.cos(angle) * distanceFromCenter + this.xCenter,
	            y: Math.sin(angle) * distanceFromCenter + this.yCenter,
	            angle
	        };
	    }
	    getPointPositionForValue(index, value) {
	        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
	    }
	    getBasePosition(index) {
	        return this.getPointPositionForValue(index || 0, this.getBaseValue());
	    }
	    getPointLabelPosition(index) {
	        const { left , top , right , bottom  } = this._pointLabelItems[index];
	        return {
	            left,
	            top,
	            right,
	            bottom
	        };
	    }
	 drawBackground() {
	        const { backgroundColor , grid: { circular  }  } = this.options;
	        if (backgroundColor) {
	            const ctx = this.ctx;
	            ctx.save();
	            ctx.beginPath();
	            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
	            ctx.closePath();
	            ctx.fillStyle = backgroundColor;
	            ctx.fill();
	            ctx.restore();
	        }
	    }
	 drawGrid() {
	        const ctx = this.ctx;
	        const opts = this.options;
	        const { angleLines , grid , border  } = opts;
	        const labelCount = this._pointLabels.length;
	        let i, offset, position;
	        if (opts.pointLabels.display) {
	            drawPointLabels(this, labelCount);
	        }
	        if (grid.display) {
	            this.ticks.forEach((tick, index)=>{
	                if (index !== 0 || index === 0 && this.min < 0) {
	                    offset = this.getDistanceFromCenterForValue(tick.value);
	                    const context = this.getContext(index);
	                    const optsAtIndex = grid.setContext(context);
	                    const optsAtIndexBorder = border.setContext(context);
	                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
	                }
	            });
	        }
	        if (angleLines.display) {
	            ctx.save();
	            for(i = labelCount - 1; i >= 0; i--){
	                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
	                const { color , lineWidth  } = optsAtIndex;
	                if (!lineWidth || !color) {
	                    continue;
	                }
	                ctx.lineWidth = lineWidth;
	                ctx.strokeStyle = color;
	                ctx.setLineDash(optsAtIndex.borderDash);
	                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
	                offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
	                position = this.getPointPosition(i, offset);
	                ctx.beginPath();
	                ctx.moveTo(this.xCenter, this.yCenter);
	                ctx.lineTo(position.x, position.y);
	                ctx.stroke();
	            }
	            ctx.restore();
	        }
	    }
	 drawBorder() {}
	 drawLabels() {
	        const ctx = this.ctx;
	        const opts = this.options;
	        const tickOpts = opts.ticks;
	        if (!tickOpts.display) {
	            return;
	        }
	        const startAngle = this.getIndexAngle(0);
	        let offset, width;
	        ctx.save();
	        ctx.translate(this.xCenter, this.yCenter);
	        ctx.rotate(startAngle);
	        ctx.textAlign = 'center';
	        ctx.textBaseline = 'middle';
	        this.ticks.forEach((tick, index)=>{
	            if (index === 0 && this.min >= 0 && !opts.reverse) {
	                return;
	            }
	            const optsAtIndex = tickOpts.setContext(this.getContext(index));
	            const tickFont = toFont(optsAtIndex.font);
	            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
	            if (optsAtIndex.showLabelBackdrop) {
	                ctx.font = tickFont.string;
	                width = ctx.measureText(tick.label).width;
	                ctx.fillStyle = optsAtIndex.backdropColor;
	                const padding = toPadding(optsAtIndex.backdropPadding);
	                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
	            }
	            renderText(ctx, tick.label, 0, -offset, tickFont, {
	                color: optsAtIndex.color,
	                strokeColor: optsAtIndex.textStrokeColor,
	                strokeWidth: optsAtIndex.textStrokeWidth
	            });
	        });
	        ctx.restore();
	    }
	 drawTitle() {}
	}

	const INTERVALS = {
	    millisecond: {
	        common: true,
	        size: 1,
	        steps: 1000
	    },
	    second: {
	        common: true,
	        size: 1000,
	        steps: 60
	    },
	    minute: {
	        common: true,
	        size: 60000,
	        steps: 60
	    },
	    hour: {
	        common: true,
	        size: 3600000,
	        steps: 24
	    },
	    day: {
	        common: true,
	        size: 86400000,
	        steps: 30
	    },
	    week: {
	        common: false,
	        size: 604800000,
	        steps: 4
	    },
	    month: {
	        common: true,
	        size: 2.628e9,
	        steps: 12
	    },
	    quarter: {
	        common: false,
	        size: 7.884e9,
	        steps: 4
	    },
	    year: {
	        common: true,
	        size: 3.154e10
	    }
	};
	 const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);
	 function sorter(a, b) {
	    return a - b;
	}
	 function parse(scale, input) {
	    if (isNullOrUndef(input)) {
	        return null;
	    }
	    const adapter = scale._adapter;
	    const { parser , round , isoWeekday  } = scale._parseOpts;
	    let value = input;
	    if (typeof parser === 'function') {
	        value = parser(value);
	    }
	    if (!isNumberFinite(value)) {
	        value = typeof parser === 'string' ? adapter.parse(value,  parser) : adapter.parse(value);
	    }
	    if (value === null) {
	        return null;
	    }
	    if (round) {
	        value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);
	    }
	    return +value;
	}
	 function determineUnitForAutoTicks(minUnit, min, max, capacity) {
	    const ilen = UNITS.length;
	    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){
	        const interval = INTERVALS[UNITS[i]];
	        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
	        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
	            return UNITS[i];
	        }
	    }
	    return UNITS[ilen - 1];
	}
	 function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
	    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){
	        const unit = UNITS[i];
	        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
	            return unit;
	        }
	    }
	    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
	}
	 function determineMajorUnit(unit) {
	    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){
	        if (INTERVALS[UNITS[i]].common) {
	            return UNITS[i];
	        }
	    }
	}
	 function addTick(ticks, time, timestamps) {
	    if (!timestamps) {
	        ticks[time] = true;
	    } else if (timestamps.length) {
	        const { lo , hi  } = _lookup(timestamps, time);
	        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
	        ticks[timestamp] = true;
	    }
	}
	 function setMajorTicks(scale, ticks, map, majorUnit) {
	    const adapter = scale._adapter;
	    const first = +adapter.startOf(ticks[0].value, majorUnit);
	    const last = ticks[ticks.length - 1].value;
	    let major, index;
	    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){
	        index = map[major];
	        if (index >= 0) {
	            ticks[index].major = true;
	        }
	    }
	    return ticks;
	}
	 function ticksFromTimestamps(scale, values, majorUnit) {
	    const ticks = [];
	     const map = {};
	    const ilen = values.length;
	    let i, value;
	    for(i = 0; i < ilen; ++i){
	        value = values[i];
	        map[value] = i;
	        ticks.push({
	            value,
	            major: false
	        });
	    }
	    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
	}
	class TimeScale extends Scale {
	    static id = 'time';
	 static defaults = {
	 bounds: 'data',
	        adapters: {},
	        time: {
	            parser: false,
	            unit: false,
	            round: false,
	            isoWeekday: false,
	            minUnit: 'millisecond',
	            displayFormats: {}
	        },
	        ticks: {
	 source: 'auto',
	            callback: false,
	            major: {
	                enabled: false
	            }
	        }
	    };
	 constructor(props){
	        super(props);
	         this._cache = {
	            data: [],
	            labels: [],
	            all: []
	        };
	         this._unit = 'day';
	         this._majorUnit = undefined;
	        this._offsets = {};
	        this._normalized = false;
	        this._parseOpts = undefined;
	    }
	    init(scaleOpts, opts = {}) {
	        const time = scaleOpts.time || (scaleOpts.time = {});
	         const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
	        adapter.init(opts);
	        mergeIf(time.displayFormats, adapter.formats());
	        this._parseOpts = {
	            parser: time.parser,
	            round: time.round,
	            isoWeekday: time.isoWeekday
	        };
	        super.init(scaleOpts);
	        this._normalized = opts.normalized;
	    }
	 parse(raw, index) {
	        if (raw === undefined) {
	            return null;
	        }
	        return parse(this, raw);
	    }
	    beforeLayout() {
	        super.beforeLayout();
	        this._cache = {
	            data: [],
	            labels: [],
	            all: []
	        };
	    }
	    determineDataLimits() {
	        const options = this.options;
	        const adapter = this._adapter;
	        const unit = options.time.unit || 'day';
	        let { min , max , minDefined , maxDefined  } = this.getUserBounds();
	 function _applyBounds(bounds) {
	            if (!minDefined && !isNaN(bounds.min)) {
	                min = Math.min(min, bounds.min);
	            }
	            if (!maxDefined && !isNaN(bounds.max)) {
	                max = Math.max(max, bounds.max);
	            }
	        }
	        if (!minDefined || !maxDefined) {
	            _applyBounds(this._getLabelBounds());
	            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
	                _applyBounds(this.getMinMax(false));
	            }
	        }
	        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
	        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
	        this.min = Math.min(min, max - 1);
	        this.max = Math.max(min + 1, max);
	    }
	 _getLabelBounds() {
	        const arr = this.getLabelTimestamps();
	        let min = Number.POSITIVE_INFINITY;
	        let max = Number.NEGATIVE_INFINITY;
	        if (arr.length) {
	            min = arr[0];
	            max = arr[arr.length - 1];
	        }
	        return {
	            min,
	            max
	        };
	    }
	 buildTicks() {
	        const options = this.options;
	        const timeOpts = options.time;
	        const tickOpts = options.ticks;
	        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
	        if (options.bounds === 'ticks' && timestamps.length) {
	            this.min = this._userMin || timestamps[0];
	            this.max = this._userMax || timestamps[timestamps.length - 1];
	        }
	        const min = this.min;
	        const max = this.max;
	        const ticks = _filterBetween(timestamps, min, max);
	        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
	        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);
	        this.initOffsets(timestamps);
	        if (options.reverse) {
	            ticks.reverse();
	        }
	        return ticksFromTimestamps(this, ticks, this._majorUnit);
	    }
	    afterAutoSkip() {
	        if (this.options.offsetAfterAutoskip) {
	            this.initOffsets(this.ticks.map((tick)=>+tick.value));
	        }
	    }
	 initOffsets(timestamps = []) {
	        let start = 0;
	        let end = 0;
	        let first, last;
	        if (this.options.offset && timestamps.length) {
	            first = this.getDecimalForValue(timestamps[0]);
	            if (timestamps.length === 1) {
	                start = 1 - first;
	            } else {
	                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
	            }
	            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
	            if (timestamps.length === 1) {
	                end = last;
	            } else {
	                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
	            }
	        }
	        const limit = timestamps.length < 3 ? 0.5 : 0.25;
	        start = _limitValue(start, 0, limit);
	        end = _limitValue(end, 0, limit);
	        this._offsets = {
	            start,
	            end,
	            factor: 1 / (start + 1 + end)
	        };
	    }
	 _generate() {
	        const adapter = this._adapter;
	        const min = this.min;
	        const max = this.max;
	        const options = this.options;
	        const timeOpts = options.time;
	        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
	        const stepSize = valueOrDefault(options.ticks.stepSize, 1);
	        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
	        const hasWeekday = isNumber(weekday) || weekday === true;
	        const ticks = {};
	        let first = min;
	        let time, count;
	        if (hasWeekday) {
	            first = +adapter.startOf(first, 'isoWeek', weekday);
	        }
	        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
	        if (adapter.diff(max, min, minor) > 100000 * stepSize) {
	            throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
	        }
	        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
	        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){
	            addTick(ticks, time, timestamps);
	        }
	        if (time === max || options.bounds === 'ticks' || count === 1) {
	            addTick(ticks, time, timestamps);
	        }
	        return Object.keys(ticks).sort(sorter).map((x)=>+x);
	    }
	 getLabelForValue(value) {
	        const adapter = this._adapter;
	        const timeOpts = this.options.time;
	        if (timeOpts.tooltipFormat) {
	            return adapter.format(value, timeOpts.tooltipFormat);
	        }
	        return adapter.format(value, timeOpts.displayFormats.datetime);
	    }
	 format(value, format) {
	        const options = this.options;
	        const formats = options.time.displayFormats;
	        const unit = this._unit;
	        const fmt = format || formats[unit];
	        return this._adapter.format(value, fmt);
	    }
	 _tickFormatFunction(time, index, ticks, format) {
	        const options = this.options;
	        const formatter = options.ticks.callback;
	        if (formatter) {
	            return callback(formatter, [
	                time,
	                index,
	                ticks
	            ], this);
	        }
	        const formats = options.time.displayFormats;
	        const unit = this._unit;
	        const majorUnit = this._majorUnit;
	        const minorFormat = unit && formats[unit];
	        const majorFormat = majorUnit && formats[majorUnit];
	        const tick = ticks[index];
	        const major = majorUnit && majorFormat && tick && tick.major;
	        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
	    }
	 generateTickLabels(ticks) {
	        let i, ilen, tick;
	        for(i = 0, ilen = ticks.length; i < ilen; ++i){
	            tick = ticks[i];
	            tick.label = this._tickFormatFunction(tick.value, i, ticks);
	        }
	    }
	 getDecimalForValue(value) {
	        return value === null ? NaN : (value - this.min) / (this.max - this.min);
	    }
	 getPixelForValue(value) {
	        const offsets = this._offsets;
	        const pos = this.getDecimalForValue(value);
	        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
	    }
	 getValueForPixel(pixel) {
	        const offsets = this._offsets;
	        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
	        return this.min + pos * (this.max - this.min);
	    }
	 _getLabelSize(label) {
	        const ticksOpts = this.options.ticks;
	        const tickLabelWidth = this.ctx.measureText(label).width;
	        const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
	        const cosRotation = Math.cos(angle);
	        const sinRotation = Math.sin(angle);
	        const tickFontSize = this._resolveTickFontOptions(0).size;
	        return {
	            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
	            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
	        };
	    }
	 _getLabelCapacity(exampleTime) {
	        const timeOpts = this.options.time;
	        const displayFormats = timeOpts.displayFormats;
	        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
	        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
	            exampleTime
	        ], this._majorUnit), format);
	        const size = this._getLabelSize(exampleLabel);
	        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
	        return capacity > 0 ? capacity : 1;
	    }
	 getDataTimestamps() {
	        let timestamps = this._cache.data || [];
	        let i, ilen;
	        if (timestamps.length) {
	            return timestamps;
	        }
	        const metas = this.getMatchingVisibleMetas();
	        if (this._normalized && metas.length) {
	            return this._cache.data = metas[0].controller.getAllParsedValues(this);
	        }
	        for(i = 0, ilen = metas.length; i < ilen; ++i){
	            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
	        }
	        return this._cache.data = this.normalize(timestamps);
	    }
	 getLabelTimestamps() {
	        const timestamps = this._cache.labels || [];
	        let i, ilen;
	        if (timestamps.length) {
	            return timestamps;
	        }
	        const labels = this.getLabels();
	        for(i = 0, ilen = labels.length; i < ilen; ++i){
	            timestamps.push(parse(this, labels[i]));
	        }
	        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
	    }
	 normalize(values) {
	        return _arrayUnique(values.sort(sorter));
	    }
	}

	function interpolate(table, val, reverse) {
	    let lo = 0;
	    let hi = table.length - 1;
	    let prevSource, nextSource, prevTarget, nextTarget;
	    if (reverse) {
	        if (val >= table[lo].pos && val <= table[hi].pos) {
	            ({ lo , hi  } = _lookupByKey(table, 'pos', val));
	        }
	        ({ pos: prevSource , time: prevTarget  } = table[lo]);
	        ({ pos: nextSource , time: nextTarget  } = table[hi]);
	    } else {
	        if (val >= table[lo].time && val <= table[hi].time) {
	            ({ lo , hi  } = _lookupByKey(table, 'time', val));
	        }
	        ({ time: prevSource , pos: prevTarget  } = table[lo]);
	        ({ time: nextSource , pos: nextTarget  } = table[hi]);
	    }
	    const span = nextSource - prevSource;
	    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
	}
	class TimeSeriesScale extends TimeScale {
	    static id = 'timeseries';
	 static defaults = TimeScale.defaults;
	 constructor(props){
	        super(props);
	         this._table = [];
	         this._minPos = undefined;
	         this._tableRange = undefined;
	    }
	 initOffsets() {
	        const timestamps = this._getTimestampsForTable();
	        const table = this._table = this.buildLookupTable(timestamps);
	        this._minPos = interpolate(table, this.min);
	        this._tableRange = interpolate(table, this.max) - this._minPos;
	        super.initOffsets(timestamps);
	    }
	 buildLookupTable(timestamps) {
	        const { min , max  } = this;
	        const items = [];
	        const table = [];
	        let i, ilen, prev, curr, next;
	        for(i = 0, ilen = timestamps.length; i < ilen; ++i){
	            curr = timestamps[i];
	            if (curr >= min && curr <= max) {
	                items.push(curr);
	            }
	        }
	        if (items.length < 2) {
	            return [
	                {
	                    time: min,
	                    pos: 0
	                },
	                {
	                    time: max,
	                    pos: 1
	                }
	            ];
	        }
	        for(i = 0, ilen = items.length; i < ilen; ++i){
	            next = items[i + 1];
	            prev = items[i - 1];
	            curr = items[i];
	            if (Math.round((next + prev) / 2) !== curr) {
	                table.push({
	                    time: curr,
	                    pos: i / (ilen - 1)
	                });
	            }
	        }
	        return table;
	    }
	 _generate() {
	        const min = this.min;
	        const max = this.max;
	        let timestamps = super.getDataTimestamps();
	        if (!timestamps.includes(min) || !timestamps.length) {
	            timestamps.splice(0, 0, min);
	        }
	        if (!timestamps.includes(max) || timestamps.length === 1) {
	            timestamps.push(max);
	        }
	        return timestamps.sort((a, b)=>a - b);
	    }
	 _getTimestampsForTable() {
	        let timestamps = this._cache.all || [];
	        if (timestamps.length) {
	            return timestamps;
	        }
	        const data = this.getDataTimestamps();
	        const label = this.getLabelTimestamps();
	        if (data.length && label.length) {
	            timestamps = this.normalize(data.concat(label));
	        } else {
	            timestamps = data.length ? data : label;
	        }
	        timestamps = this._cache.all = timestamps;
	        return timestamps;
	    }
	 getDecimalForValue(value) {
	        return (interpolate(this._table, value) - this._minPos) / this._tableRange;
	    }
	 getValueForPixel(pixel) {
	        const offsets = this._offsets;
	        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
	        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
	    }
	}

	class SearchesOverTimeChart {
	  constructor($parent) {
	    this.$parent = $parent;
	    this.$chart = null;
	    this.lineChart = null;
	    this.loadingMetrics = false;
	    this.initializeControl();
	    this.initializeEvents();
	  }
	  initializeControl() {
	    // HTML structure for the EnginesDetails select.
	    // phpcs:disable
	    const controlHTML = `
			<div class="searchwp-metrics-chart searchwp-metrics-chart--line" height="300px">
				<canvas></canvas>
				<div class="loading-spinner-container searchwp-metrics__hidden"><span class="loading-spinner"></span></div>
			</div>
		`;
	    // phpcs:enable

	    // Append the control HTML to the parent element.
	    if (this.$parent) {
	      this.$parent.append(controlHTML);
	    }
	    this.$chart = this.$parent.find('.searchwp-metrics-chart canvas');
	    this.$spinner = this.$chart.siblings('.loading-spinner-container');

	    // Register the chart components.
	    Chart.register(LineController, LineElement, PointElement, LinearScale, CategoryScale, plugin_tooltip, plugin_legend, index);

	    // Initialize new chart.
	    this.lineChart = new Chart(this.$chart, {
	      type: 'line',
	      data: {
	        labels: [],
	        datasets: []
	      },
	      options: {
	        responsive: true,
	        maintainAspectRatio: false,
	        scaleStepWidth: 1,
	        animation: true,
	        scales: {
	          y: {
	            beginAtZero: true,
	            ticks: {
	              precision: 0,
	              callback: function (value) {
	                return value.toString(); // Removes the decimal from the y-axis labels.
	              }
	            }
	          }
	        },
	        plugins: {
	          legend: {
	            display: true
	          },
	          tooltip: {
	            enabled: true
	          }
	        }
	      }
	    });
	    return this.lineChart;
	  }
	  updateChart(data) {
	    data = this.formatChartjsData(data, {
	      type: 'line',
	      borderWidth: 2,
	      fill: true
	    });
	    this.lineChart.data.labels = data.labels;
	    this.lineChart.data.datasets = data.datasets;
	    this.lineChart.update();
	    this.$spinner.addClass('searchwp-metrics__hidden');
	  }
	  formatChartjsData(data) {
	    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    let chartData = {
	      labels: data.labels,
	      datasets: []
	    };
	    let datasetLength = data.datasets.length;
	    for (let i = 0; i < datasetLength; i++) {
	      let dataset = data.datasets[i];
	      let defaults = {
	        label: dataset.engine,
	        borderColor: Utils.getColor(i),
	        backgroundColor: Utils.getColor(i, 0.15, 1.35),
	        data: dataset.dataset,
	        tension: 0.4
	      };

	      // Merge the defaults into any options set.
	      chartData.datasets.push(_objectSpread2(_objectSpread2({}, options), defaults));
	    }
	    return chartData;
	  }
	  initializeEvents() {
	    jQuery(document).on("searchwp-metrics__loading-started", this.startLoadingState.bind(this));
	  }
	  startLoadingState() {
	    this.loadingMetrics = true;
	    this.lineChart.data.datasets = [];
	    this.lineChart.update();
	    this.$spinner.removeClass('searchwp-metrics__hidden');
	  }
	}

	/**
	 * This class is responsible for setting up the Failed Searches modal.
	 *
	 * @since 1.4.5
	 */
	class FailedSearchesModal extends ModalComponent {
	  constructor(engineData) {
	    super({
	      name: 'failed-searches-' + engineData.name,
	      title: Utils.getI18nString('no_results_searches_engine', [{
	        placeholder: 'engine.label',
	        value: engineData.label
	      }]),
	      width: '600px',
	      classes: 'searchwp-metrics__failed-searches-modal',
	      scrollable: true
	    });
	    this.engineData = engineData;
	    this.failedSearches = null;
	    this.updateOnCLose = false;
	    this.updateContent();
	    this.initializeEvents();
	  }

	  /**
	   * Initialize the events for the Failed Searches modal.
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    this.$content.off().on('click', '.searchwp-delete', this.ignoreQuery.bind(this));

	    // Pass the class engineData to the downloadCSV method.
	    this.$content.on('click', '.searchwp-metrics__engine-failed-searches-csv', this.downloadCSV.bind(this, this.engineData));
	  }

	  /**
	   * Update the content of the modal.
	   *
	   * @since 1.4.5
	   *
	   * @param failedSearches
	   */
	  updateContent(failedSearches) {
	    this.failedSearches = failedSearches || null;

	    // phpcs:disable
	    this.$content.html(`
			<div class="searchwp-metrics__engine-details--heading">
				<p>${Utils.getI18nString('no_results_searches_engine_note')}</p>
				<div class="searchwp-metrics__engine-failed-searches-csv button">
					<span class="dashicons dashicons-download"></span>
				</div>
			</div>
			<table>
				<thead>
					<tr>
						<th>${Utils.getI18nString('search_query')}</th>
						<th>${Utils.getI18nString('searches')}</th>
					</tr>
				</thead>
				<tbody>
					${this.getFailedSearchesElements(failedSearches)}
				</tbody>
			</table>
		`);
	    // phpcs:enable
	  }

	  /**
	   * Get the failed searches elements.
	   *
	   * @since 1.4.5
	   *
	   * @param failedSearches
	   *
	   * @returns {*|string}
	   */
	  getFailedSearchesElements(failedSearches) {
	    // If this.engineData.failedSearches is not an array or is empty, return a message.
	    if (!Array.isArray(failedSearches) || !failedSearches.length) {
	      // phpcs:disable
	      return `
				<tr>
					<td colspan="2">${Utils.getI18nString('no_results_searches')}</td>
				</tr>
			`;
	      // phpcs:enable
	    }
	    return failedSearches.map(
	    // phpcs:disable
	    failedSearch => `
				<tr>
					<td>
						<button title="Ignore this query" class="searchwp-delete dashicons dashicons-dismiss"></button>
						${failedSearch.query}
					</td>
					<td>${failedSearch.count}</td>
				</tr>
			`
	    // phpcs:enable
	    ).join('');
	  }

	  /**
	   * Ignore the query.
	   *
	   * @since 1.4.5
	   *
	   * @param event
	   */
	  ignoreQuery(event) {
	    // Get the table row.
	    const $row = jQuery(event.target).closest('tr');

	    // Get the query to ignore.
	    const query = jQuery(event.target).parent().text().trim();

	    // Delete the entry from the failed searches.
	    this.failedSearches = this.failedSearches.filter(failedSearch => failedSearch.query !== query);
	    $row.remove();
	    jQuery(document).trigger('searchwp-metrics__ignore-query', [query]);
	    this.updateOnCLose = true;
	  }

	  /**
	   * Download the CSV file.
	   *
	   * @since 1.4.5
	   */
	  downloadCSV() {
	    Utils.downloadCSV(this.failedSearches, 'NoResultsSearches', {
	      'query': 'Query',
	      'count': 'No Results Search Count'
	    }, this.engineData.name);
	  }

	  /**
	   * Close the modal.
	   *
	   * @since 1.4.5
	   */
	  closeModal() {
	    super.closeModal();
	    if (this.updateOnCLose) {
	      this.updateOnCLose = false;
	      jQuery(document).trigger('searchwp-metrics__needs-update');
	    }
	  }
	}

	/**
	 * This class handles the Engine Statistics Component.
	 *
	 * @since 1.4.5
	 */
	class EngineStatisticsComponent {
	  constructor($engine, engineData) {
	    this.engineData = engineData;
	    this.$engine = $engine;
	    this.$parent = $engine.find('.searchwp-metrics__engine-details-alpha');
	    this.$component = null;
	    this.$totalSearches = null;
	    this.$failedSearches = null;
	    this.$totalResultsViewed = null;
	    this.$searchesPerUser = null;
	    this.$clicksPerSearch = null;
	    this.$averageClickRank = null;
	    this.failedSearchesModal = null;
	    this.initializeControl();
	    this.cacheElements();
	    this.initializeEvents();
	  }

	  /**
	   * Initialize the Engine Statistics Component.
	   *
	   * @since 1.4.5
	   */
	  initializeControl() {
	    // HTML structure for an Engine Details.
	    // phpcs:disable
	    const controlHTML = `
			<div>
				<div class="searchwp-metrics__engine-details--heading">
					<h4>${Utils.getI18nString('engine_statistics')}</h4>
				</div>
					<div class="searchwp-metrics__stats-grid">
						${this.generateStatisticsItemHTML(Utils.getI18nString('total_searches'), 'total-searches')}
						${this.generateStatisticsItemHTML(Utils.getI18nString('no_results_searches'), 'failed-searches', `
							<div class="searchwp-metrics__flex">
								<div class="failed-searches-count"></div>
								<div>
									<div class="searchwp-trigger__external failed-searches searchwp-metrics__disable-on-loading">
										<span class="dashicons dashicons-external"></span>
										<span class="screen-reader-text">${Utils.getI18nString('view_no_results_searches')}</span>
									</div>
								</div>
							</div>
						`)}
						${this.generateStatisticsItemHTML(Utils.getI18nString('total_results_viewed'), 'total-results-viewed')}
						${this.generateStatisticsItemHTML(Utils.getI18nString('searches_per_user'), 'searches-per-user', '', Utils.getI18nString('searches_per_user_note'))}
						${this.generateStatisticsItemHTML(Utils.getI18nString('clicks_per_search'), 'clicks-per-search')}
						${this.generateStatisticsItemHTML(Utils.getI18nString('average_click_rank'), 'average-click-rank')}
					</div>
					<div class="searchwp-metrics__note click-tracking-note searchwp-metrics__hidden">
						<span class="dashicons dashicons-info"></span>
						<div><p>${Utils.getI18nString('click_tracking_note')}</p></div>
					</div>
			</div>
		`;
	    // phpcs:enable

	    // Append the control HTML to the parent element.
	    if (this.$parent) {
	      this.$component = jQuery(controlHTML).appendTo(this.$parent);
	    }

	    // Add a modal for the failed searches.
	    this.failedSearchesModal = new FailedSearchesModal(this.engineData);
	  }

	  /**
	   * Generate the HTML for a statistics item.
	   *
	   * @since 1.4.5
	   *
	   * @param label
	   * @param className
	   * @param content
	   * @param tooltip
	   */
	  generateStatisticsItemHTML(label, className) {
	    let content = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
	    let tooltip = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
	    //phpcs:disable
	    let tooltipHTML = tooltip ? `<span class="dashicons dashicons-editor-help tooltip"><span class="tooltiptext">${tooltip}</span></span>` : '';
	    //phpcs:enable

	    // phpcs:disable
	    return `
			<div>
				<dl>
					<dt>${label}${tooltipHTML}</dt>
					<dd class="${className}">${content}</dd>
				</dl>
			</div>
		`;
	    // phpcs:enable
	  }

	  /**
	   * Cache the Engine Statistics Component elements.
	   *
	   * @since 1.4.5
	   */
	  cacheElements() {
	    this.$totalSearches = this.$component.find('.total-searches');
	    this.$failedSearches = this.$component.find('.failed-searches-count');
	    this.$failedSearchesLink = this.$component.find('.searchwp-trigger__external.failed-searches');
	    this.$totalResultsViewed = this.$component.find('.total-results-viewed');
	    this.$searchesPerUser = this.$component.find('.searches-per-user');
	    this.$clicksPerSearch = this.$component.find('.clicks-per-search');
	    this.$averageClickRank = this.$component.find('.average-click-rank');
	    this.$clickTrackingNote = this.$component.find('.click-tracking-note');
	    this.$notEnoughDataNotice = this.$component.find('.searchwp-metrics__no-data');
	  }

	  /**
	   * Initialize the events for the Engine Statistics Component.
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    this.$failedSearchesLink.on('click', this.failedSearchesModal.openModal.bind(this.failedSearchesModal));
	    jQuery(document).on("searchwp-metrics__loading-started", this.startLoadingState.bind(this));
	  }

	  /**
	   * Update the Engine Statistics Component with new data.
	   *
	   * @since 1.4.5
	   *
	   * @param metricsData
	   * @param metric
	   */
	  update(metricsData, metric) {
	    // Add the new metric data to the existing engine data as a new item.
	    this.engineData[metric] = metricsData;
	    const {
	      total_searches,
	      failed_searches_over_time_count,
	      failed_searches_over_time,
	      total_clicks,
	      average_searches_per_user,
	      average_clicks_per_search,
	      average_click_rank
	    } = this.engineData;
	    switch (metric) {
	      case 'total_searches':
	        this.$totalSearches.html(total_searches);
	        break;
	      case 'failed_searches_over_time_count':
	        this.$failedSearchesLink.toggle(!!failed_searches_over_time_count);
	        this.$failedSearches.html(failed_searches_over_time_count);
	        break;
	      case 'failed_searches_over_time':
	        this.failedSearchesModal.updateContent(failed_searches_over_time);
	        break;
	      case 'total_clicks':
	        this.$clickTrackingNote.toggleClass('searchwp-metrics__hidden', total_clicks !== '--');
	        this.$totalResultsViewed.html(total_clicks);
	        break;
	      case 'average_searches_per_user':
	        this.$searchesPerUser.html(average_searches_per_user);
	        break;
	      case 'average_clicks_per_search':
	        this.$clicksPerSearch.html(average_clicks_per_search);
	        break;
	      case 'average_click_rank':
	        this.$averageClickRank.html(average_click_rank);
	        break;
	    }
	  }

	  /**
	   * Start the loading state for the Engine Statistics Component.
	   *
	   * @since 1.4.5
	   */
	  startLoadingState() {
	    const spinner = '<span class="loading-spinner"></span>';
	    this.engineData = {};
	    this.$totalSearches.html(spinner);
	    this.$failedSearches.html(spinner);
	    this.$totalResultsViewed.html(spinner);
	    this.$searchesPerUser.html(spinner);
	    this.$clicksPerSearch.html(spinner);
	    this.$averageClickRank.html(spinner);
	  }

	  /**
	   * Remove the Engine Statistics Component.
	   *
	   * @since 1.4.5
	   */
	  removeElements() {
	    this.$component.remove();
	    this.failedSearchesModal.$modal.remove();
	  }
	}

	var isObject = function isObject(x) {
		return typeof x === 'object' && x !== null;
	};

	/**
	 * isArray
	 */

	var isArray = Array.isArray;

	/**
	 * toString
	 */

	var str = Object.prototype.toString;

	/**
	 * Whether or not the given `val`
	 * is an array.
	 *
	 * example:
	 *
	 *        isArray([]);
	 *        // > true
	 *        isArray(arguments);
	 *        // > false
	 *        isArray('');
	 *        // > false
	 *
	 * @param {mixed} val
	 * @return {bool}
	 */

	var isArray_1 = isArray || function (val) {
	  return !! val && '[object Array]' == str.call(val);
	};

	var isFunction_1 = isFunction;

	var toString = Object.prototype.toString;

	function isFunction (fn) {
	  if (!fn) {
	    return false
	  }
	  var string = toString.call(fn);
	  return string === '[object Function]' ||
	    (typeof fn === 'function' && string !== '[object RegExp]') ||
	    (typeof window !== 'undefined' &&
	     // IE8 and below
	     (fn === window.setTimeout ||
	      fn === window.alert ||
	      fn === window.confirm ||
	      fn === window.prompt))
	}

	var lib = createCommonjsModule(function (module) {
	/*!
	 *   keyfinder - v1.0.0
	 *   Deep search for keys in objects and arrays and pluck their respective values.
	 *   https://github.com/simon-johansson/keyfinder
	 *   by Simon Johansson <mail@simon-johansson.com>
	 *   MIT License
	 */

	(function() {
	    var arrayify, find, isArray, isFunction, isObjectOrArray;
	    isObjectOrArray = isObject;
	    isArray = isArray_1;
	    isFunction = isFunction_1;
	    arrayify = function(obj) {
	        var key, _results;
	        _results = [];
	        for (key in obj) {
	            _results.push(key);
	        }
	        return _results;
	    };
	    find = function(haystack, needle, memo) {
	        var key, parent, val, _i, _len, _ref;
	        if (memo == null) {
	            memo = [];
	        }
	        if (needle && isObjectOrArray(haystack)) {
	            if (needle in haystack) {
	                memo.push(haystack[needle]);
	            }
	            _ref = arrayify(haystack);
	            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	                key = _ref[_i];
	                val = haystack[key];
	                if (isFunction(needle)) {
	                    parent = isArray(haystack) ? "array" : "object";
	                    needle(key, val, parent);
	                }
	                if (isObjectOrArray(val)) {
	                    find(val, needle, memo);
	                }
	            }
	        }
	        return memo;
	    };
	    module.exports = function(obj, key) {
	        return find(obj, key);
	    };
	}).call(commonjsGlobal);
	});

	class PopularSearchesModal extends ModalComponent {
	  constructor(engineData) {
	    super({
	      name: 'popular-searches-' + engineData.name,
	      title: Utils.getI18nString('popular_search_details_engine', [{
	        placeholder: 'engine.label',
	        value: engineData.label
	      }]),
	      width: '800px',
	      classes: 'searchwp-metrics__popular-searches-modal',
	      scrollable: true
	    });
	    this.engineData = engineData;
	    this.popularSearchesDetails = null;
	    this.popularSearchesCount = 10;
	    this.updateOnCLose = false;
	    this.isLoading = false;
	    Chart.register(BarController, BarElement);
	    this.initializeEvents();
	  }
	  updateContent() {
	    // phpcs:disable
	    const note = `
			<div class="searchwp-metrics__engine-details--heading">
				<p>${Utils.getI18nString('popular_search_details_note')}</p>
				<div>
					<input id="searchwp-metrics__popular-searches-count" type="number" min="0" max="1000" value="${this.popularSearchesCount}">
					<button id="searchwp-metrics__popular-searches-update" class="button"><span class="dashicons dashicons-update"></span></button>
					<div class="searchwp-metrics__engine-popular-searches-csv button">
						<span class="dashicons dashicons-download"></span>
					</div>
				</div>
			</div>
		`;
	    // phpcs:enable

	    if (this.isLoading) {
	      // phpcs:disable
	      this.$content.html(`
				${note}
				<div class="searchwp-metrics__modal-loading-spinner-container"><span class="searchwp-metrics__modal-loading-spinner"></span></div>
			`);
	      // phpcs:enable
	      return;
	    }

	    // phpcs:disable
	    this.$content.html(`
			${note}
			<div class="searchwp-metrics__split">
				<p class="searchwp-metrics__guide">${Utils.getI18nString('search_query')}</p>
				<p class="searchwp-metrics__guide">${Utils.getI18nString('searches')}</p>
			</div>
			<div class="searchwp-metrics__popular-search-details searchwp-metrics__accordion">
			${this.getPopularSearchesElements()}
			</div>

		`);
	    // phpcs:enable

	    // Add a bar chart for each popular search item.
	    this.registerItemsChart();
	  }
	  getPopularSearchesElements() {
	    if (!Array.isArray(this.popularSearchesDetails) || !this.popularSearchesDetails.length) {
	      // phpcs:disable
	      return `
				<div class="searchwp-metrics__no-data">
					<p>${Utils.getI18nString('no_clicks')}</p>
				</div>
			`;
	      // phpcs:enable
	    }
	    return this.popularSearchesDetails.map((popularSearchDetail, index) => {
	      // phpcs:disable
	      return `
				<div class="searchwp-metrics__accordion--item">
					<div class="searchwp-metrics__accordion--header">
						<div class="searchwp-metrics__accordion--trigger">
							<div class="searchwp-metrics__accordion--header-icon">
								<span class="dashicons dashicons-arrow-right"></span>
							</div>
							<h5 class="searchwp-metrics__accordion--header-title">
								${popularSearchDetail.query.query}
							</h5>
							<div class="searchwp-metrics__accordion--header-figure">
								${popularSearchDetail.query.searchcount}
							</div>
						</div>
						<div class="searchwp-metrics__accordion--actions">
							<button title="remove" class="searchwp-delete dashicons dashicons-dismiss"></button>
						</div>
					</div>

					<div class="searchwp-metrics__accordion--content">
						<div class="searchwp-metrics__inner">
							${this.getPopularSearchesItemElements(popularSearchDetail, index)}
						</div>
					</div>
				</div>

			`;
	      // phpcs:enable
	    }).join('');
	  }
	  getPopularSearchesItemElements(popularSearchDetail, index) {
	    let itemDetails = '';
	    if (popularSearchDetail.clicks.length) {
	      // phpcs:disable
	      itemDetails += `
				<div>
					<div class="searchwp-metrics-chart searchwp-metrics-chart--bar" height="30px">
						<canvas id="${this.engineData.name}-popular-searches-details-item-chart-${index}"></canvas>
					</div>

					<table>
						<thead>
							<tr>
								<th class="searchwp-metrics--primary-col">${Utils.getI18nString('clicked_result')}</th>
								<th class="searchwp-metrics--secondary-col">${Utils.getI18nString('clicks')}</th>
								<th class="searchwp-metrics--secondary-col">${Utils.getI18nString('conversion_rate')}</th>
							</tr>
						</thead>
						<tbody>
						${this.getPopularSearchesItemResults(popularSearchDetail)}
						</tbody>
					</table>
				</div>
			`;
	      // phpcs:enable
	    } else {
	      // phpcs:disable
	      itemDetails += `
				<div class="searchwp-metrics__no-data">
					<p>${Utils.getI18nString('no_clicks')}</p>
				</div>
			`;
	    }
	    return itemDetails;
	  }
	  registerItemsChart() {
	    this.popularSearchesDetails.forEach((popularSearchDetail, index) => {
	      let chartElement = this.$content.find(`#${this.engineData.name}-popular-searches-details-item-chart-${index}`)[0];

	      // If there is no chart element, continue.
	      if (!chartElement) {
	        return;
	      }
	      let labels = [Utils.getI18nString('clicks')];
	      let datasets = [];
	      let totalClicks = lib(popularSearchDetail.clicks, 'clicks').reduce((a, b) => a + b, 0);
	      for (let i = 0; i < popularSearchDetail.clicks.length; i++) {
	        let value = (popularSearchDetail.clicks[i].clicks * 100 / totalClicks).toFixed(2);
	        datasets.push({
	          backgroundColor: Utils.getColor(i),
	          label: popularSearchDetail.clicks[i].post_title,
	          data: [value]
	        });
	      }
	      new Chart(chartElement, {
	        type: 'bar',
	        data: {
	          labels: labels,
	          datasets: datasets
	        },
	        options: Utils.getBarChartOptions()
	      });
	    });
	  }
	  getPopularSearchesItemResults(popularSearchDetail) {
	    return popularSearchDetail.clicks.map((click, index) => {
	      // phpcs:disable
	      return `
				<tr>
					<td class="searchwp-metrics--primary-col">
						<a href="${click.permalink}" target="_blank">
							<span class="searchwp-metrics-legend-item">
								<span class="searchwp-metrics-legend-indicator" style="background-color: ${Utils.getColor(index)}"></span>
								<span class="searchwp-metrics-legend-label" title="${click.post_title}"><span>${click.post_title}</span></span>
							</span>
						</a>
					</td>
					<td class="searchwp-metrics--secondary-col">${click.clicks}</td>
					<td class="searchwp-metrics--secondary-col">${(click.clicks * 100 / popularSearchDetail.query.searchcount).toFixed(2)}%</td>
				</tr>
			`;
	      // phpcs:enable
	    }).join('');
	  }
	  openModal() {
	    super.openModal();
	    if (this.popularSearchesDetails === null) {
	      this.loadContent();
	    }
	  }
	  closeModal() {
	    super.closeModal();
	    if (this.updateOnCLose) {
	      this.updateOnCLose = false;
	      jQuery(document).trigger('searchwp-metrics__needs-update');
	    }
	  }
	  loadContent() {
	    this.isLoading = true;
	    this.popularSearchesDetails = null;
	    this.updateContent();
	    let payload = {
	      action: 'searchwp_metrics_popular_search_details',
	      engine: this.engineData.name,
	      before: searchwp_metrics.dateRangePicker.endDate,
	      after: searchwp_metrics.dateRangePicker.startDate,
	      limit: this.popularSearchesCount
	    };
	    Utils.apiRequest(payload).then(response => {
	      this.popularSearchesDetails = response.data;
	      this.isLoading = false;
	      this.updateContent();
	    });
	  }
	  initializeEvents() {
	    // Toggle the accordion.
	    this.$content.on('click', '.searchwp-metrics__accordion--trigger', event => {
	      let accordionItem = jQuery(event.currentTarget).closest('.searchwp-metrics__accordion--item');
	      let scrollable = accordionItem.closest('.searchwp-metrics__modal-scrollable');
	      accordionItem.toggleClass('searchwp-metrics__accordion--active');

	      // Scroll the modal to the accordion item.
	      if (!accordionItem.hasClass('searchwp-metrics__accordion--active')) {
	        return;
	      }
	      scrollable.animate({
	        scrollTop: accordionItem.offset().top - scrollable.offset().top + scrollable.scrollTop() - 10
	      }, 300);
	    });

	    // Add ignored query when the delete button is clicked.
	    this.$content.on('click', '.searchwp-delete', event => {
	      this.ignoreQuery(event);
	    });

	    // Update the popular searches count when input field value is updated.
	    this.$content.on('change', '#searchwp-metrics__popular-searches-count', event => {
	      this.popularSearchesCount = event.target.value;
	    });

	    // Reload the content when the update button is clicked.
	    this.$content.on('click', '#searchwp-metrics__popular-searches-update', event => {
	      this.popularSearchesCount = event.target.value;
	      this.loadContent();
	    });

	    // Reload the content when the enter key is pressed in the input field.
	    this.$content.on('keypress', '#searchwp-metrics__popular-searches-count', event => {
	      this.popularSearchesCount = event.target.value;
	      if (event.key === 'Enter') {
	        this.loadContent();
	      }
	    });

	    // Download CSV when the download button is clicked.
	    this.$content.on('click', '.searchwp-metrics__engine-popular-searches-csv', () => {
	      this.downloadCSV();
	    });
	  }
	  ignoreQuery(event) {
	    // Get the accordion item.
	    const $item = jQuery(event.target).closest('.searchwp-metrics__accordion--item');

	    // Get the query to ignore.
	    const query = $item.find('.searchwp-metrics__accordion--header-title').text().trim();

	    // Delete the item from the list.
	    $item.remove();

	    // Delete the entry from the Popular searches details.
	    this.popularSearchesDetails = this.popularSearchesDetails.filter(popularSearchDetail => popularSearchDetail.query.query !== query);
	    jQuery(document).trigger('searchwp-metrics__ignore-query', [query]);
	    this.updateOnCLose = true;
	  }
	  downloadCSV() {
	    let formattedData = this.formatExportData();
	    Utils.downloadCSV(formattedData, 'PopularSearchesDetails', {
	      'query': 'Search Query',
	      'searches': 'Searches',
	      'clickTitle': 'Clicked Title',
	      'clickCount': 'Clicks'
	    }, this.engineData.name);
	  }
	  formatExportData() {
	    // To effectively populate a CSV-compatible display of popular searches, we need to
	    // enforce the data structure to accommodate the display of click data.
	    const source = this.popularSearchesDetails;
	    let formatted = [];
	    if (!source.length) {
	      return formatted;
	    }
	    source.forEach(function (popularSearch) {
	      // Add a row in the spreadsheet for the search, acting as a heading.
	      formatted.push({
	        query: popularSearch.query.query,
	        searches: popularSearch.query.searchcount,
	        clickId: '',
	        clickTitle: '',
	        clickCount: ''
	      });

	      // For each click, we need to make space in the spreadsheet, so we
	      // blank out the search query info and instead fill in click details.
	      if (popularSearch.clicks.length) {
	        popularSearch.clicks.forEach(function (click) {
	          formatted.push({
	            query: '',
	            searches: '',
	            clickId: click.post_id,
	            clickTitle: !click.post_id ? '' : click.post_title + ' (' + click.clickId + ')',
	            clickCount: click.clicks
	          });
	        });
	      }
	    });
	    return formatted;
	  }
	}

	/**
	 * This class is responsible for setting up the Popular Searches component.
	 *
	 * @since 1.4.5
	 */
	class PopularSearchesComponent {
	  /**
	   * Constructor.
	   *
	   * @since 1.4.5
	   *
	   * @param $engine
	   * @param engineData
	   */
	  constructor($engine, engineData) {
	    this.$engine = $engine;
	    this.engineData = engineData;
	    this.$parent = $engine.find('.searchwp-metrics__engine-details-beta.searchwp-metrics__engine-popular-searches');
	    this.$component = null;
	    this.$popularSearchesTable = null;
	    this.popularSearchesChart = null;
	    this.popularSearchesModal = null;
	    this.initializeControl();
	    this.cacheElements();
	    this.initializeEvents();
	  }

	  /**
	   * Initialize the Popular Searches component.
	   *
	   * @since 1.4.5
	   */
	  initializeControl() {
	    // HTML structure for an Engine Popular Searches.
	    // phpcs:disable
	    const controlHTML = `
			<div>
				<div class="searchwp-metrics__engine-details--heading">
					<h4>${Utils.getI18nString('popular_searches')}</h4>
					<div class="searchwp-metrics__disable-on-loading">
						<button class="button popular-searches-view-more">${Utils.getI18nString('view_more')}</button>
					</div>
				</div>
				<div class="searchwp-metrics__chart-donut-wrapper">
					<div>
						<table class="searchwp-metrics-table">
							<tbody></tbody>
						</table>
					</div>
					<div>
						<div class="searchwp-metrics-chart searchwp-metrics-chart--doughnut"><canvas></canvas></div>
						<div class="searchwp-metrics__engine-popular-searches-coverage"><span>0%</span>${Utils.getI18nString('of_all_searches')}</div>
					</div>
				</div>
				<div class="loading-spinner-container searchwp-metrics__hidden"><span class="loading-spinner"></span></div>
			</div>
		`;
	    // phpcs:enable

	    // Append the control HTML to the parent element.
	    if (this.$parent) {
	      this.$component = jQuery(controlHTML).appendTo(this.$parent);
	    }

	    // Register Doughnut Chart components.
	    Chart.register(DoughnutController, ArcElement, plugin_tooltip);
	    this.popularSearchesChart = new Chart(this.$component.find('.searchwp-metrics-chart--doughnut canvas')[0], {
	      type: 'doughnut',
	      data: {
	        datasets: [{
	          data: [],
	          backgroundColor: []
	        }],
	        labels: []
	      },
	      options: {
	        maintainAspectRatio: true,
	        plugins: {
	          legend: {
	            display: false
	          },
	          tooltip: {
	            cornerRadius: 2,
	            titleMarginBottom: 10,
	            padding: {
	              x: 11,
	              y: 9
	            },
	            callbacks: {
	              label: function (context) {
	                const label = context.label || '';
	                const value = context.formattedValue;
	                return ` ${label}: ${value}`;
	              },
	              // Remove title to prevent label appearing twice.
	              title: function () {
	                return '';
	              }
	            }
	          }
	        }
	      }
	    });

	    // Add new Popular Searches Modal.
	    this.popularSearchesModal = new PopularSearchesModal(this.engineData);
	  }

	  /**
	   * Generate the HTML for the Popular Searches table.
	   *
	   * @since 1.4.5
	   *
	   * @param popularSearches
	   *
	   * @returns {string}
	   */
	  generatePopularSearchesHTML() {
	    let popularSearches = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    let popularSearchesHTML = '';
	    popularSearches.forEach((search, index) => {
	      let legendColor = Utils.getColor(index);
	      // phpcs:disable
	      popularSearchesHTML += `
				<tr>
					<td>
					<span class="searchwp-metrics-legend-item">
						<span title="${search.query}" class="searchwp-metrics-legend-indicator" style="background-color: ${legendColor}"></span>
						<span title="${search.query}" class="searchwp-metrics-legend-label">${search.query}</span>
					</span>
					</td>
					<td><button title="${Utils.getI18nString('remove')}" class="searchwp-delete dashicons dashicons-dismiss" data-query="${search.query}"></button></td>
					<td>${search.count}</td>
				</tr>
			`;
	      // phpcs:enable
	    });
	    return popularSearchesHTML;
	  }

	  /**
	   * Cache the elements for the Popular Searches component.
	   *
	   * @since 1.4.5
	   */
	  cacheElements() {
	    this.viewMore = this.$component.find('.searchwp-metrics__engine-details--heading .popular-searches-view-more');
	    this.$chartWrapper = this.$component.find('.searchwp-metrics__chart-donut-wrapper');
	    this.$popularSearchesTable = this.$component.find('.searchwp-metrics-table tbody');
	    this.$popularSearchesCoverage = this.$component.find('.searchwp-metrics__engine-popular-searches-coverage span');
	    this.$spinner = this.$component.find('.loading-spinner-container');
	  }

	  /**
	   * Initialize the events for the Popular Searches component.
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    jQuery(document).on('searchwp-metrics__loading-started', this.startLoadingState.bind(this));
	    this.viewMore.on('click', this.popularSearchesModal.openModal.bind(this.popularSearchesModal));
	    this.$popularSearchesTable.on('click', '.searchwp-delete', this.ignoreQuery.bind(this));
	  }

	  /**
	   * Ignore a query.
	   *
	   * @since 1.4.5
	   *
	   * @param event
	   */
	  ignoreQuery(event) {
	    let $deleteButton = jQuery(event.target);

	    // Get the query to ignore.
	    const query = $deleteButton.data('query').trim();

	    // Delete the entry from the failed searches.
	    $deleteButton.closest('tr').remove();
	    jQuery(document).trigger('searchwp-metrics__ignore-query', [query, true]);
	  }

	  /**
	   * Get the percentage of popular searches.
	   *
	   * @since 1.4.5
	   *
	   * @param popularSearches
	   * @param totalSearches
	   *
	   * @returns {string}
	   */
	  getPopularSearchesPercentage(popularSearches, totalSearches) {
	    if (!totalSearches || !popularSearches.length) {
	      return '0%';
	    }
	    let totalPopularSearches = popularSearches.reduce((totalCount, query) => {
	      return totalCount + query.count;
	    }, 0);
	    return Math.round(totalPopularSearches * 100 / totalSearches) + '%';
	  }

	  /**
	   * Update the Popular Searches component.
	   *
	   * @since 1.4.5
	   *
	   * @param popular_queries_over_time
	   * @param totalSearches
	   */
	  update(popular_queries_over_time, totalSearches) {
	    // If popular_queries_over_time is not an array, return.
	    if (!Array.isArray(popular_queries_over_time)) {
	      return;
	    }
	    this.$popularSearchesTable.html(this.generatePopularSearchesHTML(popular_queries_over_time));
	    this.popularSearchesChart.data.labels = popular_queries_over_time.map(search => search.query);
	    this.popularSearchesChart.data.datasets[0].data = popular_queries_over_time.map(search => search.count);
	    this.popularSearchesChart.data.datasets[0].backgroundColor = popular_queries_over_time.map((search, index) => Utils.getColor(index));
	    this.popularSearchesChart.update();
	    this.$popularSearchesCoverage.html(this.getPopularSearchesPercentage(popular_queries_over_time, totalSearches));
	    this.$spinner.addClass('searchwp-metrics__hidden');
	    this.$chartWrapper.removeClass('searchwp-metrics__hidden');
	  }

	  /**
	   * Start the loading state.
	   *
	   * @since 1.4.5
	   */
	  startLoadingState() {
	    this.$spinner.removeClass('searchwp-metrics__hidden');
	    this.$chartWrapper.addClass('searchwp-metrics__hidden');
	  }

	  /**
	   * Remove the Popular Searches component.
	   *
	   * @since 1.4.5
	   */
	  removeElements() {
	    this.$component.remove();
	    this.popularSearchesModal.$modal.remove();
	  }
	}

	/**
	 * This class is responsible for setting up the Insights details modal.
	 *
	 * @since 1.4.5
	 */
	class InsightsDetailsModal extends ModalComponent {
	  /**
	   * Constructor.
	   *
	   * @since 1.4.5
	   *
	   * @param engineData
	   */
	  constructor(engineData) {
	    super({
	      name: 'insights-' + engineData.name,
	      title: Utils.getI18nString('insights_engine', [{
	        placeholder: 'engine.label',
	        value: engineData.label
	      }]),
	      width: '600px',
	      classes: 'searchwp-metrics__engine-insights-details',
	      scrollable: true
	    });
	    this.engineData = engineData;
	    this.insights = null;
	    this.updateOnCLose = false;
	    this.isLoading = false;
	    Chart.register(BarController, BarElement);
	    this.initializeEvents();
	  }

	  /**
	   * Update the modal content.
	   *
	   * @since 1.4.5
	   *
	   * @param insights
	   */
	  updateContent(insights) {
	    if (!insights) {
	      return;
	    }
	    this.$content.html('<div class="searchwp-metrics__accordion"></div>');
	    this.getInsightsItems(insights);
	  }

	  /**
	   * Get the insights items.
	   *
	   * @since 1.4.5
	   *
	   * @param insights
	   *
	   * @returns {string}
	   */
	  getInsightsItems(insights) {
	    if (!insights) {
	      return '';
	    }
	    insights.forEach(insight => {
	      switch (insight.type) {
	        case 'popular':
	          jQuery(this.getPopularInsight(insight)).appendTo(this.$content);
	          break;
	        case 'analysis':
	          jQuery(this.getAnalysisInsight(insight)).appendTo(this.$content);
	          break;
	        case 'underdog':
	          jQuery(this.getUnderdogInsight(insight)).appendTo(this.$content);
	          break;
	      }
	    });
	  }

	  /**
	   * Get the popular insight.
	   *
	   * @since 1.4.5
	   *
	   * @param insight
	   *
	   * @returns {string}
	   */
	  getPopularInsight(insight) {
	    function getInsightPosts(posts) {
	      let rows = '';
	      posts.forEach(post => {
	        // phpcs:disable
	        rows += `
					<tr>
						<td class="searchwp-metrics--primary-col"><a href="${post.permalink}" target="_blank">${post.post_title}</a></td>
						<td class="searchwp-metrics--secondary-col">${post.clicks}</td>
					</tr>
				`;
	        // phpcs:enable
	      });
	      return rows;
	    }
	    let header = insight.postCount > 1 ? Utils.getI18nString('insight_popular_plural', [{
	      placeholder: 'postCount',
	      value: insight.postCount
	    }]) : Utils.getI18nString('insight_popular_singular');

	    // phpcs:disable
	    return `
			<div class="searchwp-metrics__accordion--item">
				<div class="searchwp-metrics__accordion--header">
					<div class="searchwp-metrics__accordion--trigger">
						<div class="searchwp-metrics__accordion--header-icon">
							<span class="dashicons dashicons-awards"></span>
						</div>
						<div class="searchwp-metrics__accordion--header-title">
							<div class="searchwp-metrics__insight">
								<div class="searchwp-metrics__engine-suggestions-insight-content">
									<p>
										<span>${header}</span>
										<button class="searchwp-metrics-nonbutton">${Utils.getI18nString('details')}</button>
									</p>
								</div>
							</div>
						</div>
					</div>
				</div>
				<div class="searchwp-metrics__accordion--content">
					<div class="searchwp-metrics__inner">
						<div>
							<table>
								<thead>
									<tr>
										<th class="searchwp-metrics--primary-col">${Utils.getI18nString('entry')}</th>
										<th class="searchwp-metrics--secondary-col">${Utils.getI18nString('clicks')}</th>
									</tr>
								</thead>
								<tbody>
								${getInsightPosts(insight.posts)}
								</tbody>
							</table>
						</div>
					</div>
				</div>
			</div>
		`;
	    // phpcs:enable
	  }

	  /**
	   * Get the analysis insight.
	   *
	   * @since 1.4.5
	   *
	   * @param insight
	   *
	   * @returns {*|jQuery|HTMLElement}
	   */
	  getAnalysisInsight(insight) {
	    function getInsightPosts(posts) {
	      let rows = '';
	      posts.forEach((post, index) => {
	        // phpcs:disable
	        rows += `
					<tr>
						<td class="searchwp-metrics--primary-col">
							<a href="${post.permalink}" target="_blank">
								<span class="searchwp-metrics-legend-item">
									<span class="searchwp-metrics-legend-indicator" style="background-color: ${Utils.getColor(index)}"></span>
									<span class="searchwp-metrics-legend-label" title="${post.post_title}"><span>${post.post_title}</span></span>
								</span>
							</a>
						</td>
						<td class="searchwp-metrics--secondary-col">${post.clicks}</td>
					</tr>
					`;
	        // phpcs:enable
	      });
	      return rows;
	    }
	    let header = Utils.getI18nString('insight_analysis', [{
	      placeholder: 'query',
	      value: insight.query
	    }, {
	      placeholder: 'clickCount',
	      value: insight.clickCount
	    }, {
	      placeholder: 'postCount',
	      value: insight.postCount
	    }, {
	      placeholder: 'query',
	      value: insight.query
	    }]);

	    // phpcs:disable
	    let $item = jQuery(`
			<div class="searchwp-metrics__accordion--item">
				<div class="searchwp-metrics__accordion--header">
					<div class="searchwp-metrics__accordion--trigger">
						<div class="searchwp-metrics__accordion--header-icon">
							<span class="dashicons dashicons-arrow-right"></span>
						</div>
						<div class="searchwp-metrics__accordion--header-title">
							<div class="searchwp-metrics__insight">
								<div class="searchwp-metrics__engine-suggestions-insight-content">
									<p>
										<span>${header}</span>
										<button class="searchwp-metrics-nonbutton">${Utils.getI18nString('details')}</button>
									</p>
								</div>
							</div>
						</div>
					</div>
				</div>
				<div class="searchwp-metrics__accordion--content">
					<div class="searchwp-metrics__inner">
						<div>
							<div class="searchwp-metrics-chart searchwp-metrics-chart--bar" height="30px">
								<canvas></canvas>
							</div>
							<table>
								<thead>
									<tr>
										<th class="searchwp-metrics--primary-col">${Utils.getI18nString('entry')}</th>
										<th class="searchwp-metrics--secondary-col">${Utils.getI18nString('clicks')}</th>
									</tr>
								</thead>
								<tbody>
								${getInsightPosts(insight.posts)}
								</tbody>
							</table>
						</div>
					</div>
				</div>
			</div>
		`);
	    // phpcs:enable

	    this.registerAnalysisChart($item, insight);
	    return $item;
	  }

	  /**
	   * Get the underdog insight.
	   *
	   * @since 1.4.5
	   *
	   * @param insight
	   *
	   * @returns {string}
	   */
	  getUnderdogInsight(insight) {
	    let header = insight.postCount > 1 ? Utils.getI18nString('insight_underdog_plural', [{
	      placeholder: 'postCount',
	      value: insight.postCount
	    }]) : Utils.getI18nString('insight_underdog_singular');

	    // phpcs:disable
	    return `
			<div class="searchwp-metrics__accordion--item">
				<div class="searchwp-metrics__accordion--header">
					<div class="searchwp-metrics__accordion--trigger">
						<div class="searchwp-metrics__accordion--header-icon">
							<span class="dashicons dashicons-sos"></span>
						</div>
						<div class="searchwp-metrics__accordion--header-title">
							<div class="searchwp-metrics__insight">
								<div class="searchwp-metrics__engine-suggestions-insight-content">
									<p>
										<span>${header}</span>
										<button class="searchwp-metrics-nonbutton">${Utils.getI18nString('details')}</button>
									</p>
								</div>
							</div>
						</div>
					</div>
				</div>
				<div class="searchwp-metrics__accordion--content">
					<div class="searchwp-metrics__inner">
						<div>
							<table>
								<thead>
									<tr>
										<th class="searchwp-metrics--primary-col">${Utils.getI18nString('entry')}</th>
										<th class="searchwp-metrics--secondary-col">${Utils.getI18nString('clicks')}</th>
										<th class="searchwp-metrics--secondary-col">${Utils.getI18nString('average_rank')}</th>
									</tr>
								</thead>
								<tbody>
								${getInsightPosts(insight.posts)}
								</tbody>
							</table>
						</div>
					</div>
				</div>
			</div>
		`;
	    // phpcs:enable

	    function getInsightPosts(posts) {
	      let rows = '';
	      posts.forEach(post => {
	        // phpcs:disable
	        rows += `
					<tr>
						<td class="searchwp-metrics--primary-col"><a href="${post.permalink}" target="_blank">${post.post_title}</a></td>
						<td class="searchwp-metrics--secondary-col">${post.click_count}</td>
						<td class="searchwp-metrics--secondary-col">${post.avg_rank}</td>
					</tr>
				`;
	        // phpcs:enable
	      });
	      return rows;
	    }
	  }

	  /**
	   * Register the analysis chart.
	   *
	   * @since 1.4.5
	   *
	   * @param $item
	   * @param insight
	   */
	  registerAnalysisChart($item, insight) {
	    let chartElement = $item.find('canvas')[0];

	    // If there is no chart element, continue.
	    if (!chartElement) {
	      return;
	    }
	    let labels = [Utils.getI18nString('clicks')];
	    let datasets = [];
	    let totalClicks = lib(insight.posts, 'clicks').reduce((a, b) => a + b, 0);
	    let postsCount = insight.posts.length;
	    for (let i = 0; i < postsCount; i++) {
	      datasets.push({
	        backgroundColor: Utils.getColor(i),
	        label: insight.posts[i].post_title,
	        data: [(insight.posts[i].clicks * 100 / totalClicks).toFixed(2)]
	      });
	    }
	    new Chart(chartElement, {
	      type: 'bar',
	      data: {
	        labels: labels,
	        datasets: datasets
	      },
	      options: Utils.getBarChartOptions()
	    });
	  }

	  /**
	   * Initialize the events.
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    // Toggle the accordion.
	    this.$content.on('click', '.searchwp-metrics__accordion--trigger', event => {
	      let accordionItem = jQuery(event.currentTarget).closest('.searchwp-metrics__accordion--item');
	      let scrollable = accordionItem.closest('.searchwp-metrics__modal-scrollable');
	      accordionItem.toggleClass('searchwp-metrics__accordion--active');

	      // Scroll the modal to the accordion item.
	      if (!accordionItem.hasClass('searchwp-metrics__accordion--active')) {
	        return;
	      }
	      scrollable.animate({
	        scrollTop: accordionItem.offset().top - scrollable.offset().top + scrollable.scrollTop() - 10
	      }, 300);
	    });
	  }

	  /**
	   * Open the modal.
	   *
	   * @since 1.4.5
	   *
	   * @param itemIndex
	   */
	  openModal(itemIndex) {
	    super.openModal();

	    // Add the active class to the specified accordion item.
	    this.$content.find('.searchwp-metrics__accordion--item').eq(itemIndex).addClass('searchwp-metrics__accordion--active');
	  }

	  /**
	   * Close the modal.
	   *
	   * @since 1.4.5
	   */
	  closeModal() {
	    super.closeModal();

	    // Remove the active class from all accordion items.
	    this.$content.find('.searchwp-metrics__accordion--item').removeClass('searchwp-metrics__accordion--active');
	  }
	}

	/**
	 * This class is responsible for setting up the Insights Details component.
	 *
	 * @since 1.4.5
	 */
	class InsightsDetailsComponent {
	  constructor($engine, engineData) {
	    this.$engine = $engine;
	    this.engineData = engineData;
	    this.$parent = $engine.find('.searchwp-metrics__engine-details-omega.searchwp-metrics__engine-suggestions');
	    this.$component = null;
	    this.totalInsights = 0;
	    this.initializeControl();
	    this.cacheElements();
	    this.initializeEvents();
	  }

	  /**
	   * Initialize the Insights Details component.
	   *
	   * @since 1.4.5
	   */
	  initializeControl() {
	    // HTML structure for an Engine Suggestions.
	    // phpcs:disable
	    const controlHTML = `
			<div>
				<div class="searchwp-metrics__engine-details--heading">
					<h4>${Utils.getI18nString('insights')}</h4>
				</div>

				<div class="searchwp-metrics__engine-suggestions-insights">
					<div>
						${this.getEngineInsights()}
					</div>
				</div>
				<div class="loading-spinner-container searchwp-metrics__hidden"><span class="loading-spinner"></span></div>
			</div>
		`;
	    // phpcs:enable

	    // Append the control HTML to the parent element.
	    if (this.$parent) {
	      this.$component = jQuery(controlHTML).appendTo(this.$parent);
	    }

	    // Add the insight details modal.
	    this.insightsDetailsModal = new InsightsDetailsModal(this.engineData);
	  }

	  /**
	   * Get the insights for the engine.
	   *
	   * @since 1.4.5
	   *
	   * @returns {string}
	   */
	  getEngineInsights() {
	    if (this.engineData.insights === undefined) {
	      return '';
	    }
	    let insights = '<ul>';
	    if (!this.engineData.insights.length) {
	      // phpcs:disable
	      return `
				<div class="searchwp-metrics__note">
					<span class="dashicons dashicons-info"></span>
					<div>
						<p>${Utils.getI18nString('no_insights')}</p>
					</div>
			`;
	      // phpcs:enable
	    }
	    this.engineData.insights.forEach((insight, index) => {
	      let icon = '';
	      let content = '';
	      switch (insight.type) {
	        case 'popular':
	          icon = '<span class="dashicons dashicons-awards"></span>';
	          content = insight.postCount > 1 ? Utils.getI18nString('insight_popular_plural', [{
	            placeholder: 'postCount',
	            value: insight.postCount
	          }]) : Utils.getI18nString('insight_popular_singular');
	          break;
	        case 'analysis':
	          icon = '<span class="dashicons dashicons-arrow-right"></span>';
	          content = Utils.getI18nString('insight_analysis', [{
	            placeholder: 'query',
	            value: insight.query
	          }, {
	            placeholder: 'clickCount',
	            value: insight.clickCount
	          }, {
	            placeholder: 'postCount',
	            value: insight.postCount
	          }, {
	            placeholder: 'query',
	            value: insight.query
	          }]);
	          break;
	        case 'underdog':
	          icon = '<span class="dashicons dashicons-sos"></span>';
	          content = insight.postCount > 1 ? Utils.getI18nString('insight_underdog_plural', [{
	            placeholder: 'postCount',
	            value: insight.postCount
	          }]) : Utils.getI18nString('insight_underdog_singular');
	          break;
	      }
	      // phpcs:disable
	      insights += `
				<li class="searchwp-metrics__engine-suggestions-insight">
					<div class="searchwp-metrics__insight">
						${icon}
						<div class="searchwp-metrics__engine-suggestions-insight-content">
							<p>
								<span>${content}</span>
								<button class="searchwp-metrics-nonbutton" data-insight-index="${index}">${Utils.getI18nString('details')}</button>
							</p>
						</div>
					</div>
				</li>
			`;
	      // phpcs:enable
	    });
	    insights += '</ul>';
	    if (this.totalInsights > 3) {
	      // phpcs:disable
	      insights += `<button class="button searchwp-metrics__engine-suggestions-insights-viewall">${Utils.getI18nString('view_all')}</button>`;
	      // phpcs:enable
	    }
	    return insights;
	  }

	  /**
	   * Cache the elements for the Insights Details component.
	   *
	   * @since 1.4.5
	   */
	  cacheElements() {
	    this.$insights = this.$component.find('.searchwp-metrics__engine-suggestions-insights');
	    this.$spinner = this.$component.find('.loading-spinner-container');
	  }

	  /**
	   * Initialize the events for the Insights Details component.
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    jQuery(document).on("searchwp-metrics__loading-started", this.startLoadingState.bind(this));
	    jQuery(document).on("searchwp-metrics__loading-ended", this.endLoadingState.bind(this));
	    this.$insights.on('click', '.searchwp-metrics-nonbutton', event => {
	      let insightIndex = jQuery(event.target).data('insight-index');
	      this.insightsDetailsModal.openModal(insightIndex);
	    });
	    this.$component.on('click', '.searchwp-metrics__engine-suggestions-insights-viewall', () => {
	      this.insightsDetailsModal.openModal();
	    });
	  }

	  /**
	   * Start the loading state.
	   *
	   * @since 1.4.5
	   */
	  startLoadingState() {
	    this.engineData = {};
	    this.totalInsights = 0;
	    this.$spinner.removeClass('searchwp-metrics__hidden');
	  }

	  /**
	   * End the loading state.
	   *
	   * @since 1.4.5
	   */
	  endLoadingState() {}

	  /**
	   * Update the insights.
	   *
	   * @since 1.4.5
	   *
	   * @param insights
	   */
	  update(insights) {
	    if (!insights) {
	      return;
	    }
	    this.totalInsights = insights.length;
	    this.engineData.insights = insights.slice(0, 3);
	    this.$spinner.addClass('searchwp-metrics__hidden');
	    this.$insights.html(this.getEngineInsights());
	    this.insightsDetailsModal.updateContent(insights);
	  }

	  /**
	   * Remove the elements.
	   *
	   * @since 1.4.5
	   */
	  removeElements() {
	    this.$component.remove();
	    this.insightsDetailsModal.$modal.remove();
	  }
	}

	/**
	 * This class is responsible for setting up a popover menu.
	 *
	 * @since 1.4.5
	 */
	class MenuComponent {
	  constructor($parent) {
	    this.$parent = $parent;
	    this.$button = this.$parent.find('button');
	    this.$component = null;
	    this.initializeComponent();
	    this.initializeMenuEvents();
	  }

	  /**
	   * Initialize the popover menu.
	   *
	   * @since 1.4.5
	   */
	  initializeComponent() {
	    // HTML structure for a popover menu.
	    // phpcs:disable
	    const componentHTML = `
			<div class="popover-outer searchwp-metrics__hidden">
				<div class="popover-inner">
					<div>
						<ul></ul>
					</div>
				</div>
			</div>
		`;
	    // phpcs:enable

	    // Append the component HTML to the HTML body.
	    this.$component = jQuery(componentHTML).appendTo(this.$parent);
	    this.$menuItems = this.$component.find('ul');
	  }

	  /**
	   * Add items to the popover menu.
	   *
	   * @since 1.4.5
	   *
	   * @param items
	   */
	  addItems(items) {
	    if (items) {
	      items.forEach(item => {
	        let isHidden = item.hidden ? ' searchwp-metrics__hidden' : '';

	        // phpcs:disable
	        let $newItem = jQuery(`
						<li class="${isHidden}">
							<button id="${item.id}" class="searchwp-metrics-nonbutton">${item.label}</button>
						</li>
						`).appendTo(this.$menuItems);
	        // phpcs:enable

	        $newItem.on('click', event => {
	          // If item has a callback, call it.
	          if (item.callback) {
	            item.callback();
	          }
	          this.closePopover(event);
	        });
	      });
	    }
	  }

	  /**
	   * Initialize the events for the popover menu.
	   *
	   * @since 1.4.5
	   */
	  initializeMenuEvents() {
	    // Toggle the popover when the button is clicked.
	    this.$button.on('click', event => this.togglePopover(event));

	    // Close the popover when clicking outside of it.
	    jQuery(document).on('click', event => {
	      if (!this.$component.is(event.target) && !jQuery.contains(this.$component[0], event.target)) {
	        this.closePopover(event);
	      }
	    });

	    // Close the popover when the escape key is pressed.
	    jQuery(document).on('keydown', event => {
	      if (event.key === 'Escape') {
	        this.closePopover(event);
	      }
	    });

	    // Toggle a menu item event.
	    jQuery(document).on('searchwp-metrics__toggle-menu-item', (event, data) => {
	      // Get menu item from ID.
	      const $item = this.$menuItems.find('#' + data.id);
	      if ($item.length) {
	        $item.closest('li').toggleClass('searchwp-metrics__hidden', !data.show);
	      }
	    });
	  }

	  /**
	   * Toggle the popover.
	   *
	   * @since 1.4.5
	   *
	   * @param event
	   */
	  togglePopover(event) {
	    event.stopPropagation();
	    if (this.$component.hasClass('searchwp-metrics__hidden')) {
	      this.$component.removeClass('searchwp-metrics__hidden');
	    } else {
	      this.$component.addClass('searchwp-metrics__hidden');
	    }
	  }

	  /**
	   * Close the popover.
	   *
	   * @since 1.4.5
	   *
	   * @param event
	   */
	  closePopover(event) {
	    event.stopPropagation();
	    this.$component.addClass('searchwp-metrics__hidden');
	  }
	}

	/**
	 * This class handles the Engine Component.
	 *
	 * @since 1.4.5
	 */
	class EngineComponent {
	  constructor($parent, engineData) {
	    this.$parent = $parent;
	    this.$engine = null;
	    this.engineData = engineData;
	    this.engineDetails = {};
	    this.engineStatisticsComponent = null;
	    this.popularSearchesComponent = null;
	    this.insightsDetailsComponent = null;
	    this.menu = null;
	    this.initializeControl();
	    this.cacheElements();
	    this.initializeEvents();
	  }

	  /**
	   * Initialize the Engine Component.
	   *
	   * @since 1.4.5
	   */
	  initializeControl() {
	    // HTML structure for an Engine Details.
	    // phpcs:disable
	    const componentHTML = `
            <div class="searchwp-metrics__engine-details" data-swp-engine="${this.engineData.name}">
                <div class="searchwp-metrics__engine-details-heading-group">
                    <h3 class="searchwp-metrics__engine-details-heading">
                        <span class="searchwp-metrics__engine-details-legend" style="background-color: ${this.engineData.color}"></span>
                        <span>
						${Utils.getI18nString('engine_details_for_timeline', [{
      placeholder: 'engine.label',
      value: this.engineData.label
    }])}
						</span>
                    </h3>
                    <div id="searchwp-metrics__menu__${this.engineData.name}" class="searchwp-metrics__popover-menu searchwp-metrics__disable-on-loading">
						<button class="button"><span class="dashicons dashicons-menu"></span></button>
					</div>
                </div>
                <div class="searchwp-metrics__engine-details-hook">

                    <div class="searchwp-metrics__engine-details-alpha"></div>

                    <div class="searchwp-metrics__engine-details-beta searchwp-metrics__engine-popular-searches"></div>

                    <div class="searchwp-metrics__engine-details-omega searchwp-metrics__engine-suggestions"></div>
                </div>
                <div class="searchwp-metrics__no-data searchwp-metrics__hidden"><p>${Utils.getI18nString('not_enough_data')}</p></div>
            </div>
        `;
	    // phpcs:enable

	    // Append the control HTML to the parent element.
	    if (this.$parent) {
	      this.$engine = jQuery(componentHTML).appendTo(this.$parent);
	    }

	    // Engine Statistics.
	    this.engineStatisticsComponent = new EngineStatisticsComponent(this.$engine, this.engineData);

	    // Popular Searches.
	    this.popularSearchesComponent = new PopularSearchesComponent(this.$engine, this.engineData);

	    // Insights.
	    this.insightsDetailsComponent = new InsightsDetailsComponent(this.$engine, this.engineData);

	    // Menu.
	    this.setupMenu();
	  }

	  /**
	   * Cache the Engine Component elements.
	   *
	   * @since 1.4.5
	   */
	  cacheElements() {
	    this.$engineDetails = this.$engine.find('.searchwp-metrics__engine-details-hook');
	    this.$notEnoughDataNotice = this.$engine.find('.searchwp-metrics__no-data');
	  }

	  /**
	   * Initialize the Engine Component events.
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    jQuery(document).on("searchwp-metrics__loading-started", this.startLoadingState.bind(this));
	  }

	  /**
	   * Update the Engine Component.
	   *
	   * @since 1.4.5
	   *
	   * @param {Object} newData The new data to update.
	   * @param {string} metric The metric to update.
	   */
	  updateMetric(newData, metric) {
	    this.engineDetails = _objectSpread2(_objectSpread2({}, this.engineDetails), newData);
	    this.updateEngineDetails(metric);
	  }

	  /**
	   * Update the Engine Details.
	   *
	   * @since 1.4.5
	   *
	   * @param {string} metric The metric to update.
	   */
	  updateEngineDetails(metric) {
	    const {
	      total_searches,
	      failed_searches_over_time_count,
	      failed_searches_over_time,
	      total_clicks,
	      average_searches_per_user,
	      average_clicks_per_search,
	      average_click_rank,
	      popular_queries_over_time,
	      popular_clicks_over_time
	    } = this.engineDetails;
	    switch (metric) {
	      case 'total_searches':
	        this.engineStatisticsComponent.update(total_searches, 'total_searches');
	        break;
	      case 'failed_searches_over_time_count':
	        this.engineStatisticsComponent.update(failed_searches_over_time_count, 'failed_searches_over_time_count');
	        break;
	      case 'failed_searches_over_time':
	        this.engineStatisticsComponent.update(failed_searches_over_time, 'failed_searches_over_time');
	        break;
	      case 'total_clicks':
	        this.engineStatisticsComponent.update(total_clicks, 'total_clicks');
	        break;
	      case 'average_searches_per_user':
	        this.engineStatisticsComponent.update(average_searches_per_user, 'average_searches_per_user');
	        break;
	      case 'average_clicks_per_search':
	        this.engineStatisticsComponent.update(average_clicks_per_search, 'average_clicks_per_search');
	        break;
	      case 'average_click_rank':
	        this.engineStatisticsComponent.update(average_click_rank, 'average_click_rank');
	        break;
	      case 'popular_queries_over_time':
	        this.popularSearchesComponent.update(popular_queries_over_time, total_searches);
	        break;
	      case 'popular_clicks_over_time':
	        this.insightsDetailsComponent.update(popular_clicks_over_time);
	        break;
	    }
	    if (total_searches === 0) {
	      this.$notEnoughDataNotice.removeClass('searchwp-metrics__hidden');
	      this.$engineDetails.addClass('searchwp-metrics__hidden');
	    } else {
	      this.$notEnoughDataNotice.addClass('searchwp-metrics__hidden');
	      this.$engineDetails.removeClass('searchwp-metrics__hidden');
	    }
	  }

	  /**
	   * Set up the Engine Component Menu.
	   *
	   * @since 1.4.5
	   */
	  setupMenu() {
	    const menuItems = [{
	      id: this.engineData.name + '-export-searches-over-time',
	      label: Utils.getI18nString('export_searches_over_time'),
	      callback: () => this.exportSearchesOverTime()
	    }, {
	      id: this.engineData.name + '-export-engine-statistics',
	      label: Utils.getI18nString('export_engine_statistics'),
	      callback: () => this.exportEngineStatistics()
	    }, {
	      id: this.engineData.name + '-export-popular-searches',
	      label: Utils.getI18nString('export_popular_searches'),
	      callback: () => this.exportPopularSearches()
	    }];
	    this.menu = new MenuComponent(this.$engine.find('.searchwp-metrics__popover-menu')).addItems(menuItems);
	  }

	  /**
	   * Start the loading state.
	   *
	   * @since 1.4.5
	   */
	  startLoadingState() {
	    this.engineDetails = {};
	  }

	  /**
	   * Remove the Engine Component elements.
	   *
	   * @since 1.4.5
	   */
	  removeElements() {
	    this.engineStatisticsComponent.removeElements();
	    this.popularSearchesComponent.removeElements();
	    this.insightsDetailsComponent.removeElements();
	    this.$engine.remove();
	  }

	  /**
	   * Export the Searches Over Time.
	   *
	   * @since 1.4.5
	   */
	  exportSearchesOverTime() {
	    Utils.downloadCSV(this.engineDetails.searches_over_time, 'SearchesOverTime', {
	      'label': Utils.getI18nString('date'),
	      'searches': Utils.getI18nString('searches')
	    }, this.engineData.name);
	  }

	  /**
	   * Export the Engine Statistics.
	   *
	   * @since 1.4.5
	   */
	  exportEngineStatistics() {
	    Utils.downloadCSV([{
	      'label': Utils.getI18nString('total_searches'),
	      'value': this.engineDetails.total_searches
	    }, {
	      'label': Utils.getI18nString('no_results_searches'),
	      'value': this.engineDetails.failed_searches_over_time_count
	    }, {
	      'label': Utils.getI18nString('total_results_viewed'),
	      'value': this.engineDetails.total_clicks
	    }, {
	      'label': Utils.getI18nString('searches_per_user'),
	      'value': this.engineDetails.average_searches_per_user
	    }, {
	      'label': Utils.getI18nString('clicks_per_search'),
	      'value': this.engineDetails.average_clicks_per_search
	    }, {
	      'label': Utils.getI18nString('average_click_rank'),
	      'value': this.engineDetails.average_click_rank
	    }], 'EngineStatistics', {
	      'label': Utils.getI18nString('statistic'),
	      'value': Utils.getI18nString('value')
	    }, this.engineData.name);
	  }

	  /**
	   * Export the Popular Searches.
	   *
	   * @since 1.4.5
	   */
	  exportPopularSearches() {
	    Utils.downloadCSV(this.engineDetails.popular_queries_over_time, 'PopularSearches', {
	      'query': Utils.getI18nString('search_query'),
	      'count': Utils.getI18nString('searches')
	    }, this.engineData.name);
	  }
	}

	/**
	 * This class is responsible for setting up the Engines Details component.
	 *
	 * @since 1.4.5
	 */
	class EnginesDetails {
	  constructor($parent, engines) {
	    this.$parent = $parent;
	    this.engines = engines || [];
	    this.engineComponents = [];
	  }

	  /**
	   * Initialize the Engines Details component.
	   *
	   * @since 1.4.5
	   */
	  initializeEngines() {
	    this.engines.forEach(engine => {
	      this.engineComponents.push(new EngineComponent(this.$parent, {
	        name: engine.value,
	        label: engine.label,
	        color: engine.color
	      }));
	    });
	  }

	  /**
	   * Toggle the engines displayed in the Engines Details component.
	   *
	   * @since 1.4.5
	   *
	   * @param engines
	   */
	  toggleEngines(engines) {
	    // Remove all existing engine components.
	    this.engineComponents.forEach(engine => engine.removeElements());
	    this.engineComponents = [];

	    // Filter and sort engines based on the selected order.
	    this.engines = Utils.getEngines().filter(engine => engines.includes(engine.value)).sort((a, b) => engines.indexOf(a.value) - engines.indexOf(b.value));
	    this.initializeEngines();
	  }

	  /**
	   * Update the engine details.
	   *
	   * @since 1.4.5
	   *
	   * @param engineData
	   * @param metric
	   */
	  updateEngineDetails(engineData, metric) {
	    this.engineComponents.forEach((engine, index) => {
	      engine.updateMetric(engineData[index], metric);
	    });
	  }
	}

	/**
	 * This class handles the Clear Metrics Data Modal.
	 *
	 * @since 1.4.5
	 */
	class ClearMetricsDataModal extends ModalComponent {
	  constructor() {
	    super({
	      name: 'clear-metrics-data',
	      title: Utils.getI18nString('clear_metrics_data'),
	      width: '300px',
	      classes: 'searchwp-metrics__clear-data-modal',
	      scrollable: false
	    });
	    this.initializeModalContent();
	    this.cacheElements();
	    this.initializeEvents();
	  }

	  /**
	   * Initialize the modal content.
	   *
	   * @since 1.4.5
	   */
	  initializeModalContent() {
	    // HTML structure for the Clear Metrics Data Modal.
	    // phpcs:disable
	    const modalContentHTML = `
			<div class="searchwp-metrics__modal-confirmation">
				<h4>
					<span class="dashicons dashicons-arrow-right"></span>
					 ${Utils.getI18nString('are_you_sure')}
					 <span class="dashicons dashicons-arrow-left"></span>
				</h4>
				<p>${Utils.getI18nString('clear_metrics_data_note')}</p>
				<p>
				<span class="dashicons dashicons-info"></span>
					${Utils.getI18nString('clear_metrics_data_note_details')}
				</p>
				<ul class="searchwp-metrics__modal-confirmation--actions">
					<li><button id="confirm-clear-metrics-data" class="button">${Utils.getI18nString('clear_data')}</button></li>
					<li><button id="cancel-clear-metrics-data" class="searchwp-metrics-nonbutton">${Utils.getI18nString('cancel')}</button></li>
				</ul>
			</div>
		`;
	    // phpcs:enable

	    // Append the modal content HTML to the modal body.
	    this.$content.append(modalContentHTML);
	  }

	  /**
	   * Cache the modal elements.
	   *
	   * @since 1.4.5
	   */
	  cacheElements() {
	    this.$confirmButton = this.$content.find('#confirm-clear-metrics-data');
	    this.$cancelButton = this.$content.find('#cancel-clear-metrics-data');

	    // Loading Spinner.
	    this.$loadingSpinner = jQuery('.searchwp-metrics__loading');
	  }

	  /**
	   * Initialize the events for the Clear Metrics Data Modal
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    this.$confirmButton.on('click', this.clearMetricsData.bind(this));
	    this.$cancelButton.on('click', this.closeModal.bind(this));
	  }

	  /**
	   * Clear the metrics data.
	   *
	   * @since 1.4.5
	   */
	  clearMetricsData() {
	    let payload = {
	      action: 'searchwp_metrics_clear_metrics_data'
	    };

	    // We want the loading state to be triggered right away.
	    this.$loadingSpinner.removeClass('searchwp-metrics__hidden');
	    this.closeModal();

	    // Request the deletion and then update when it's done.
	    Utils.apiRequest(payload).then(() => {
	      this.$loadingSpinner.addClass('searchwp-metrics__hidden');
	      // Trigger an event to update Metrics data.
	      jQuery(document).trigger('searchwp-metrics__needs-update');
	    });
	  }
	}

	/**
	 * This class handles the Clear Metrics Data Before Modal.
	 *
	 * @since 1.4.5
	 */
	class ClearMetricsDataBeforeModal extends ModalComponent {
	  constructor() {
	    super({
	      name: 'clear-metrics-data-before',
	      title: Utils.getI18nString('clear_metrics_data_before'),
	      width: '300px',
	      classes: 'searchwp-metrics__clear-data-before-modal',
	      scrollable: false
	    });
	    this.initializeModalContent();
	    this.cacheElements();
	    this.initializeEvents();
	  }

	  /**
	   * Initialize the modal content.
	   *
	   * @since 1.4.5
	   */
	  initializeModalContent() {
	    // HTML structure for the Clear Metrics Data Modal.
	    // phpcs:disable
	    const modalContentHTML = `
			<div class="searchwp-metrics__modal-confirmation">
				<h4>
					<span class="dashicons dashicons-arrow-right"></span>
					 ${Utils.getI18nString('are_you_sure')}
					 <span class="dashicons dashicons-arrow-left"></span>
				</h4>
				<p>${Utils.getI18nString('clear_metrics_data_before_note')}</p>
				<p>
					<span class="dashicons dashicons-info"></span>
					${Utils.getI18nString('clear_metrics_data_note_details')}
				</p>
				<div class="searchwp-metrics__daterange-picker">
					<input type="text" name="daterange">
				</div>
				<ul class="searchwp-metrics__modal-confirmation--actions">
					<li><button id="confirm-clear-metrics-data" class="button">${Utils.getI18nString('clear_data')}</button></li>
					<li><button id="cancel-clear-metrics-data" class="searchwp-metrics-nonbutton">${Utils.getI18nString('cancel')}</button></li>
				</ul>
			</div>
		`;
	    // phpcs:enable

	    // Append the modal content HTML to the modal body.
	    this.$content.append(modalContentHTML);
	  }

	  /**
	   * Get the Date Range Picker configuration.
	   *
	   * @since 1.4.5
	   */
	  getDateRangePickerConfig() {
	    const {
	      options: {
	        default_clear_data_before_date
	      }
	    } = _SEARCHWP_METRICS_VARS;
	    const locale = {
	      format: 'YYYY-MM-DD',
	      separator: ` ${Utils.getI18nString('to')} `,
	      applyLabel: Utils.getI18nString('update'),
	      cancelLabel: Utils.getI18nString('close')
	    };
	    return {
	      parentEl: '.searchwp-metrics',
	      singleDatePicker: true,
	      opens: 'center',
	      showDropdowns: true,
	      linkedCalendars: false,
	      showCustomRangeLabel: true,
	      alwaysShowCalendars: true,
	      autoApply: false,
	      locale,
	      ranges: false,
	      startDate: new Date(default_clear_data_before_date),
	      minDate: Utils.getDateRangesMinDate(),
	      maxDate: Utils.getDateRangesMaxDate()
	    };
	  }

	  /**
	   * Cache the modal elements.
	   *
	   * @since 1.4.5
	   */
	  cacheElements() {
	    this.$confirmButton = this.$content.find('#confirm-clear-metrics-data');
	    this.$cancelButton = this.$content.find('#cancel-clear-metrics-data');

	    // Date range picker control.
	    this.$daterangePicker = this.$content.find('input[name="daterange"]');
	    this.$daterangePicker.daterangepicker(this.getDateRangePickerConfig());

	    // Loading Spinner.
	    this.$loadingSpinner = jQuery('.searchwp-metrics__loading');
	  }

	  /**
	   * Initialize the modal events.
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    this.$confirmButton.on('click', this.clearMetricsDataBefore.bind(this));
	    this.$cancelButton.on('click', this.closeModal.bind(this));
	  }

	  /**
	   * Clear the metrics data before the selected date.
	   *
	   * @since 1.4.5
	   */
	  clearMetricsDataBefore() {
	    let payload = {
	      action: 'searchwp_metrics_clear_metrics_data_before',
	      date: this.$daterangePicker.data('daterangepicker').startDate.toISOString().split('T')[0]
	    };

	    // We want the loading state to be triggered right away.
	    this.$loadingSpinner.removeClass('searchwp-metrics__hidden');
	    this.closeModal();

	    // Request the deletion and then update when it's done.
	    Utils.apiRequest(payload).then(() => {
	      this.$loadingSpinner.addClass('searchwp-metrics__hidden');
	      // Trigger an event to update Metrics data.
	      jQuery(document).trigger('searchwp-metrics__needs-update');
	    });
	  }
	}

	/**
	 * This class handles the Clear Metrics Data at Intervals Modal.
	 *
	 * @since 1.4.5
	 */
	class ClearMetricsDataAtIntervalsModal extends ModalComponent {
	  constructor() {
	    super({
	      name: 'clear-metrics-data-intervals',
	      title: Utils.getI18nString('clear_metrics_data_at_intervals'),
	      width: '300px',
	      classes: 'searchwp-metrics__clear-data-intervals-modal',
	      scrollable: false
	    });
	    this.initializeModalContent();
	    this.cacheElements();
	    this.initializeEvents();
	  }

	  /**
	   * Initialize the modal content.
	   *
	   * @since 1.4.5
	   */
	  initializeModalContent() {
	    // HTML structure for the Clear Metrics Data Modal.
	    // phpcs:disable
	    const modalContentHTML = `
			<div class="searchwp-metrics__modal-confirmation">
				<p>${Utils.getI18nString('clear_metrics_data_at_intervals_note')}</p>
				<p>
					<span class="dashicons dashicons-info"></span>
					${Utils.getI18nString('clear_metrics_data_note_details')}
				</p>
				<div class="searchwp-metrics">
					<select class="multiselect"></select>
				</div>
				<div class="clear-metrics-custom-interval searchwp-metrics__hidden">
					<input type="number" min="1" step="1" value="${Utils.getSetting('clear_data_interval_custom')}">
					<p class="description">${Utils.getI18nString('clear_metrics_data_interval_custom_note')}</p>
				</div>
				<ul class="searchwp-metrics__modal-confirmation--actions">
					<li><button id="confirm-clear-metrics-data" class="button">${Utils.getI18nString('save_close')}</button></li>
					<li><button id="cancel-clear-metrics-data" class="searchwp-metrics-nonbutton">${Utils.getI18nString('cancel')}</button></li>
				</ul>
			</div>
		`;
	    // phpcs:enable

	    // Append the modal content HTML to the modal body.
	    this.$content.append(modalContentHTML);

	    // Get the select element.
	    this.$select = this.$content.find('select');

	    // Initialize choices.js.
	    this.choices = new Choices(this.$select[0], {
	      allowHTML: false,
	      removeItemButton: false,
	      searchEnabled: false,
	      duplicateItemsAllowed: false,
	      shouldSort: false,
	      choices: Utils.getClearMetricsDataIntervals()
	    });
	  }

	  /**
	   * Cache the modal elements.
	   *
	   * @since 1.4.5
	   */
	  cacheElements() {
	    this.$customIntervalInput = this.$content.find('.clear-metrics-custom-interval input');
	    this.$customIntervalInputParent = this.$content.find('.clear-metrics-custom-interval');
	    this.$confirmButton = this.$content.find('#confirm-clear-metrics-data');
	    this.$cancelButton = this.$content.find('#cancel-clear-metrics-data');

	    // Loading Spinner.
	    this.$loadingSpinner = jQuery('.searchwp-metrics__loading');
	  }

	  /**
	   * Initialize the events for the Clear Metrics Data Modal
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    // Trigger a change event to show the custom interval input if the custom option is selected.
	    if ('custom' === this.$select.val()) {
	      this.$customIntervalInputParent.removeClass('searchwp-metrics__hidden');
	    }
	    this.$confirmButton.on('click', this.clearMetricsData.bind(this));
	    this.$cancelButton.on('click', this.closeModal.bind(this));

	    // Show the custom interval input when the custom option is selected.
	    this.$select.on('change', () => {
	      if ('custom' === this.$select.val()) {
	        this.$customIntervalInputParent.removeClass('searchwp-metrics__hidden');
	      } else {
	        this.$customIntervalInputParent.addClass('searchwp-metrics__hidden');
	      }
	    });
	  }

	  /**
	   * Clear the metrics data.
	   *
	   * @since 1.4.5
	   */
	  clearMetricsData() {
	    let interval = this.$select.val();
	    let customInterval = this.$customIntervalInput.val();
	    let payload = {
	      action: 'searchwp_metrics_set_clear_metrics_data_interval',
	      interval: interval,
	      custom_interval: customInterval
	    };

	    // We want the loading state to be triggered right away.
	    this.$loadingSpinner.removeClass('searchwp-metrics__hidden');
	    this.closeModal();

	    // Request the deletion and then update when it's done.
	    Utils.apiRequest(payload).then(() => {
	      this.$loadingSpinner.addClass('searchwp-metrics__hidden');
	    });
	  }
	}

	/**
	 * This class handles the Clear Ignored Queries Modal.
	 *
	 * @since 1.4.5
	 */
	class ClearAllIgnoredQueriesModal extends ModalComponent {
	  constructor() {
	    super({
	      name: 'clear-ignored-queries',
	      title: Utils.getI18nString('remove_all_ignored_queries'),
	      width: '300px',
	      classes: 'searchwp-metrics__clear-ignored-queries-modal',
	      scrollable: false
	    });
	    this.initializeModalContent();
	    this.cacheElements();
	    this.initializeEvents();
	  }

	  /**
	   * Initialize the modal content.
	   *
	   * @since 1.4.5
	   */
	  initializeModalContent() {
	    // HTML structure for the Remove Ignored Queries Modal.
	    // phpcs:disable
	    const modalContentHTML = `
			<div class="searchwp-metrics__modal-confirmation">
				<h4>
					<span class="dashicons dashicons-arrow-right"></span>
					 ${Utils.getI18nString('are_you_sure')}
					 <span class="dashicons dashicons-arrow-left"></span>
				</h4>
				<p>${Utils.getI18nString('clear_ignored_queries_note')}</p>
				<ul class="searchwp-metrics__modal-confirmation--actions">
					<li><button id="confirm-clear-ignored-queries" class="button">${Utils.getI18nString('clear_data')}</button></li>
					<li><button id="cancel-clear-ignored-queries" class="searchwp-metrics-nonbutton">${Utils.getI18nString('cancel')}</button></li>
				</ul>
			</div>
		`;
	    // phpcs:enable

	    // Append the modal content HTML to the modal body.
	    this.$content.append(modalContentHTML);
	  }

	  /**
	   * Cache the modal elements.
	   *
	   * @since {VERSION
	   */
	  cacheElements() {
	    this.$confirmClearIgnoredQueries = this.$content.find('#confirm-clear-ignored-queries');
	    this.$cancelClearIgnoredQueries = this.$content.find('#cancel-clear-ignored-queries');

	    // Loading Spinner.
	    this.$loadingSpinner = jQuery('.searchwp-metrics__loading');
	  }

	  /**
	   * Initialize the events for the Clear Ignored Queries Modal
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    this.$confirmClearIgnoredQueries.on('click', () => this.clearIgnoredQueries());
	    this.$cancelClearIgnoredQueries.on('click', () => this.closeModal());
	  }

	  /**
	   * Clear all ignored queries.
	   *
	   * @since 1.4.5
	   */
	  clearIgnoredQueries() {
	    let payload = {
	      action: 'searchwp_metrics_clear_ignored_queries'
	    };

	    // We want the loading state to be triggered right away.
	    this.$loadingSpinner.removeClass('searchwp-metrics__hidden');
	    this.closeModal();

	    // Request the deletion and then update when it's done.
	    Utils.apiRequest(payload).then(() => {
	      this.$loadingSpinner.addClass('searchwp-metrics__hidden');
	      // Trigger an event to update Metrics data.
	      jQuery(document).trigger('searchwp-metrics__needs-update');
	    });
	  }
	}

	/**
	 * This class is responsible for setting up the Logging Rules Modal.
	 *
	 * @since 1.4.5
	 */
	class LoggingRulesModal extends ModalComponent {
	  /**
	   * Initialize the Logging Rules Modal.
	   *
	   * @since 1.4.5
	   */
	  constructor() {
	    super({
	      name: 'logging-rules',
	      title: Utils.getI18nString('logging_rules'),
	      width: '400px',
	      classes: 'searchwp-metrics__logging-rules-modal',
	      scrollable: false
	    });
	    this.initializeModalContent();
	    this.cacheElements();
	    this.initializeEvents();
	  }

	  /**
	   * Initialize the content of the Logging Rules Modal.
	   *
	   * @since 1.4.5
	   */
	  initializeModalContent() {
	    let blocklists = Utils.getSetting('blocklists');
	    let roles = blocklists.roles ? blocklists.roles : '';
	    let ips = blocklists.ips ? blocklists.ips : '';

	    // HTML structure for the Logging Rules Modal.
	    // phpcs:disable
	    const modalContentHTML = `
			<div>
				<p>${Utils.getI18nString('logging_rules_note')}</p>
				<p>
					<span class="dashicons dashicons-info"></span>
					${Utils.getI18nString('logging_rules_note_details')}
				</p>
				<div class="searchwp-metrics__textarea">
					<label for="searchwp_metrics_ip_blocklist">${Utils.getI18nString('user_id_role_blocklist')}</label>
					<textarea name="searchwp_metrics_role_blocklist" id="searchwp_metrics_role_blocklist" cols="30" rows="10">${roles}</textarea>
					<p class="description">${Utils.getI18nString('user_id_role_blocklist_note')}</p>
				</div>
				<div class="searchwp-metrics__textarea">
					<label for="searchwp_metrics_ip_blocklist">${Utils.getI18nString('ip_blocklist')}</label>
					<textarea name="searchwp_metrics_ip_blocklist" id="searchwp_metrics_ip_blocklist" cols="30" rows="10">${ips}</textarea>
					<p class="description">${Utils.getI18nString('ip_blocklist_note')}</p>
				</div>
				<ul class="searchwp-metrics__modal-confirmation--actions">
					<li><button id="save-metrics-logging-rules" class="button">${Utils.getI18nString('save_close')}</button></li>
				</ul>
			</div>
		`;
	    // phpcs:enable

	    // Append the modal content HTML to the modal body.
	    this.$content.append(modalContentHTML);
	  }

	  /**
	   * Cache the elements of the Logging Rules Modal.
	   *
	   * @since 1.4.5
	   */
	  cacheElements() {
	    // Textarea elements.
	    this.$roleBlocklistTextarea = this.$content.find('#searchwp_metrics_role_blocklist');
	    this.$ipBlocklistTextarea = this.$content.find('#searchwp_metrics_ip_blocklist');
	    this.$saveButton = this.$content.find('#save-metrics-logging-rules');

	    // Loading Spinner.
	    this.$loadingSpinner = jQuery('.searchwp-metrics__loading');
	  }

	  /**
	   * Initialize the events for the Logging Rules Modal.
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    this.$saveButton.on('click', this.saveLoggingRules.bind(this));
	  }

	  /**
	   * Save the Logging Rules.
	   * This will update the blocklists for roles and IPs.
	   *
	   * @since 1.4.5
	   */
	  saveLoggingRules() {
	    let payload = {
	      action: 'searchwp_metrics_update_logging_rules',
	      roles: this.$roleBlocklistTextarea.val(),
	      ips: this.$ipBlocklistTextarea.val()
	    };

	    // We want the loading state to be triggered right away.
	    this.$loadingSpinner.removeClass('searchwp-metrics__hidden');
	    this.closeModal();

	    // Request the deletion and then update when it's done.
	    Utils.apiRequest(payload).then(() => {
	      this.$loadingSpinner.addClass('searchwp-metrics__hidden');
	    });
	  }
	}

	/**
	 * This class is responsible for setting up the General Settings modal.
	 *
	 * @since 1.4.5
	 */
	class GeneralSettingsModal extends ModalComponent {
	  constructor() {
	    super({
	      name: 'settings',
	      title: Utils.getI18nString('settings'),
	      width: '400px',
	      classes: 'searchwp-metrics__settings-modal',
	      scrollable: false
	    });
	    this.initializeModalContent();
	    this.cacheElements();
	    this.initializeEvents();
	  }

	  /**
	   * Initialize the modal content.
	   *
	   * @since 1.4.5
	   */
	  initializeModalContent() {
	    let clickTrackBuoy = Utils.getSetting('click_tracking_buoy');
	    let clearDataOnUninstall = Utils.getSetting('clear_data_on_uninstall') ? ' checked' : '';

	    // HTML structure for the Logging Rules Modal.
	    // phpcs:disable
	    const modalContentHTML = `
			<div>
				<div class="searchwp-metrics__checkbox">
						<input type="checkbox" name="searchwp_metrics_click_track_buoy" id="searchwp_metrics_click_track_buoy" ${clickTrackBuoy ? ' checked' : ''}>
						<div class="searchwp-metrics__checkbox-label">
							<label for="searchwp_metrics_click_track_buoy">${Utils.getI18nString('click_tracking_buoy')}</label>
							<p class="description">${Utils.getI18nString('click_tracking_buoy_label_note')}</p>
						</div>
					</div>
					<div class="searchwp-metrics__checkbox">
						<input type="checkbox" name="searchwp_metrics_clear_data_on_uninstall" id="searchwp_metrics_clear_data_on_uninstall" ${clearDataOnUninstall ? ' checked' : ''}>
						<div class="searchwp-metrics__checkbox-label">
							<label for="searchwp_metrics_clear_data_on_uninstall">${Utils.getI18nString('remove_on_uninstallation')}</label>
							<p class="description">${Utils.getI18nString('remove_on_uninstallation_label_note')}</p>
						</div>
					</div>
					<ul class="searchwp-metrics__modal-confirmation--actions">
						<li>
							<button class="button">${Utils.getI18nString('save_close')}</button>
						</li>
					</ul>
			</div>
		`;
	    // phpcs:enable

	    // Append the modal content HTML to the modal body.
	    this.$content.append(modalContentHTML);
	  }

	  /**
	   * Cache the modal elements.
	   *
	   * @since 1.4.5
	   */
	  cacheElements() {
	    // Checkbox elements by ID.
	    this.$clickTrackBuoy = this.$content.find('#searchwp_metrics_click_track_buoy');
	    this.$clearDataOnUninstall = this.$content.find('#searchwp_metrics_clear_data_on_uninstall');
	    this.$saveButton = this.$content.find('button');

	    // Loading Spinner.
	    this.$loadingSpinner = jQuery('.searchwp-metrics__loading');
	  }

	  /**
	   * Initialize the events for the General Settings modal.
	   *
	   * @since 1.4.5
	   */
	  initializeEvents() {
	    this.$saveButton.on('click', this.saveSettings.bind(this));
	  }

	  /**
	   * Save the settings.
	   *
	   * @since 1.4.5
	   */
	  saveSettings() {
	    let clickTrackBuoy = this.$clickTrackBuoy.prop('checked');
	    let clearDataOnUninstall = this.$clearDataOnUninstall.prop('checked');
	    let payload = {
	      action: 'searchwp_metrics_update_settings',
	      clear_data_on_uninstall: clearDataOnUninstall,
	      click_tracking_buoy: clickTrackBuoy
	    };

	    // We want the loading state to be triggered right away.
	    this.$loadingSpinner.removeClass('searchwp-metrics__hidden');
	    this.closeModal();

	    // Request the deletion and then update when it's done.
	    Utils.apiRequest(payload).then(() => {
	      this.$loadingSpinner.addClass('searchwp-metrics__hidden');
	    });
	  }
	}

	/**
	 * This class is responsible for setting up the App menu.
	 *
	 * @since 1.4.5
	 */
	class AppMenu {
	  constructor($parent) {
	    this.$parent = $parent;
	    this.menuItems = [];
	    this.setupModals();
	    this.setupMenu();
	  }

	  /**
	   * Set up the modals that will be used in the App menu.
	   *
	   * @since 1.4.5
	   */
	  setupModals() {
	    // Clear Metrics Data.
	    let clearMetricsDataModal = new ClearMetricsDataModal();
	    this.menuItems.push({
	      id: 'clear-metrics-data',
	      label: Utils.getI18nString('clear_metrics_data'),
	      callback: () => clearMetricsDataModal.openModal()
	    });

	    // Clear Metrics Data Before.
	    let clearMetricsDataBeforeModal = new ClearMetricsDataBeforeModal();
	    this.menuItems.push({
	      id: 'clear-metrics-data-before',
	      label: Utils.getI18nString('clear_metrics_data_before'),
	      callback: () => clearMetricsDataBeforeModal.openModal()
	    });

	    // Clear Metrics Data at Intervals.
	    let clearMetricsDataAtIntervalsModal = new ClearMetricsDataAtIntervalsModal();
	    this.menuItems.push({
	      id: 'clear-metrics-data-at-intervals',
	      label: Utils.getI18nString('clear_metrics_data_at_intervals'),
	      callback: () => clearMetricsDataAtIntervalsModal.openModal()
	    });

	    // Clear Ignored Queries.
	    let clearAllIgnoredQueriesModal = new ClearAllIgnoredQueriesModal();
	    this.menuItems.push({
	      id: 'clear-ignored-queries',
	      label: Utils.getI18nString('remove_all_ignored_queries'),
	      callback: () => clearAllIgnoredQueriesModal.openModal(),
	      hidden: true
	    });

	    // Logging Rules.
	    let loggingRulesModal = new LoggingRulesModal();
	    this.menuItems.push({
	      id: 'logging-rules',
	      label: Utils.getI18nString('logging_rules'),
	      callback: () => loggingRulesModal.openModal()
	    });

	    // General Settings.
	    let generalSettingsModal = new GeneralSettingsModal();
	    this.menuItems.push({
	      id: 'general-settings',
	      label: Utils.getI18nString('settings'),
	      callback: () => generalSettingsModal.openModal()
	    });
	  }

	  /**
	   * Set up the App menu.
	   *
	   * @since 1.4.5
	   */
	  setupMenu() {
	    this.menuComponent = new MenuComponent(this.$parent);
	    this.menuComponent.addItems(this.menuItems);
	  }
	}

	/* global _SEARCHWP_METRICS_VARS */
	(function ($) {

	  const app = {
	    /**
	     * Initialize the app.
	     *
	     * @since 1.4.5
	     */
	    init: function () {
	      app.data = {};
	      app.metricsToLoad = ['searches_over_time', 'ignored_queries', 'failed_searches_over_time', 'total_clicks', 'average_searches_per_user', 'average_clicks_per_search', 'average_click_rank', 'popular_queries_over_time', 'popular_clicks_over_time'];
	      $(document).ready(app.ready);
	    },
	    /**
	     * Run the app.
	     *
	     * @since 1.4.5
	     */
	    ready: () => {
	      app.setupComponents();
	      app.events();
	      app.update();
	    },
	    /**
	     * Set up the app components.
	     *
	     * @since 1.4.5
	     */
	    setupComponents: function () {
	      const $appMenu = $('#searchwp-metrics__menu');
	      const $controls = $('.searchwp-metrics__controls');
	      const $searchesOverTime = $('.searchwp-metrics__searches-over-time');
	      const $engines = $('.searchwp-metrics__engines');

	      // Main Menu.
	      app.menu = new AppMenu($appMenu);

	      // Controls.
	      app.dateRangePicker = new DaterangePickerControl($controls);
	      app.searchQuery = new SearchQueryControl($controls);
	      app.engines = new EnginesControl($controls);

	      // Engine Details.
	      app.searchesOverTime = new SearchesOverTimeChart($searchesOverTime);
	      app.enginesDetails = new EnginesDetails($engines, app.engines.getSelectedEngines());
	    },
	    /**
	     * Set up the app events.
	     *
	     * @since 1.4.5
	     */
	    events: function () {
	      // Listens for any update events triggered by the components.
	      $(document).on("searchwp-metrics__needs-update", app.update);
	    },
	    /**
	     * Update the Metrics.
	     *
	     * @since 1.4.5
	     */
	    update: function () {
	      let engines = app.engines.getSelectedEngines();
	      app.enginesDetails.toggleEngines(engines);
	      app.startLoadingEvent();
	      app.requestMetricsData();
	    },
	    /**
	     * Request the metrics data.
	     *
	     * @since 1.4.5
	     */
	    requestMetricsData: function () {
	      let metricsRequests = app.metricsToLoad;
	      let fetched = [];
	      let promises = [];

	      // Initial request. This will fetch the first set of metrics.
	      Utils.apiRequest(app.getRequestPayload(metricsRequests)).then(function (response) {
	        // Update the metrics data coming from the initial request.
	        app.updateMetricsData(response.data);

	        // Remove the fetched metrics from the list of metrics to fetch.
	        fetched = fetched.concat(Object.keys(response.data));
	        metricsRequests = metricsRequests.filter(metric => !fetched.includes(metric));

	        // If there are no more metrics to fetch, we can stop here.
	        if (metricsRequests.length === 0) {
	          app.endLoadingEvent();
	          return;
	        }

	        // Fetch the remaining metrics.
	        promises = metricsRequests.map(async function (metric) {
	          return Utils.apiRequest(app.getRequestPayload([metric])).then(function (response) {
	            app.updateMetricsData(response.data);
	          });
	        });

	        // Wait for all promises to resolve. This will ensure that all metrics are fetched before stopping the loading state.
	        Promise.all(promises).then(function () {
	          app.endLoadingEvent();
	        });
	      });
	    },
	    /**
	     * Update the metrics data.
	     *
	     * @since 1.4.5
	     *
	     * @param data
	     */
	    updateMetricsData: function (data) {
	      Object.keys(data).forEach(metric => {
	        switch (metric) {
	          case 'searches_over_time':
	            app.searchesOverTime.updateChart(data[metric]);
	            app.enginesDetails.updateEngineDetails(Utils.getMetricCount(data[metric].datasets, 'total_searches'), 'total_searches');
	            app.enginesDetails.updateEngineDetails(Utils.getSearchesOverTimeMetric(data[metric], metric), metric);
	            break;
	          case 'failed_searches_over_time':
	            app.enginesDetails.updateEngineDetails(Utils.getMetricCount(data[metric], 'failed_searches_over_time_count'), 'failed_searches_over_time_count');
	            app.enginesDetails.updateEngineDetails(Utils.getFailedSearchesList(data[metric], metric), metric);
	            break;
	          case 'total_clicks':
	            app.enginesDetails.updateEngineDetails(Utils.getMetricStatistic(data[metric], metric), metric);
	            break;
	          case 'average_searches_per_user':
	            app.enginesDetails.updateEngineDetails(Utils.getMetricStatistic(data[metric], metric), metric);
	            break;
	          case 'average_clicks_per_search':
	            app.enginesDetails.updateEngineDetails(Utils.getMetricStatistic(data[metric], metric), metric);
	            break;
	          case 'average_click_rank':
	            app.enginesDetails.updateEngineDetails(Utils.getMetricStatistic(data[metric], metric), metric);
	            break;
	          case 'popular_queries_over_time':
	            app.enginesDetails.updateEngineDetails(Utils.getPopularSearchesOverTime(data[metric], metric), metric);
	            break;
	          case 'ignored_queries':
	            app.searchQuery.updateIgnoredQueries(data[metric]);
	            break;
	          case 'popular_clicks_over_time':
	            app.enginesDetails.updateEngineDetails(Utils.getInsights(data[metric], metric), metric);
	            break;
	        }
	      });
	    },
	    /**
	     * Get the request payload.
	     *
	     * @since 1.4.5
	     *
	     * @param metrics
	     *
	     * @returns {{searches, before: (null|*), engines: *, limit: number, action: string, metrics, after: (null|*)}}
	     */
	    getRequestPayload: function (metrics) {
	      return {
	        action: 'searchwp_metrics',
	        metrics: metrics,
	        limit: 10,
	        searches: app.searchQuery.getSelectedQueries(),
	        engines: app.engines.getSelectedEngines(),
	        before: app.dateRangePicker.endDate,
	        after: app.dateRangePicker.startDate
	      };
	    },
	    /**
	     * Start the loading event.
	     *
	     * @since 1.4.5
	     */
	    startLoadingEvent: function () {
	      $('.searchwp-metrics__disable-on-loading').addClass('searchwp-metrics__disabled');
	      $(document).trigger('searchwp-metrics__loading-started');
	    },
	    /**
	     * End the loading event.
	     *
	     * @since 1.4.5
	     */
	    endLoadingEvent: function () {
	      $('.searchwp-metrics__disable-on-loading').removeClass('searchwp-metrics__disabled');
	      $(document).trigger('searchwp-metrics__loading-ended');
	    }
	  };
	  app.init();
	  window.searchwp_metrics = window.searchwp_metrics || {};
	  window.searchwp_metrics = app;
	})(jQuery);

})(jQuery);
